---
title: 1025 反转链表
date: 2021-01-11 22:15:32
index_img: https://tva3.sinaimg.cn/large/0060lm7Tly1ftg6owkw9lj31hc0u0tt9.jpg
tags: [PAT, 链表, 算法]
categories: [PAT]
---

# 1025 反转链表

## 题目

{% note warning %}
难度：中等
{% endnote %}

![反转链表](https://gitee.com/yoyhm/oss/raw/master/uPic/CSJuhH.png)

## 思路

> 本题看起来不难，但是和**leetcode**不一样，他的数据是自己输入，因此还需要构造一个数据结构来存储每个输入数据

1. 创建一个结构体如下，存储链表。其中使用一个`order`来表示链表的顺序。

```C++
const int maxn = 100010;
struct Node{
    int address, next, order, data;
}node[maxn];
```

- address:该结点地址
- next:下一个结点地址
- order:结点在链表中的顺序。初始值为`maxn`
- data:结点数据

2. 设置一个变量`count`,根据输入的首地址`begin`，给每个结点的`order`编号。最后让`n=count`.这一步很重要，因为可能给出的数据有两个链表。

```C++
int count = 0;
while (begin_address != -1) { // 计算链表的顺序
	node[begin_address].order = count++;
	begin_address = node[begin_address].next;
}
n = count; // 这里需要处理一下，有时候会出现两个结点。部分用例无法通过
sort(node, node + maxn, cmp); // 按照链表顺序进行排序，即有效数组都在前面。
```

3. 对结点进行排序，然后分成`group = n / k`,每k个一组倒叙输出。每组的最后一个结点的`next`指向的是当前组的下一组的最后一个结点`address`。
4. ⚠️对最后一组需要单独判断。若当前是最后一组，判断是否还存在多余的小于k的结点，若存在，对最后剩余结点正序输出。若不存在，输出`-1`。

## 代码

C++

```C++
#include <cstdio>
#include <algorithm>
using namespace std;
const int maxn = 100010;

struct Node{
    int address, next, order, data;
}node[maxn];

bool cmp(Node a, Node b) {
    return a.order < b.order;
}

int main() {
    int begin_address, n, k;
    int address;
    scanf("%d%d%d", &begin_address, &n, &k);
    for (int i = 0; i < n; i++) {
        scanf("%d", &address);
        scanf("%d%d", &node[address].data, &node[address].next);
        node[address].address = address;
    }
    // 初始化数组的order，方便排序
    for (int i = 0; i < maxn; i++) {node[i].order = maxn;}
    int count = 0;
    while (begin_address != -1) { // 计算链表的顺序
        node[begin_address].order = count++;
        // count++;
        begin_address = node[begin_address].next;
    }
    // node[begin_address].order = count; // 最后一个等于-1也要标注order
    sort(node, node + maxn, cmp); // 按照链表顺序进行排序，即有效数组都在前面。
    n = count; // 这里需要处理一下，有时候会出现两个节点。部分用例无法通过
    // 开始按照k个一组进行倒叙输出。
    // 注意每组最后一个节点的next都是下一组的最后一个节点。
    // 但是若是该组的下一组节点数量小于k，即下一个节点就是最后一组的第一个节点
    // 若该组本身就是最后一个节点，那么下一个节点就是-1
    int group = n / k; // 满足每组k个数的组的数量
    // 先处理前面group组
    for (int i = 0; i < group; i++) {
        // 倒叙输出第i组,注意每组最后一个node不要输出
        for (int j = (i + 1) * k - 1; j > i * k; j--) {
            printf("%05d %d %05d\n", node[j].address, node[j].data, node[j - 1].address);
        }
        // 处理最后一个node的下一个节点
        printf("%05d %d ", node[i * k].address, node[i * k].data);
        // 如果当前i是最后一组
        if (i == group - 1) {
            // 判断是否还存在小于k的最后一组组
            if (n % k == 0) {printf("%d\n", -1);}
            else { // 存在第group+1组
                printf("%05d\n", node[group * k].address); // 指向group+1组的第一个节点。
                for (int r = group * k; r < n - 1; r++) {
                    printf("%05d %d %05d\n", node[r].address, node[r].data, node[r + 1].address);
                }
                printf("%05d %d %d\n", node[n - 1].address, node[n - 1].data, -1);
            }
        } else {
            // 如果不是最后一组，那么当前组的最后一个node的next指向下一个组的最后一个节点。
            printf("%05d\n", node[(i + 2)*k - 1].address);
        }
    }
    return 0;
}
```

## 其他

难点

- 构造一个恰当的结构体
- 测试用例中存在多个`next = -1`,即多条链表,所以需要使用`count`记录有效结点，然后使用`n = count`
