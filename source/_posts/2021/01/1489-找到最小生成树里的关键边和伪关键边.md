---
title: 1489. 找到最小生成树里的关键边和伪关键边
date: 2021-01-21 09:30:03
tags: [leetcode, 算法, union-find, Kruskal, 最小生成树]
categories: [LeetCode]
index_img: https://tva4.sinaimg.cn/large/87c01ec7gy1frmrtnq32hj21hc0u0wnl.jpg
---

# [1489. 找到最小生成树里的关键边和伪关键边](https://leetcode-cn.com/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/)

## 题目

![Yu4UTc](https://gitee.com/yoyhm/oss/raw/master/uPic/Yu4UTc.png)

## 思路

本题参考[官方解答](https://leetcode-cn.com/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/solution/zhao-dao-zui-xiao-sheng-cheng-shu-li-de-gu57q/)，用简单的话来理解什么是关键边和伪关键边。

- **关键边**: 当图中删除这条边的时候，无法形成最小生成树或是权值大于最小生成树的权值。所以**删除这条边了影响生成最佳的最小生成树**
- **伪关键边**: 该边只出现在部分最小生成树中，不会出现在所有最小生成树中。

根据上面可以得到，若改边是**关键边**，则就不需要判断它是不是**伪关键边**了，因为**关键边**一定出现在每个最小生成树中。所以可以对一条边先进行判断是否是关键边，若是，则不需要判断是伪关键边。若不是则需要判断是不是伪关键边。

步骤

1. 先使用`Kruskal`+`UnionFind`计算出最小生成树的权值`minWeight`.
2. 在对每条边依次判断。
3. 关键边，在并查集中不加入边，判断改变是否对最小生成树和权值有影响。

```C++
if (i != j && (uf.find(u) != uf.find(v)))
```

4. 伪关键边，在判断完不是关键边后，把这条边作为第一条连接的边加入并查集中，然后去继续判断生成的树权值是否和`minWeight`相等，若相等，则证明该边在当前生成树中是有效的边，加入到伪关键边中。

## 代码

```C++
class UnionFind {
    private:
    vector<int> parent;
    int num;
    public:
    UnionFind(int n) {
        num = n;
        for (int i = 0; i < n; i++) parent.push_back(i);
    }
    int find(int x) {
        if (x != parent[x]) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }
    void quick_union(int v, int w) {
        int vRoot = find(v), wRoot = find(w);
        if (vRoot == wRoot) return;
        parent[find(v)] = find(w);
        num--;
    }
    int getCount() { // 获取连通分量个数
        return num;
    }
};

class Solution {
public:
    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {
        // 使用官方的思路
        // 1. 先求出最小生成树的权值
        // 2. 关键边，依次对每条边判断，若该边不存在，是否影响到权值
        // 3. 非关键边，优先连接该边，若value相同，则证明该边不影响最终结果

        // 0. 记录关键边的下标，因为题目要求返回的下标，等会按权值排序会打乱下标
        int size = edges.size();
        for (int i = 0; i < size; i++) {edges[i].push_back(i);}

        // 1.1 对权边排序
        sort(edges.begin(), edges.end(), [](const auto& a,const auto& b) {
            return a[2] < b[2];
        });
        // 1.2 依次对权值最小边进行合并,并求出最小权值和
        UnionFind uf(n);
        int minWeight = 0;
        for (int i = 0; i < size; i++) {
            int u = edges[i][0], v = edges[i][1];
            if (uf.find(u) != uf.find(v)) {
                uf.quick_union(u, v);
                minWeight += edges[i][2];
            }
        }
        // 2. 依次排除一条边，判断权值是否变化，若变大，则证明该边是关键边
        vector<vector<int>> ans(2);
        for (int i = 0; i < size; i++) {
            // 2.1 找出关键边
            UnionFind uf(n);
            int weight = 0;
            for (int j = 0; j < size; j++) {
                int u = edges[j][0], v = edges[j][1];
                if (i != j && (uf.find(u) != uf.find(v))) {
                    uf.quick_union(u, v);
                    weight += edges[j][2];
                }
            }
            // 2.2 关键边去除是无法形成最小生成树的或形成了生成树，但是权值增大。
            if (uf.getCount() != 1 || (uf.getCount() == 1 && weight > minWeight)) {
                ans[0].push_back(edges[i][3]);
                continue; // 既然是关键边，那么肯定是非关键边。
            }
            // 2.2 找出非关键边。非关键去除也对最小权值没有影响。
            // UnionFind uf(n); 这种写法错误，会导致重新定义
            uf = UnionFind(n);
            uf.quick_union(edges[i][0], edges[i][1]); // 先连接改边，若改变对结果没有影响。那么他就是非关键边
            weight = edges[i][2];
            for (int j = 0; j < size; j++) {
                int u = edges[j][0], v = edges[j][1];
                if (i != j && (uf.find(u) != uf.find(v))) {
                    uf.quick_union(u, v);
                    weight += edges[j][2];
                }
            }
            if (weight == minWeight) {
                ans[1].push_back(edges[i][3]); // 把非关键边下标放进去
            }
        }

        return ans;
    }
};
```

## 其他

- C++ iota函数用法详解[^1]

在官方题解中，看到在并查集中有这样的写法

```C++
UnionFind(int _n): n(_n), setCount(_n), parent(_n), size(_n, 1) {
	iota(parent.begin(), parent.end(), 0);
}
```

定义在 numeric 头文件中的 iota() 函数模板会用连续的 T 类型值填充序列。

	- 前两个参数是定义序列的正向迭代器，第三个参数是初始的 T 值。
	- 第三个指定的值会被保存到序列的第一个元素中。保存在第一个元素后的值是通过对前面的值**运用自增运算符得到的**。当然，这意味着 T 类型必须支持 operator++()。

下面展示了如何生成一个有连续的浮点值元素的 vector 容器：

```C++
std::vector<double> data(9);
double initial {-4};
std::iota (std::begin (data) , std::end (data) , initial);
std::copy(std::begin(data), std::end(data),std::ostream_iterator<double>{std::cout<< std::fixed << std::setprecision(1), " "});
std::cout << std::endl;  // -4.0 -3.0 -2.0 -1.0 0.0 1.0 2.0 3.0 4.0
```

- 排序 sort vector，並使用 lambda function 匿名函式排序(升序)[^2]

很多语言都要匿名函数，那么在C++中如何写呢？

这是本题的匿名函数在排序中使用

```C++
sort(edges.begin(), edges.end(), [](const auto& a,const auto& b) {
	return a[2] < b[2];
});
```

```C++
std::sort(v.begin(), v.end(), [](int a, int b){
	return a < b; // 升序排列
});
```

参考上面的两个例子，匿名函数的写法应该是

```C++
sort(head_address，end_address，[](auto& a, auto& b) {
	return a < b; // a b 的一些比较
})
```

[^1]: [C++ iota函数用法详解](http://c.biancheng.net/view/681.html)
[^2]: [](https://shengyu7697.github.io/blog/2019/11/30/std-sort/)
