---
title: 1579. 保证图可完全遍历
date: 2021-01-27 09:24:56
tags: [leetcode, 算法, union-find]
categories: [LeetCode]
index_img: https://tva1.sinaimg.cn/large/0060lm7Tly1ftg6xhyidxj31hc0u0x6p.jpg
---

# [1579. 保证图可完全遍历](https://leetcode-cn.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/)

## 题目

![Xesr5M](https://gitee.com/yoyhm/oss/raw/master/uPic/Xesr5M.png)

## 思路

参考[[Python] [动画] 先看Alice再看Bob
](https://leetcode-cn.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/solution/python-dong-hua-xian-kan-alicezai-kan-bo-kavo/)

步骤

1. 分别设置两个图，在设置一个变量`ans`存储无效边（被删除边）
2. 先连接他们公共边，若改边已经存在，证明它是无效边，可以删除。同时`ans++`
3. 在分别连接各自的边，若边存在，则是无效边，进行`ans++`，若不存在，则进行合并。并计算连通分量
4. 最后输出结果的时候，需要判断连通分量是否大于1，若大于1，证明无法遍历所有的点，输出`-1`，否则输出`ans`。

注意

- 这里顶点的编号是`1-n`,因此在初始化并查集的时候，parent的大小是`n+1`,不要忘记最后输出连通分量的时候记得`-1`，把`0`这个分量删除。

## 代码

```C++
class UnionFind {
    private:
    vector<int> parent;
    int countCon;
    public:
    UnionFind(int n) {
        for (int i = 0; i < n; i++) parent.push_back(i);
        countCon = n;
    }
    int find(int n) {
        if (n != parent[n]) parent[n] = find(parent[n]);
        return parent[n];
    }
    void merge(int u, int v) {
        int uRoot = find(u), vRoot = find(v);
        if (uRoot == vRoot) return;
        parent[uRoot] = vRoot;
        countCon--;
    }
    int getCount() {
        return countCon;
    }
    bool connection(int u, int v) {
        return find(u) == find(v);
    }
};
class Solution {
public:
    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {
        int ans = 0;
        UnionFind ufBob(n + 1), ufAlice(n + 1); // n的范围1-n
        for (auto& e: edges) {
            if (e[0] == 3) {
                if (!ufBob.connection(e[1], e[2])) {
                    ufBob.merge(e[1], e[2]);
                    ufAlice.merge(e[1], e[2]);
                } else {
                    ans++; // 已经连接，则证明这条边是没有用的
                }
            }
        }
        for (auto& e: edges) {
            if (e[0] == 2) {
                if (!ufBob.connection(e[1], e[2])) {
                    ufBob.merge(e[1], e[2]);
                } else {
                    ans++; // 已经连接，则证明这条边是没有用的
                }
            }
        }
        for (auto& e: edges) {
            if (e[0] == 1) {
                if (!ufAlice.connection(e[1], e[2])) {
                    ufAlice.merge(e[1], e[2]);
                } else {
                    ans++; // 已经连接，则证明这条边是没有用的
                }
            }
        }
        // 最后判断是否存在多个连通分量，若存在证明无法形成一个完全遍历的图
        return (ufBob.getCount() - 1) * (ufAlice.getCount() - 1) > 1 ? -1 : ans;
    }
};
```
