---
title: 堆
date: 2021-01-21 12:37:14
tags: [PAT, 堆, 算法]
categories: [PAT]
index_img: https://tva3.sinaimg.cn/large/0060lm7Tly1ftg6omusg9j31hc0u010h.jpg
---

# 堆

**堆是完全二叉树**

既然是完全二叉树，那么可以使用数组对完全二叉树进行描述

`i`表示当前结点，`2i`表示左子结点，`2i + 1`表示右子结点。

```C++
int MAX = 10010;
int heap[MAX], n; // 堆，元素个数
```

## 创建堆

建堆过程中，每次都要向下进行调整。若当前结点比子结点小，则和子结点进行交换，交换后继续和子结点进行比较，直至当前结点大于子结点或不存在子结点了。向下调整的代码如下：

```C++
void downAdjust(int low, int high) { // low: 当前结点。 high: 堆的最后一个结点
	int i = low, j = low * 2; // j表示左子结点
	while (j <= high) {
		// 找出左右子结点中值最大的结点下标。
		if (j + 1 < high && heap[j + 1] > heap[j]) { // 右结点存在 && 右结点大于左结点
			j = j + 1;
		}
		// 和根结点进行比较
		if (heap[i] < heap[j]) { // 小于子结点
			swap(heap[i], heap[j]); // 交换
			i = j; // 交换后，i移动到新的位置。继续和子结点比较
			j = i * 2; // j 移动到i的新子结点
		} else {
			break; // 若i结点大于子结点，则不需要移动。
		}
	}

}
```

接下来就是建立一个堆了。对于一个大小为$n$的堆，它的叶子结点数量是$|n/2|$。因为叶子结点不需要调整顺序，因此需要调整顺序的结点范围在$1 \sim n/2$。于是可以从$n/2$开始倒着遍历，为什么倒着遍历呢？因为每次调整都可以保证根结点都变成了最大值。

```C++
void createHeap() {
	for (int i = n / 2; i > 0; i--) {
		downAdjust(i, n);
	}
}
```

## 删除堆顶元素

删除堆顶元素，只需要将最后一个值覆盖堆顶元素，由于此时堆顶元素不是最大值，因此只需要对堆顶元素进行调整即可。

```C++
void deleteTop() {
	heap[1] = heap[n--]; // 元素n-1
	downAdjust(1, n);
}
```

## 在堆中添加元素

在堆中添加元素，需要把元素加到最后面，然后进行向上调整，把自己和父结点对比。若权值大于父结点，则与其交换，直到到达堆顶或者结点权值小于父结点停止。

下面是向上调整代码

```C++
void upAdjust(int low, int high) {
	int i = high, j = i / 2; // j为i的父结点
	while (j >= low) {
		if (heap[i] > heap[j]) {
			swap(heap[i], heap[j]);
			i = j;
			j = j / 2; // 找当上一个父结点
		} else {
			break; // 权值小于父结点，不替换
		}
	}
}

void insert(int x) {
	heap[++n] = x;
	upAdjust(1, n);
}
```

