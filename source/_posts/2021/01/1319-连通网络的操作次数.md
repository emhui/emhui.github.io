---
title: 1319. 连通网络的操作次数
date: 2021-01-23 08:40:34
tags: [leetcode, 算法, union-find]
categories: [LeetCode]
math: true
index_img: https://tva2.sinaimg.cn/large/0060lm7Tly1ftg6oh633dj31hc0u0qbh.jpg
---

# [1319. 连通网络的操作次数](https://leetcode-cn.com/problems/number-of-operations-to-make-network-connected/)

## 题目

![QhV5ev](https://gitee.com/yoyhm/oss/raw/master/uPic/QhV5ev.png)

## 思路

题目要求将所有电脑连接起来。即将所有连通分量合并成一个。根据定义，一个连通图若要连通，则至少需要$n-1$条边。每次合并两个连通分量就需要一条边，因此本题就转化成，计算给定图中存在多少连通分量。而所需要断开的线的数量为**连通分量数量-1**。

并查集可以解决连通分量问题。

## 代码

```C++
class UnionFind {
    private:
    vector<int> parent;
    int countConnections;
    public:
    UnionFind(int n) {
        countConnections = n;
        for (int i = 0; i < n; i++) parent.push_back(i);
    }
    int find(int x) {
        if (x != parent[x]) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }
    void quick_union(int v, int w) {
        int vRoot = find(v), wRoot = find(w);
        if (vRoot == wRoot) return;
        parent[find(v)] = find(w);
        countConnections--;
    }
    int getCountConnections() {
        return countConnections;
    }
};
class Solution {
public:
    int makeConnected(int n, vector<vector<int>>& connections) {
        if (connections.size() < n - 1) return -1;
        UnionFind uf(n);
        for (auto& node: connections) {
            int u = node[0], v = node[1];
            if (uf.find(u) != uf.find(v)) {
                uf.quick_union(u, v);
            }
        }
        return uf.getCountConnections() - 1;
    }
};
```
