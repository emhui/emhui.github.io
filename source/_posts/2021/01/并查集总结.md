---
title: 并查集总结
date: 2021-01-16 11:19:35
tags: [算法, 并查集, leetcode]
categories: [LeetCode]
---

# 并查集

> 参考自《算法4》

算法API

![guUjRV](https://gitee.com/yoyhm/oss/raw/master/uPic/guUjRV.png)

- union() 将两个不同分量中的结点归并
- find() 返回给定结点所在的连通分量标识
- connected() 判断两个结点是否存在同一连通分量中
- count() 返回连通分量个数，每次归并两个结点，连通分量数量-1

union-find的实现

```python
class UF(object):
    def __init__(self, N):
        self.count = N
        self.id = list(range(N)) # 初始化

    def count(self):
        return self.count

    def connected(self, p, q):
        return self.find(p) == self.find(q)

    def find(self, p):
        pass

    def union(self, p, q):
		pass

if __name__ == "__main__":
    data = [[1,2], [2,3], [3,4], [1,4], [1,5]]
    size = len(data)
    uf = UF(size + 1)
    for v, w in data:
        if not uf.connected(v, w):
            uf.union(v, w)
    pass
```

## 实现

三种不同方式

- `quick-find`
- `quick-union`
- `加权quick-union`

### quick-find

重点：实现`find()`的快速查找

属于同一连通分量的`id[i]`值都应该相同。

实现一

```python
def find(self, p):
	return id[p]

def union(slef, p, q):
	p_id, q_id = self.find(p), self.find(q)
	if p_id == q_id: return
	for i in range(len(id)):
		if id[i] == p_id:
			id[i] = q_id # 将所有属于连通分量p_id的结点挂到q_id上
	self.count -= 1 # 两个连通分量合并后，总连通分量数量-1
```

分析

- find() 速度很快，每次查找执行操作都是$O(1)$
- union() 每次都要遍历数组，执行操作$O(n)$。数据量过大时不适用。

由于`union()`操作比较耗时，下面介绍第二种方法

### quick-union

重点：提升`union()`的速度。

这里需要重新定义一下`id`变量的意义，之前方法一中，该变量的意义是**标识一个连通分量**。但是在这里，我们使用`id`表示的是**同一连通分量中，另一个结点的id**。为了混淆，重新写一下上面的代码，并且使用`parent`来替换`id`,`parent`表示**在同一连通分量中，当前结点的上一个结点是谁，有可能该结点是本身**

在实现`find()`的方法时候，通过`parent`找到它的上一个结点，再继续找上一个结点的上一个结点。最终找到根结点（根结点即是指向自己的结点）。所以当两个结点找到同一个根结点，则证明它们在同一连通分量中。

而在`union`中则需要维持这个关系，找到两个结点的根结点。然后将其中一个根结点指向另一个根结点。

```python
class QuickUnionUF(object):
    def __init__(self, N):
        self.count = N
        self.parent = list(range(N)) # 初始化

    def count(self):
        return self.count

    def connected(self, p, q):
        return self.find(p) == self.find(q)

    def find(self, p): # 寻找根结点
		while p ¡= self.parent[p]: p = self.parent[p]
		return p

    def union(self, p, q):
		p_root, q_root = self.find(p), self.find(q)
		if p_root == q_root: return
		self.parent[p_root] = q_root # 合并，将其中一个根结点挂在到另一个根结点
		self.count -= 1 # 连通分量数量 - 1
		pass
```

`quick-union`的实现形成了一个树形结构。

### 加权quick-union

重点：提升效率，减少树的高度。

```python
class WeightQuickUnionUF(object):
    def __init__(self, N):
        self.count = N
        self.parent = list(range(N)) # 初始化
		self.sz = [1] * N # 每个连通分量根结点的权重

    def count(self):
        return self.count

    def connected(self, p, q):
        return self.find(p) == self.find(q)

    def find(self, p): # 寻找根结点
		while p ¡= self.parent[p]: p = self.parent[p]
		return p

    def union(self, p, q):
		p_root, q_root = self.find(p), self.find(q)
		if p_root == q_root: return

		# 根据权重，将权重小的根结点挂在到权重大的根结点上
		if self.sz[p_root] > self.sz[q_root]:
			self.parent[q_root] = p_root
			self.sz[p_root] += self.sz[q_root]
		else:
			self.parent[p_root] = q_root
			self.sz[q_root] += self.sz[p_root]

		self.count -= 1 # 连通分量数量 - 1
		pass
```

## 绝招：路径压缩的加权quick-union

重点：检查每个结点的同时，直接将该结点链接到它的根结点。

因为`quick-union`已经无法在优化了，所以只能从`quick-find`入手，对`find`方法进行下手。将每次在查找路径中遇到的结点链接到根结点上。


```python
class CompressRouteWeightQuickUnionUF(object):
    def __init__(self, N):
        self.count = N
        self.parent = list(range(N)) # 初始化
		self.sz = [1] * N # 每个连通分量根结点的权重

    def count(self):
        return self.count

    def connected(self, p, q):
        return self.find(p) == self.find(q)

    def find(self, p): # 寻找根结点
		if (p != self.parent[p]):
			self.parent[p] = self.find(self.parent[p]) # 将每一个结点都链接到根结点上
		return self.parent[p] # 最后返回根结点的值

    def union(self, p, q):
		p_root, q_root = self.find(p), self.find(q)
		if p_root == q_root: return

		# 根据权重，将权重小的根结点挂在到权重大的根结点上
		if self.sz[p_root] > self.sz[q_root]:
			self.parent[q_root] = p_root
			self.sz[p_root] += self.sz[q_root]
		else:
			self.parent[p_root] = q_root
			self.sz[q_root] += self.sz[p_root]

		self.count -= 1 # 连通分量数量 - 1
		pass
```

最后通过此方法，得到的是一个扁平的树。
