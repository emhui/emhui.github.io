---
title: 105. 从前序与中序遍历序列构造二叉树
date: 2021-01-14 20:24:12
tags: [leetcode, 算法, 二叉树]
categories: [LeetCode]
index_img: https://tva2.sinaimg.cn/large/87c01ec7gy1frmr2kh3xkj21kw0w0e8e.jpg
---

# [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

## 题目

![8Fzs61](https://gitee.com/yoyhm/oss/raw/master/uPic/8Fzs61.png)

## 思路

参考[106. 从中序与后序遍历序列构造二叉树](https://emhui.fun/2021/01/14/106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/)

## 代码

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        return createTree(0, preorder.size() - 1, 0, inorder.size() - 1, preorder, inorder);
    }

    TreeNode* createTree(int preL, int preR, int inL, int inR, vector<int>& preorder, vector<int>& inorder) {
        if (preL > preR) return NULL;
        TreeNode *root = new TreeNode;
        root->val = preorder[preL];
        int mid = 0;
        for (mid = inL; mid <= inR; mid++) {
            if (inorder[mid] == preorder[preL]) break;
        }
        int leftNum = mid - inL;
        root->left = createTree(preL + 1, preL + leftNum, inL, mid - 1, preorder, inorder);
        root->right = createTree(preL + leftNum + 1, preR, mid + 1, inR, preorder, inorder);
        return root;
    }
};
```
