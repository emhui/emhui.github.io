---
title: 959. 由斜杠划分区域
date: 2021-01-25 10:02:59
tags: [leetcode, union-find, 算法]
categories: [LeetCode]
index_img: https://tva1.sinaimg.cn/large/0060lm7Tly1ftg6oqfp3aj318g0p0k4h.jpg
---

# [959. 由斜杠划分区域](https://leetcode-cn.com/problems/regions-cut-by-slashes/)

## 题目

![pCQINx](https://gitee.com/yoyhm/oss/raw/master/uPic/pCQINx.png)

## 思路

本题参考[🎦 由斜杠划分区域](https://leetcode-cn.com/problems/regions-cut-by-slashes/solution/you-xie-gang-hua-fen-qu-yu-by-leetcode-67xb/)

首先是将**单元格內划分为四个部分**，因为`/,\\, ' '`在单元格內只能将分成下面三种情况

![单元内连通](https://gitee.com/yoyhm/oss/raw/master/uPic/EAG0KQ.png)

然后分成三种情况，对单元格內的区域进行连通

- 空格：连通所有区域
- 斜杠：分别连通03，12区域
- 反斜杠：分别连通01，23区域

对单元格內区域连通完成后，考虑对**单元格之间**进行连通。如下图

![r2ZEwN](https://gitee.com/yoyhm/oss/raw/master/uPic/r2ZEwN.png)

经过发现

- 左右相邻的单元格中，左单元格1区域和右单元格3区域一定连通
- 上下相邻的单元格中，上单元格2区域和下单元格0区域一定连通

即单元格之间的连通关系如下图所示

![单元格之间连通](https://gitee.com/yoyhm/oss/raw/master/uPic/SeXPgr.png)

知道连通情况后，就可以使用**并查集**计算连通分量个数。

这里需要计算每个单元格的下标。由于是一个`N*N`的单元格，每个单元格分成4个区域，因此单元格总数应该是`4*N*N`.而每个单元格的起始下标应该是`4 * (i * N + j)`.

## 代码

```C++
class UnionFind {
    private:
    vector<int> parent;
    int countConnections;
    public:
    UnionFind(int n) {
        countConnections = n;
        for (int i = 0; i < n; i++) parent.push_back(i);
    }
    int find(int x) {
        if (x != parent[x]) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }
    void quick_union(int v, int w) {
        int vRoot = find(v), wRoot = find(w);
        if (vRoot == wRoot) return;
        parent[find(v)] = find(w);
        countConnections--;
    }
    int getCountConnections() {
        return countConnections;
    }
};
class Solution {
public:
    int regionsBySlashes(vector<string>& grid) {
        int size = grid.size();
        UnionFind uf(size * size * 4);
        for (int i = 0; i < size; i++) {
            for (int j = 0; j < size; j++) {
                // 判断每个单元格內连通情况
                int idx = 4 * (i * size + j); // 当前位于第几个单元格
                char c = grid[i][j];
                if (c == '/') { // 连通0-3,1-2
                    uf.quick_union(idx, idx + 3);
                    uf.quick_union(idx + 1, idx + 2);
                } else if (c == '\\') { // union 0-1,2-3
                    uf.quick_union(idx, idx + 1);
                    uf.quick_union(idx + 2, idx + 3);
                } else { // union all
                    uf.quick_union(idx, idx + 1);
                    uf.quick_union(idx + 1, idx + 2);
                    uf.quick_union(idx + 2, idx + 3);
                }

                // 连通相邻单元格，单元格是一定可以实现连通的，画图出来就可以知道了。
                if (j < size - 1) { // union left:1-right:3
                    uf.quick_union(idx + 1, 4 * (i * size + j + 1) + 3);
                }
                if (i < size - 1) { // union bottom:2-top:0
                    uf.quick_union(idx + 2, 4 * ((i + 1) * size + j));
                }
            }
        }
        return uf.getCountConnections();
    }
};
```
