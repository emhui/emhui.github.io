---
title: 账户合并
date: 2021-01-18 10:40:28
tags: [leetcode, 算法, union-find]
categories: [LeetCode]
index_img: https://tva1.sinaimg.cn/large/0060lm7Tly1ftg6x22sgcj31hc0u0qh8.jpg
---

# [账户合并](https://leetcode-cn.com/problems/accounts-merge/)

## 题目

![Ssq91V](https://gitee.com/yoyhm/oss/raw/master/uPic/Ssq91V.png)

## 思路

本题需要找到邮箱之间的连通性，若邮箱之间连通，那么就确定了该邮箱所属的人。可以采用并查集来实现。设置两个哈希表。建立**email->idx**，**email->name**。

映射方法如下

```C++
map<string, int> email2idx;
map<string,string> email2name;
for (int i = 0; i < accounts.size(); i++) {
	string name = accounts[i][0];
	for (int j = 1; j < accounts[i].size(); j++) {
		if (email2idx.find(accounts[i][j]) == email2idx.end()) {
			email2idx[accounts[i][j]] = email2idx.size();
			email2name[accounts[i][j]] = name;
		}
	}
}
```

接着使用并查集，将属于同一连通分量的email连通。

```C++
UnionFind uf(email2idx.size()); // 初始化
for (int i = 0; i < accounts.size(); i++) {
	string first = accounts[i][1]; // 每一组account对象中，各个邮箱都是连通的，因此只要选择一个来和其他连通就可以。
	for (int j = 2; j < accounts[i].size(); j++) {
		uf.quick_union(email2idx[first], email2idx[accounts[i][j]]); // 合并同一个集合
	}
}
```

合并好连通分量后，开始将同一个连通分量下的email集合到一起

```C+=
// 将同一连通分量下的集合添加到一起
map<int, vector<string>> idx2emails;
for (map<string, int>::iterator it = email2idx.begin(); it != email2idx.end(); it++) {
	idx2emails[uf.find(it->second)].push_back(it->first);
}
```

最后按照题目返回对应格式数据即可。

## 代码

```C++
class UnionFind {
    private:
    vector<int> parent;
    public:
    UnionFind(int n) {
        for (int i = 0; i < n; i++) parent.push_back(i);
    }
    int find(int x) {
        if (x != parent[x]) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }
    void quick_union(int v, int w) {
        parent[find(v)] = find(w);
    }
};

class Solution {
public:
    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {
        map<string, int> email2idx;
        map<string,string> email2name;
        for (int i = 0; i < accounts.size(); i++) {
            string name = accounts[i][0];
            for (int j = 1; j < accounts[i].size(); j++) {
                if (email2idx.find(accounts[i][j]) == email2idx.end()) {
                    email2idx[accounts[i][j]] = email2idx.size();
                    email2name[accounts[i][j]] = name;
                }
            }
        }
        UnionFind uf(email2idx.size()); // 初始化
        for (int i = 0; i < accounts.size(); i++) {
            string first = accounts[i][1];
            for (int j = 2; j < accounts[i].size(); j++) {
                uf.quick_union(email2idx[first], email2idx[accounts[i][j]]); // 合并同一个集合
            }
        }
        // 将同一连通分量下的集合添加到一起
        map<int, vector<string>> idx2emails;
        for (map<string, int>::iterator it = email2idx.begin(); it != email2idx.end(); it++) {
            // cout << it->first << " " << uf.find(it->second) <<endl;
            idx2emails[uf.find(it->second)].push_back(it->first);
        }
        vector<vector<string>> ans;

        for (map<int, vector<string>>::iterator it = idx2emails.begin(); it != idx2emails.end(); it++) {
            vector<string> temp;
            temp.push_back(email2name[it->second[0]]);
            sort(it->second.begin(), it->second.end());
            temp.insert(temp.end(), it->second.begin(), it->second.end());
            ans.push_back(temp);
        }
        return ans;
};
};
```

## 其他

- `vector<type>`合并数据

如下例所示，使用`insert(oriin.end(), in.begin(), in.end())`

```C++
vector<int> vec1 = {...};
vector<int> vec2 = {...};// vec1和vec2都存有内容

vector<int> vec3;//vec3是空的
vec3.insert(vec3.end(),vec1.begin(),vec1.end())//将vec1压入
vec3.insert(vec3.end(),vec2.begin(),vec2.end())//继续将vec2压入
```

- `vector`如何使用`sort`

基本使用：`sort(v.begin(), v.end())`
