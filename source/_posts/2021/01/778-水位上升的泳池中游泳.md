---
title: 778. 水位上升的泳池中游泳
date: 2021-01-30 09:35:23
tags: [leetcode, 算法, Dijkstra]
categories: [LeetCode]
math: true
index_img: https://tva4.sinaimg.cn/large/87c01ec7gy1frmrxi7a77j21hc0u0aj7.jpg
---

# [778. 水位上升的泳池中游泳](https://leetcode-cn.com/problems/swim-in-rising-water/)

![MYmJYZ](https://gitee.com/yoyhm/oss/raw/master/uPic/MYmJYZ.png)

## 思路

- Dijsktra
- 并查集
- 二分搜索

### Dijsktra

以网格中的值作为距离。

Dijsktra的步骤

1. 初始化参数
2. 依次找到$n*n$个结点的最短距离
	1. 找到最小的距离点
	2. 将该点的visited标记为已访问
	3. 判断是否到达了终点，若到了终点就返回该距离
	4. **更新最短距离**

其中上面有两点需要注意

- `dis[0,0] = grid[0][0]`，dis表示的达到降水的最大高度
- 更新最短距离需要选择 `dis[newX][newY] = max(dis[u][v], grid[newX][newY])`



## 代码

```C++
class Solution {
public:
int move[4][2] = {{1,0}, {-1,0}, {0,1}, {0,-1}};
    int swimInWater(vector<vector<int>>& grid) {
        // 找到一条权值点最小的路径，其中权值点最大的是答案
        // 计算到达每个点的最小距离，结点值作为距离
        int m = grid.size(), n = grid.size();
        int INF = 98764321;
        vector<vector<bool>> visited(n, vector<bool>(n, false));
        vector<vector<int>> dis(n, vector<int>(n, INF));
        dis[0][0] = grid[0][0];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                // 找到范围內最小的点
                int u = -1, v = -1, minDis = INF;
                for (int x = 0; x < m; x++) {
                    for (int y = 0; y < n; y++) {
                        if (!visited[x][y] && dis[x][y] < minDis) {
                            u = x;
                            v = y;
                            minDis = dis[x][y];
                        }
                    }
                }
                cout << u << " " << v << endl;
                if (u == -1 && v == -1) continue;
                visited[u][v] = true; // 访问最小值
                if (u == m - 1 && v == n - 1) {
                    return dis[u][v];
                }
                // 开始优化四个角落
                for (int k = 0; k < 4; k++) {
                    int newX = u + move[k][0];
                    int newY = v + move[k][1];
                    if (newX < 0 || newX >= m || newY < 0 || newY >= n) continue;
                    // 更新距离,这一步如何实现
                    if (!visited[newX][newY] && max(dis[u][v], grid[newX][newY]) < dis[newX][newY]) {
                        dis[newX][newY] = max(dis[u][v], grid[newX][newY]);
                    }
                }
            }
        }
        return -1;
    }
};
```

使用 `priority_queue`实现`Dijkstra`

```C++
// 优先队列中的数据结构。其中 (i,j) 代表坐标，val 代表水位。
struct Entry {
    int i;
    int j;
    int val;
    bool operator<(const Entry& other) const {
        return this->val > other.val;
    }
    Entry(int ii, int jj, int val): i(ii), j(jj), val(val) {}
};

class Solution {
public:
    int swimInWater(vector<vector<int>>& grid) {
        int n = grid.size();
        priority_queue<Entry, vector<Entry>, function<bool(const Entry& x, const Entry& other)>> pq(&Entry::operator<);
        vector<vector<int>> visited(n, vector<int>(n, 0));

        pq.push(Entry(0, 0, grid[0][0]));
        int ret = 0;
        vector<pair<int, int>> directions{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        while (!pq.empty()) {
            Entry x = pq.top();
            pq.pop();
            if (visited[x.i][x.j] == 1) {
                continue;
            }

            visited[x.i][x.j] = 1;
            ret = max(ret, grid[x.i][x.j]);
            if (x.i == n - 1 && x.j == n - 1) {
                break;
            }

            for (const auto [di, dj]: directions) {
                int ni = x.i + di, nj = x.j + dj;
                if (ni >= 0 && ni < n && nj >= 0 && nj < n) {
                    if (visited[ni][nj] == 0) {
                        pq.push(Entry(ni, nj, grid[ni][nj]));
                    }
                }
            }
        }
        return ret;
    }
};
```
