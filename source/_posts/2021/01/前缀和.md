---
title: 前缀和
date: 2021-01-28 09:26:46
tags: [leetcode, 算法, 前缀和, 数组]
categories: [LeetCode]
math: true
index_img: https://tva2.sinaimg.cn/large/87c01ec7gy1frmrs543ivj21hc0u0ths.jpg
---

# 前缀和

## 前缀和概念

**作用**

前缀和一般用于求$sum[i, j]$ 范围i,j之间的和。

**原理**

使用一个数组记录前n个的结果。比如

$P[i] = n[0] + n[1] + ... + n[i-1]$

而$[i,j]$范围內的和等于

$$
sum[i,j] = P[j + 1] - P[i] \\ =  n[j] + n[j - 1] + n[i] + n]i - 1] + ... n[0] \\ - n[i - 1] - n[i - 2] ... n[0] \\= n[j] + n[j - 1] + .. n[i]
$$

根据上面可以推断出前缀和算法模板为

```C++
int n; // 元素个数
vector<int> nums;
vector<int> pre(n + 1); // n 表示前 n-1个和，所以 n + 1 表示前n个数之和

pre[0] = 0; // 第一个数默认为0. [i,0] 之和 为 pre[i + 1]. 所以 i = 0时， sum[0] = pre[1]

for (int i = 0; i < n; i++) {
	pre[i + 1] = pre[i] + nums[i];
}

// [i,j]之间的和
sum[i,j] = pre[j + 1] - pre[i];
```

---

## 相关题目

[724. 寻找数组的中心索引](https://leetcode-cn.com/problems/find-pivot-index/)

题目

> 给定一个整数类型的数组 nums，请编写一个能够返回数组 “中心索引” 的方法。
>
> 我们是这样定义数组 中心索引 的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。
>
> 如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。

示例

> 输入：
> nums = [1, 7, 3, 6, 5, 6]
>
> 输出：3
>
> 解释：
> 索引 3 (nums[3] = 6) 的左侧数之和 (1 + 7 + 3 = 11)，与右侧数之和 (5 + 6 = 11) 相等。
同时, 3 也是第一个符合要求的中心索引。

**分析**

计算该数组的前缀和，假设当前元素索引为$i$,

则左侧和范围是

$0 \sim i - 1$,

左侧和为 $sum[0, i - 1] = pre[i]$,

右侧和范围是

$i + 1 \sim n - 1$,

则右侧和为

$sum[i + 1, n - 1] = pre[n] - pre[i + 1] = pre[n] - pre[i] - nums[i]$.

所以本题需要找到一个`i`，满足`pre[i] == pre[n] - pre[i] - nums[i]`

代码如下

```C++
class Solution {
public:
    int pivotIndex(vector<int>& nums) {
        int n = nums.size();
        if (n == 0) return -1;
        vector<int> pre(n + 1, 0);
        for (int i = 1; i <= n; i++) {
            pre[i] = pre[i - 1] + nums[i - 1];
        }
        for (int i = 0; i < n; i++) {
            if (pre[i] == pre[n] - pre[i] - nums[i]) {
                return i;
            }
        }
        return -1;
    }
};
```

**优化**

本题中，中心索引需要满足

$pre[i] == pre[n] - pre[i] - nums[i]$.

可以令$sum = pre[i], total = pre[n]$，那么上面方程则变成

$$
sum = total - sum - nums[i] \\
2 * sum + nums[i] = total
$$

因此代码优化成一遍遍历即可找到结果

```C++
class Solution {
public:
    int pivotIndex(vector<int>& nums) {
        int n = nums.size();
        if (n == 0) return -1;
        int total = accumulate(nums.begin(), nums.end(), 0); // 第三个是累加初始值，初始值为0
        int sum = 0;
        for (int i = 0; i < n; i++) {
            if (2 * sum + nums[i] == total) {
                return i;
            }
            sum += nums[i];
        }
        return -1;
    }
};
```
