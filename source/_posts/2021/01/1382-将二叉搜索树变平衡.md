---
title: 1382. 将二叉搜索树变平衡
date: 2021-01-20 17:44:48
tags: [leetcode, 算法, 平衡二叉树, 二叉搜索树, 完全二叉树]
categories: [LeetCode]
math: true
index_img: https://tva1.sinaimg.cn/large/87c01ec7gy1frmrqzc5woj21hc0u0k07.jpg
---

# [1382. 将二叉搜索树变平衡](https://leetcode-cn.com/problems/balance-a-binary-search-tree/)

## 题目

![9bWA3J](https://gitee.com/yoyhm/oss/raw/master/uPic/9bWA3J.png)

## 思路

- 使用中序遍历将结点转化为递增顺序的数组。
- 对递增顺序的数组，采用递归的方式建立一个完全二叉树。（完全二叉树一定是平衡二叉树）
- 因为完全二叉树是一个静态的数组，因此还需要根据下面规则，对完全二叉树內的结点建立联系。
	- 索引$X$的左子树索引是$2X$，右子树索引是$2X + 1$

```python
for i in range(1, self.n + 1):
	if i * 2 <= self.n: self.cbt[i].left = self.cbt[i * 2]
	else: self.cbt[i].left = None
	if i * 2 + 1 <= self.n: self.cbt[i].right = self.cbt[i * 2 + 1]
	else: self.cbt[i].right = None
```

⚠️: 完全二叉树根结点的索引是$1$开始的。因此完全二叉树的数组大小是$结点数量+1$

## 代码

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def inorder(self, root):
        if root is None:
            return
        self.inorder(root.left)
        self.ans.append(root)
        self.inorder(root.right)
    def create_cbt(self, idx):
        if idx > self.n: return
        self.create_cbt(idx * 2)
        self.cbt[idx].val = self.ans[self.num].val
        self.num += 1
        self.create_cbt(idx * 2 + 1)
    def balanceBST(self, root):
        """
        :type root: TreeNode
        :rtype: TreeNode
        """

        # 1. 将搜索二叉树中序遍历，获取其递增序列
        self.ans = []
        self.inorder(root)
        # 2. 创建完全二叉树数组
        self.n = len(self.ans) # 结点数量
        self.num = 0 # 当前递增序列遍历的结点
        self.cbt = [TreeNode(0) for _ in range(self.n + 1)] # 静态的完全二叉树数组
        self.create_cbt(1) # 完全二叉树以1为根结点
        # 3. 根据左子树索引:2x, 右子树索引:2x+1, 重建二叉树索引
        for i in range(1, self.n + 1):
            if i * 2 <= self.n: self.cbt[i].left = self.cbt[i * 2]
            else: self.cbt[i].left = None
            if i * 2 + 1 <= self.n: self.cbt[i].right = self.cbt[i * 2 + 1]
            else: self.cbt[i].right = None
        return self.cbt[1]

```

C++实现

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> inorder;
    TreeNode* balanceBST(TreeNode* root) {
        midtravel(root);
        return create(0, inorder.size() - 1);
    }

    TreeNode* create(int left, int right) {
        if (left > right) return NULL;
        int mid = left + ((right - left) >> 1);
        TreeNode* root = new TreeNode(inorder[mid]);
        root->left = create(left, mid - 1);
        root->right = create(mid + 1,right);
        return root;
    }

    void midtravel(TreeNode* root) {
        if (!root) return;
        midtravel(root->left);
        inorder.push_back(root->val);
        midtravel(root->right);
    }
};
```
