---
title: 839. 相似字符串组
date: 2021-01-31 08:34:42
tags: [leetcode, union-find]
categories: [LeetCode]
---

# [839. 相似字符串组](https://leetcode-cn.com/problems/similar-string-groups/)

## 题目

![fmjjEv](https://gitee.com/yoyhm/oss/raw/master/uPic/fmjjEv.png)

## 分析

将每个字符串作为一个点，将相似的字符串连通到一起，本题就变成了求连通分量个数。

如何判断是否相似，若两个字符串中只存在两个不同的字符，那么就等于相似。

```C++
bool isSimilar(string& a, string& b, int len) {
	int num = 0;
	for (int i = 0; i < len; i++) {
		if (a[i] != b[i]) {
			num++;
			if (num > 2) return false;
		}
	}
	return true;
}
```


## 代码

```C++
class Solution {
public:
    vector<int> parent;
    int find(int x) {
        return parent[x] ==  x ? x : parent[x] = find(parent[x]);
    }

    bool isSimilar(string& a, string& b, int len) {
        int num = 0;
        for (int i = 0; i < len; i++) {
            if (a[i] != b[i]) {
                num++;
                if (num > 2) return false;
            }
        }
        return true;
    }

    int numSimilarGroups(vector<string>& strs) {
        int n = strs.size();
        int m = strs[0].size();
        int setCount = n;
        for (int i = 0; i < n; i++) parent.push_back(i);
        // 开始连通每个字符串
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                int iRoot = find(i), jRoot = find(j);
                if (iRoot == jRoot) continue;
                if (isSimilar(strs[i], strs[j], m)) {
                    parent[iRoot] = jRoot;
                    setCount--;
                }
            }
        }
        return setCount;
    }
};
```

## 参考

- [相似字符串组](https://leetcode-cn.com/problems/similar-string-groups/solution/xiang-si-zi-fu-chuan-zu-by-leetcode-solu-8jt9/)
