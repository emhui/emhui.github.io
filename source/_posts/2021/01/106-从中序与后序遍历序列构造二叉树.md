---
title: 106. 从中序与后序遍历序列构造二叉树
date: 2021-01-14 17:53:07
tags: [leetcode, 算法, 二叉树, 前序遍历, 后序遍历]
categories: [LeetCode]
index_img: https://tva1.sinaimg.cn/large/87c01ec7gy1frmrxi7a77j21hc0u0aj7.jpg
---

# [106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

## 题目

{% note warning %}
难度：中等
{% endnote %}

![qPKWr8](https://gitee.com/yoyhm/oss/raw/master/uPic/qPKWr8.png)

## 思路

分析由用后序遍历序列和中序遍历序列来重建二叉树。

假设递归过程中某步的后序序列区间为[postL, postR],中序序列区间为[inL, inR],那么由后序序列性质可知,后序序列的最后一个元素post[postR]即为根结点。接着需要在中序序列中寻找一个位置k,使得in(k]=postpostR],这样就找到了中序序列中的根结点。易知左子树结点个数为numLeft=k-inL,于是左子树的后序序列区间为[postL, postL + numLeft1],左子树的中序序列区间为[inL, k-1];右子树的后序序列区间为[postL + numLefj),右子树的中序序列区间为k + 1, inR]。

## 代码

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        return createTree(0, inorder.size() - 1, 0, postorder.size() - 1, inorder, postorder);
    }
    TreeNode* createTree(int inL, int inR, int postL, int postR, vector<int>& inorder, vector<int>& postorder) {
        if (postL > postR) return NULL;
        TreeNode* node = new TreeNode;
        node->val = postorder[postR];
        int mid = 0;
        for (mid = inL; mid <= inR; mid++) { // 找到中序遍历的根结点位置
            if (inorder[mid] == node->val) break;
        }
        int leftNum = mid - inL; // 左子树的数量
        node->left = createTree(inL, mid - 1, postL, postL + leftNum - 1, inorder, postorder);
        node->right = createTree(mid + 1, inR, postL + leftNum, postR - 1, inorder, postorder);
        return node;
    }
};
```
