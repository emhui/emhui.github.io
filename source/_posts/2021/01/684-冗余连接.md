---
title: 684. 冗余连接
date: 2021-01-13 11:56:09
tags: [leetcode, union-find, 图]
categories: [LeetCode]
math: true
index_img: https://tva2.sinaimg.cn/large/0060lm7Tly1ftg6oquldpj318g0p04ak.jpg
---
# [684. 冗余连接](https://leetcode-cn.com/problems/redundant-connection/)

## 题目

![NfR2TK](https://gitee.com/yoyhm/oss/raw/master/uPic/NfR2TK.png)

## 思路

本题考察的是**并查集**,假设它是一个无环图，那么边和顶点的数量是$e + 1 = v$。但是因为存在一条冗余边，因此边和顶点关系为$e=v$。

同时，在通过并查集连接两个顶点的时候，若该两个顶点已经出现在一个连通分量中，则证明该此图已经连通过，出现了环，若是没有，则连通该两点。

{% note warning %}
并查集知识点参考

- 并查集详解[^1]
- 《算法4》[^2]
{% endnote %}

## 代码

C++


```C++
class Solution {
public:
    int find(vector<int>& parent, int q) {
        while (parent[q] != q) {q = parent[q]; } // 找到根结点
        return q;
    }

    // 加权quick-union方法，参考《算法4》
    void quick_union(vector<int>& parent, vector<int>& weight, int q, int p) {
        int qRoot = find(parent, q), pRoot = find(parent, p);
        if (qRoot == pRoot) return;
        if (weight[qRoot] < weight[pRoot]) {
            parent[qRoot] = pRoot;
            weight[pRoot] += weight[qRoot];
        } else {
            parent[pRoot] = qRoot;
            weight[qRoot] += weight[pRoot];
        }

    }
    vector<int> findRedundantConnection(vector<vector<int>>& edges) {
        int size = edges.size() + 1;
        vector<int> parent(size);
        vector<int> weight(size, 1);
        for (int i = 0; i < size; i++) { // 初始化
            parent[i] = i;
        }
        for (auto& edge: edges) {
            int p = edge[0], q = edge[1];
            if (find(parent, q) != find(parent, p)) {
                quick_union(parent, weight, q, p);
            } else {
                return edge;
            }
        }
        return vector<int>{};
    }
};
```

这里参考《算法4》[^2],使用的是加权quick-union方法。经过测试时间上是有提升，但是有时候也不稳定。时间是非加权结果一样。如图测试结果

![rHY9BU](https://gitee.com/yoyhm/oss/raw/master/uPic/rHY9BU.png)

Python

```python
class Solution:
    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:
        nodesCount = len(edges)
        parent = list(range(nodesCount + 1)) # 初始化值，即 parent[i] = i

        def find(index: int) -> int:
            while index != parent[index]: index = parent[index]
            return index

        def union(index1: int, index2: int):
            parent[find(index1)] = find(index2)

        for node1, node2 in edges:
            if find(node1) != find(node2): # 如果不再一个集合里面，则没有找到重复
                union(node1, node2)
            else:
                return [node1, node2]

        return []
```

## 其他

以下是根据《算法4》[^2]写出的Python版本的Unin-find模板。

```python
class UF(object):
    def __init__(self, N):
        self.count = N
        self.id = list(range(N))

    def count(self):
        return self.count

    def connected(self, p, q):
        return self.find(p) == self.find(q)

    def find(self, p):
        while (p != self.id[p]): p = self.id[p]
        return p

    def union(self, p, q):
        p_root, q_root = self.find(p), self.find(q)
        if p_root == q_root: return
        self.id[p] = q_root
        self.count -= 1
```

[^1]: [并查集详解 ——图文解说,简单易懂](https://blog.csdn.net/liujian20150808/article/details/50848646)
[^2]: [算法4](https://m.douban.com/book/subject/19952400/)
