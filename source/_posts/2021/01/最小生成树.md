---
title: 最小生成树
date: 2021-01-19 11:41:06
tags: [leetcode, 算法, 最小生成树, Kruskal]
categories: [LeetCode]
index_img: https://tva2.sinaimg.cn/large/87c01ec7gy1frmmlso9rgj21hc0u0kjn.jpg
---

# 最小生成树算法

满足最小生成树

- 所有顶点都连接
- 没有环

生成树可能存在多个，而权值只和最小的就是最小生成树

实现方法

- [x] Kruskal
- [ ] Prim

## Kruskal

- 所有的边按照权值排序
- 解决当前最小的权值边和已添加的线是否形成回路（重点）

如图是Kruskal算法的过程

![mFdoQR](https://gitee.com/yoyhm/oss/raw/master/uPic/mFdoQR.png)

每次从权值边选出最小边，再判断该边的两点是否已经存在于最小生成树中（使用并查集来判断），若不存在就加入最小生成树中。若存在则寻找下一条最小权值的边。

## 代码

如何将权值和两个顶点联系起来呢？这是使用`pair<int, pair<int, int>>`来实现，其中权值作为第一个元素，第二个元素为该权值对应的两个顶点。使用`sort`对权值边从小到达大进行排序。

```C++
const int MAX = 100;
UnionFind uf;
int V; // 顶点个数
vector<pair<int, int>> adj[MAX]; // 邻接表，存储图
int kruskal(<vector<pair(int,int)>>& selected) {
	int sum = 0;
	selected.clear(); // 加入到最小生成树的顶点
	vector<pair<int, pair<int, int>>> edges; // 存储权值边以及两端顶点
	for (int u = 0; u < V; u++) {
		for (int i = 0; i < adj[u].size(); i++) {
			int v = adj[u][i].first;
			int cost = adj[u][i].second;
			edges.push_back(make_pair(cost, make_pair(u, v))); // 把 权值， 两个点 存储到 edges中
		}
	}
	sort(edges.begin(), sort.end()); // 按照权值进行排序
	UnionFind uf(V); // 建立并查集
	for (int i = 0; i < edges.size(); i++) { // 开始依次选择最小权值生成最小生成树
		int cost = edges[i].first;
		int u = edges[i].second.first, v = edges[i].second.second;
		if (uf.find(u) == uf.find(v)) continue;
		uf.quick_union(u, v);
		selected.push_back(make_pair(u, v));
		sum += cost;
	}
	return sum; // 最小生成树权值
}
```

相关题目

- [1584.连接所有点的最小费用](https://emhui.fun/2021/01/19/1584-%E8%BF%9E%E6%8E%A5%E6%89%80%E6%9C%89%E7%82%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8/)
