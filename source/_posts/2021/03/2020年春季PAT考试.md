---
title: 2020年春季PAT考试
date: 2021-03-06 09:39:11
tags: [PAT, 素数, 图, 优先队列]
categories: [PAT]
index_img: https://tva1.sinaimg.cn/large/0060lm7Tly1ftg6wuhgywj31hc0u0wjr.jpg
---

# 2020年春季PAT考试

## 7-1 Prime Day (20分)

The above picture is from Sina Weibo, showing May 23rd, 2019 as a very cool "Prime Day". That is, not only that the corresponding number of the date `20190523` is a prime, but all its sub-strings ended at the last digit `3` are prime numbers.

Now your job is to tell if a given date is a Prime Day.

### Input Specification:

Each input file contains one test case. For each case, a date between January 1st, 0001 and December 31st, 9999 is given, in the format `yyyymmdd`.

### Output Specification:

For each given date, output in the decreasing order of the length of the substrings, each occupies a line. In each line, print the string first, followed by a space, then `Yes` if it is a prime number, or `No` if not. If this date is a Prime Day, print in the last line `All Prime!`.

### Sample Input 1:

```
20190523
```

### Sample Output 1:

```
20190523 Yes
0190523 Yes
190523 Yes
90523 Yes
0523 Yes
523 Yes
23 Yes
3 Yes
All Prime!
```

### Sample Input 2:

```
20191231
```

### Sample Output 2:

```
20191231 Yes
0191231 Yes
191231 Yes
91231 No
1231 Yes
231 No
31 Yes
1 No
```

### 分析

本题考查 **判断素数**和**字符串分割**

> 求**素数**不要忘记是**<=**

### 代码如下

```c++
#include <iostream>
#include <string>
#include <cmath>
#include <algorithm>
using namespace std;

// 本题考查 素数判断、字符串提取

bool isPrime(int x) {
    if (x < 2) return false;
    // 不要忘记等于号
    for (int i = 2; i <= (int)sqrt(1.0 * x); i++) {
        if (x % i == 0) return false;
    }
    return true;
}

int main() {
    string s, temp;
    cin >> s;
    bool flag = true;
    for (int i = 0; i < s.size(); i++) {
        temp = s.substr(i);
        if (isPrime(stoi(temp))) {
            printf("%s Yes\n", temp.c_str());
        } else {
            flag = false;
            printf("%s No\n", temp.c_str());
        }
    }
    if (flag)
    printf("All Prime!");
    return 0;
}
```

 ## 7-2 The Judger (25分)

A game of numbers has the following rules: at the beginning, two distinct positive integers are given by the judge. Then each player in turn must give a number to the judge. The number must be the difference of two numbers that are previously given, and must not be duplicated to any of the existed numbers. The game will run for several rounds. The one who gives a duplicate number or even a wrong number will be kicked out.

Your job is to write a judger program to judge the players' numbers and to determine the final winners.

### Input Specification:

Each input file contains one test case. For each case, the first line gives two distinct positive integers to begin with. Both numbers are in [1,10^5][1,105].

In the second line, two numbers are given: N (2≤N≤10), the number of players, and M (2≤M≤10^3)*M*(2≤*M*≤103), the number of rounds.

Then N lines follow, each contains M positive integers. The i-th line corresponds to the i-th player (i=1,⋯,N). The game is to start from the 1st player giving his/her 1st number, followed by everybody else giving their 1st numbers in the 1st round; then everyone give their 2nd numbers in the 2nd round, and so on so forth.

### Output Specification:

If the `i`-th player is kicked out in the `k`-th round, print in a line `Round #k: i is out.`. The rest of the numbers given by the one who is out of the game will be ignored. If more than one player is out in the same round, print them in increasing order of their indices. When the game is over, print in the last line `Winner(s): W1 W2 ... Wn`, where `W1 ... Wn` are the indices of the winners in increasing order. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the beginning or the end of the line. If there is no winner, print `No winner.` instead.

### Sample Input 1:

```
101 42
4 5
59 34 67 9 7
17 9 8 50 7
25 92 43 26 37
76 51 1 41 40
```

### Sample Output 1:

```
Round #4: 1 is out.
Round #5: 3 is out.
Winner(s): 2 4
```

### Sample Input 2:

```
42 101
4 5
59 34 67 9 7
17 9 18 50 49
25 92 58 1 39
102 32 2 6 41
```

### Sample Output 2:

```
Round #1: 4 is out.
Round #3: 2 is out.
Round #4: 1 is out.
Round #5: 3 is out.
No winner.
```

### 分析

本题考查 **set**的应用。题目比较难理解，大致意思是：每个人给出的数字必须是之前出现过的任意两数字的**差值（difference）**且非之前已经出现过的数字。因此设置两个`unordered_set<int> diff, nums`分别存储已经出现过的任意两数字差值和已经出现过的数字。每轮每个人给出新的数字后，都需要更新`diff,nums`。

### 代码

```C++
#include <iostream>
#include <string>
#include <cmath>
#include <algorithm>
#include <vector>
#include <unordered_set>
using namespace std;

// 本题考查 set

int main() {
    int n, m, n1, n2;
    unordered_set<int> diff, nums; // 存储差值和给出的数字
    cin >> n1 >> n2;
    nums.insert(n1);
    nums.insert(n2);
    diff.insert(abs(n1 - n2));
    cin >> n >> m;
    vector<vector<int> > arr(n, vector<int>(m));
    vector<bool> isWin(n, true); // 一开始谁都是赢家
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            cin >> arr[i][j];
        }
    }

    int loser = 0;
    for (int j = 0; j < m; j++) {
        for (int i = 0; i < n; i++) {
            if (!isWin[i]) continue;
            int val = arr[i][j];
            // 不是差值或者存在重复就淘汰
            if (diff.count(val) == 0 || nums.count(val) == 1) {
                isWin[i] = false;
                printf("Round #%d: %d is out.\n", j + 1, i + 1);
                loser++;
                continue;
            }
            // 最后剩下的就是满足条件的
            // nums.insert(val);
            // 更新差值
/*             for (auto it: nums) {
                diff.insert(abs(val - it));
            } */
            for (unordered_set<int>::iterator it = nums.begin(); it != nums.end(); ++it) {
                diff.insert(abs(*it - val));
            }
            nums.insert(val);
        }
    }
    if (loser == n) {
        printf("No winner.\n");
    } else {
        printf("Winners(s):");
        for (int i = 0; i < n; i++) {
            if (isWin[i]) {
                printf(" %d", i + 1);
            }
        }
        printf("\n");
    }
    return 0;
}
```

## 7-3 Safari Park (25分)

A safari park（野生动物园）has K species of animals, and is divided into N regions. The managers hope to spread the animals to all the regions, but not the same animals in the two neighboring regions. Of course, they also realize that this is an NP complete problem, you are not expected to solve it. Instead, they have designed several distribution plans. Your job is to write a program to help them tell if a plan is feasible.

### Input Specification:

Each input file contains one test case. For each case, the first line gives 3 integers: N (0<N≤500), the number of regions; R (≥0), the number of neighboring relations, and K (0<K≤N), the number of species of animals. The regions and the species are both indexed from 1 to N.

Then R lines follow, each gives the indices of a pair of neighboring regions, separated by a space.

Finally there is a positive M (≤20) followed by M lines of distribution plans. Each plan gives N indices of species in a line (the i-th index is the animal in the i-th rigion), separated by spaces. It is guaranteed that any pair of neighboring regions must be different, and there is no duplicated neighboring relations.

### Output Specification:

For each plan, print in a line `Yes` if no animals in the two neighboring regions are the same, or `No` otherwise. However, if the number of species given in a plan is not K, you must print `Error: Too many species.` or `Error: Too few species.` according to the case.

### Sample Input:

```
6 8 3
2 1
1 3
4 6
2 5
2 4
5 4
5 6
3 6
5
1 2 3 3 1 2
1 2 3 4 5 6
4 5 6 6 4 5
2 3 4 2 3 4
2 2 2 2 2 2
```

### Sample Output:

```
Yes
Error: Too many species.
Yes
No
Error: Too few species.
```

### 分析

本题考查 **邻接表**。

题目也不难，就是建立一个邻接表，然后根据根据给出的序列安排位置。若相邻的边坐着同一种类的动物，就输出`false`.

### 代码

```C++
#include <iostream>
#include <string>
#include <cmath>
#include <algorithm>
#include <vector>
#include <unordered_set>
using namespace std;

// 本题考查 图，判断两个顶点不能一样

int main() {
    int n, r, k, m;
    int s1, s2;
    cin >> n >> r >> k;
    vector<vector<int> > adj(n + 1); // 邻接关系
    // r条边
    for (int i = 0; i < r; i++) {
        cin >> s1 >> s2;
        adj[s1].push_back(s2);
        adj[s2].push_back(s1);
    }

    cin >> m;
    vector<int> neg(n+1);
    bool flag; // 判断是否满足条件
    unordered_set<int> spec; //动物种类
    while (m--) {
        fill(neg.begin(), neg.end(), 0); // 默认没有邻居
        flag = true;
        spec.clear();
        for (int i = 1; i <= n; i++) {
            cin >> s1;
            // if (!flag) continue;
            neg[i] = s1;
            spec.insert(s1);
            for (int j = 0; j < adj[i].size(); j++) {
                s2 = adj[i][j];
                // 判断他的邻居
                if (neg[s2] == s1) flag = false;
            }
        }
        if (spec.size() == k) {
            printf("%s\n", flag ? "Yes" : "No");
        } else if(spec.size() > k) {
            printf("Error: Too many species.\n");
        } else {
            printf("Error: Too few species.\n");
        }
    }
    return 0;
}
```

## 7-4 Replacement Selection (30分)

When the input is much too large to fit into memory, we have to do **external sorting** instead of internal sorting. One of the key steps in external sorting is to generate sets of sorted records (also called **runs**) with limited internal memory. The simplest method is to read as many records as possible into the memory, and sort them internally, then write the resulting run back to some tape. The size of each run is the same as the capacity of the internal memory.

**Replacement Selection** sorting algorithm was described in 1965 by Donald Knuth. Notice that as soon as the first record is written to an output tape, the memory it used becomes available for another record. Assume that we are sorting in ascending order, if the next record is not smaller than the record we have just output, then it can be included in the run.

For example, suppose that we have a set of input { 81, 94, 11, 96, 12, 99, 35 }, and our memory can sort 3 records only. By the simplest method we will obtain three runs: { 11, 81, 94 }, { 12, 96, 99 } and { 35 }. According to the replacement selection algorithm, we would read and sort the first 3 records { 81, 94, 11 } and output 11 as the smallest one. Then one space is available so 96 is read in and will join the first run since it is larger than 11. Now we have { 81, 94, 96 }. After 81 is out, 12 comes in but it must belong to the next run since it is smaller than 81. Hence we have { 94, 96, 12 } where 12 will stay since it belongs to the next run. When 94 is out and 99 is in, since 99 is larger than 94, it must belong to the **first run**. Eventually we will obtain two runs: the first one contains { 11, 81, 94, 96, 99 } and the second one contains { 12, 35 }.

Your job is to implement this replacement selection algorithm.

### Input Specification:

Each input file contains several test cases. The first line gives two positive integers N (≤10^5)*N*(≤105) and M (<N/2)*M*(<*N*/2), which are the total number of records to be sorted, and the capacity of the internal memory. Then N numbers are given in the next line, all in the range of **int**. All the numbers in a line are separated by a space.

### Output Specification:

For each test case, print in each line a run (in ascending order) generated by the replacement selection algorithm. All the numbers in a line must be separated by exactly 1 space, and there must be no extra space at the beginning or the end of the line.

### Sample Input:

```
13 3
81 94 11 96 12 99 17 35 28 58 41 75 15
```

### Sample Output:

```
11 81 94 96 99
12 17 28 35 41 58 75
15
```

### 分析

本题题目有点没看明白，后来参考[2020年7月第4题 PAT甲级真题 Replacement Selection (30分)](https://blog.csdn.net/allisonshing/article/details/107626332),代码中描述很清楚，根据代码的意思。题目描述的意思应该是。内部内存具有排序功能，每一轮排序都会输出内部内存中的最小值。同时外部内存中即将进入内部内存的值会和该最小值比较，若大于该最小值，则参与到该内部排序中，否则将这个值暂时保存起来且不进入到内部排序，等到当前这轮内部排序完成后再处理刚刚保存起来的值，进入新的一轮内部排序。

> 觉得题目中` { 94, 96, 12 } `这个存在误导性。理论上`12`其实不应该放到内部内存中的，因为当前这轮排序还在继续，而`12`在下一轮的排序才参与排序。

### 代码

```C++
#include <iostream>
#include <string>
#include <cmath>
#include <algorithm>
#include <vector>
#include <unordered_set>
#include <queue>
using namespace std;

// 本题考查 外部排序算法
// 步骤：1. 尽可能读取记录，在进行内部排序 2. 将结果写入到run中
// 重要重要重要：本题把小于内部内存中有序队列的第一个值的值的放在下一轮中等待比较比较

int main() {
    int n, m; // m 内存大小
    cin >> n >> m;
    vector<int> arr(n);
    for (int i = 0; i < n; i++) cin >> arr[i];
    priority_queue<int, vector<int>, greater<int> > pq;
    vector<int> cur, next;
    int num = 0, idx = m, top;
    for (int i = 0; i < m; i++) pq.push(arr[i]);
    while (num != n) {
        top = pq.top(); // 和这个比较
        cur.push_back(top);
        num++;
        pq.pop();
        if (idx < n) { // 处理接下来的数字
            // 若大于最小的数字放进队列中，否则加入到下一轮的比较
            if (arr[idx] > top) pq.push(arr[idx++]);
            else next.push_back(arr[idx++]);
        }
        // 当前该轮结果比较完成
        if (pq.empty()) {
            for (int i = 0; i < cur.size(); i++) {
                printf("%d ", cur[i]);
                if (i < cur.size() - 1) printf(" ");
            }
            printf("\n");
            cur.clear();
            // 将下轮结果设置为当前这轮
            for (int i = 0; i < next.size(); i++) {
                pq.push(next[i]);
            }
            next.clear();
        }
    }
    return 0;
}
```

## 参考

- [7-1 Prime Day (20分)](https://segmentfault.com/a/1190000038372948)
- [7-2 The Judger (25分)](https://segmentfault.com/a/1190000038377285)
- [7-3 Safari Park (25分)](https://segmentfault.com/a/1190000038373148)
- [7-4 Replacement Selection (30分)](https://segmentfault.com/a/1190000038377906)
