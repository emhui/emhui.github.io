---
title: 基本排序算法实现（归并、快排、选择、插入）
date: 2021-03-10 12:28:06
update: 2021-04-05 11:24:06
tags: [归并排序, 快速排序, 选择排序, 插入排序, PAT, leetcode]
categories: [LeetCode]
index_img: https://images.unsplash.com/photo-1613631050894-bcf3e8ab2d98?ixlib=rb-1.2.1&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=1080&fit=max
---

# 排序专题

## 归并排序

### 递归实现

2路归并排序是将当前区间 **[left, right]**(闭区间)分成两半，对两个区间分别递归进行归并排序

`merge`函数将两个有序的子区间进行合并

```C++
const int MAX = 1000;

void merge(int A[], int l1, int r1, int l2, int r2) {
	int i = l1, j = l2;
	int temp[MAX], idx = 0;
	while (i <= l1 && j <= l2) {
		if (A[i] < A[j]) {
			temp[idx++] = A[i];
			i++;
		} else {
			temp[idx++] = A[j];
			j++;
		}
	}
	while (i <= l1) temp[idx++] = A[i++];
	while (j <= l2) temp[idx++] = A[j++];
	// 还原回去
	for (i = 0; i < idx; i++)
	{
		A[l1 + i] = temp[i];
	}
}

void mergeSort(int A[], int left, int right) {
	if (left < right) {
		int mid = (left + right) >> 1;
		// 先归并在排序
		mergeSort(A, left, mid);
		mergeSort(A, mid + 1, right);
		merge(A, left, mid, mid + 1, right);
		// 在PAT考试中，如果没有要求，可以直接使用
		// sort(A + left, A + right + 1);
	}
}
```

### 非递归版本实现

`merge`函数还是一样的，用来 **合并有序子区间**。所以需要更改的是`mergeSort`函数，归并排序是一开始2个一组，然后是4个一组，8个一组。

```C++
const int MAX = 1000;
void merge(int A[], int left, int mid, int right) {
	int i = left, j = mid + 1;
	int temp[MAX], idx = 0;
	while (i <= mid && j <= right) {
		if (A[i] < A[j]) temp[idx++] = A[i++];
		else temp[idx++] = A[j++];
	}
	while (i <= mid) temp[idx++] = A[i++];
	while (j <= right) temp[idx++] = A[j++];
	for (int i = 0; i < idx; i++) A[left + i] = temp[i];
}

void mergeSort(int A[]) {
	for (int size = 1; size < n; size += size) { // 子区间的大小
		for (int start = 0; start < n - size; start += size * 2) { // 子区间开始索引
			// 合并两个子区间，两个子区间的大小是 size * 2
			// 第一个子区间的范围是 [start, start + size - 1]
			// 第二个子区间的范围是 [start + size, min(start + size * 2 - 1, n  -1)];
			// 最后一个区间可能大小小于size，所以需要和 n-1进行比较。取最小的那个。
			merge(A, start, start + size - 1, min(start + size * 2 - 1, n - 1));
		}
	}
}
```

## 快速排序

平均时间复杂度 $O(nlogn)$ .

原理：随机选择待排序序列中的一个数，将小于该数的放在它的右边，大于该数的放在它的左边。

快速排序的切分

```C++
int partition(int A[], int left, int right)
{
	int rand = rand() % (right - left + 1) + left;
	swap(A[left], A[rand]);
	int temp = A[left]; // 这一步最好使用随机选择主元的方法
	while (left < right) {
		while (left < right && A[right] > temp) right--;
		A[left] = A[right];
		// 这里需要添加=号
		while (left < right && A[left] <= temp) left++;
		A[right] = A[left];
	}
	A[left] = temp;
	return left; // 返回相遇的下标
}

void quickSort(int A[], int left, int right) {
	if (left < right) {
		// pos 左边的元素均小于右边的元素
		// 数组分区，找到基准的位置。
		int pos = partition(A, left, right);
		// 排序小于基准的分区
		quickSort(A, left, pos - 1);
		// 排序大于基准的分区
		quickSort(A, pos + 1, right);
	}
}
```


C++ 实现随机数

```C++
#include <stdlib.h>
#include <time.h>

int main () {
	srand((unsigned)time(NULL));
	printf("%d\n", rand());
	// 生成某个范围内的数字，比如[a, b]
	int rand = rand() % (b - a + 1) + a;
```

## 选择排序

原理：从数组第一个元素开始，每次找到最小的一个元素，把它放到前面。

实现代码如下

```C++
void selectSort(int A[], int n) {
	for (int i = 0; i < n; i++) {
		int min_idx = i;
		for (int j = i + 1; j < n; j++) {
			if (A[min_idx] > A[j]) min_idx = j;
		}
		swap(A[min_idx], A[i]);
	}
}
```

## 插入排序

原理：和上面差不多，但是这个是逐个往前插入。

代码如下

```C++
void insertSort(int A[], int n) {
	for (int i = 0; i < n; i++) {
		int temp = A[i], j = i;
        while (j > 0 && A[j - 1] > temp) {
            A[j] = A[j - 1];
            j--;
        }
		A[j] = temp;
	}
}
```

## 算法验证（归并、选择、插入、快排）

```C++
#include <iostream>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <stdlib.h>
#include <time.h>
using namespace std;

void insertSort(int A[], int n) {
	for (int i = 0; i < n; i++) {
		int temp = A[i], j = i;
        while (j > 0 && A[j - 1] > temp) {
            A[j] = A[j - 1];
            j--;
        }
		A[j] = temp;
	}
}

void selectSort(int A[], int n) {
	for (int i = 0; i < n; i++) {
		int min_idx = i;
		for (int j = i + 1; j < n; j++) {
			if (A[min_idx] > A[j]) min_idx = j;
		}
		swap(A[min_idx], A[i]);
	}
}

void print(int A[], int n) {
    for (int i = 0; i < n; ++i) {
        printf("%d ", A[i]);
    }
    printf("\n");
}

void merge(int A[], int left, int mid, int right) {
    int i = left, j = mid + 1;
    int temp[10], idx = 0;
    while (i <= mid && j <= right) {
        if (A[i] < A[j]) temp[idx++] = A[i++];
        else temp[idx++] = A[j++];
    }
    while (i <= mid) temp[idx++] = A[i++];
    while (j <= right) temp[idx++] = A[j++];
    for (int i = 0; i < idx; i++) A[left + i] = temp[i];
}

// 使用递归的方法
void mergeSort(int A[], int left, int right) {
    // 如果是等于，就不用排序了。
    if (left >= right) return;
    int mid = (left + right) >> 1;
    mergeSort(A, left, mid);
    mergeSort(A, mid + 1, right);
    merge(A, left, mid, right);
}

// 使用迭代的方法
void mergeSort2(int A[], int n) {
    for (int size = 1; size < n; size += size) { // 每轮合并规模
        for (int start = 0; start < n - size; start += size * 2) {
            merge(A, start, start + size - 1, min(start + size * 2 - 1 , n - 1));
        }
    }
}

int parition(int A[], int left, int right) {
    int temp = A[left];
    while (left < right) {
        while (left < right && A[right] > temp) right--;
        A[left] = A[right];
        // 这里需要添加等于号，不然程序遇到相同的会卡死
        while (left < right && A[left] <= temp) left++;
        A[right] = A[left];
    }
    A[left] = temp;
    return left;
}

int randomPartition(int A[], int left, int right) {
    int r = rand() % (right - left + 1) + left;
    swap(A[left], A[r]);
    return parition(A, left, right);
}

void quickSort(int A[], int left, int right) {
    if (left >= right) return;
    // int pos = parition(A, left, right);
    int pos = randomPartition(A, left, right); // 随机选择一个数做为主元
    quickSort(A, left, pos - 1);
    quickSort(A, pos + 1, right);
}

int main() {
    srand((unsigned)time(NULL));
    int n = 10;
    int A[10] = {91,61,3,90,61,235,61,23,0,-1};
    insertSort(A, n);
    // selectSort(A, n);
    // mergeSort(A, 0, 9); // 使用递归的方法实现归并排序
    // mergeSort2(A, 10); // 使用迭代的方法实现归并排序
    // quickSort(A, 0, 9);
    print(A, 10);
}
```

## 计数排序

思路：计数排序假定数据范围是 $0 \sim k$。对于每一个元素 $x$，确定小于 $x$的个数，通过这个信息，就可以知道 $x$的位置。比如有10个小于$x$的数字，那么$x$的位置应该就是11.

具体实现：需要有三个数组

> n 是数组个数，k是最大值

- A[0, n]：待排序的数组
- B[0, n]：存放排好序的数组
- C[0, k]：临时数组

伪代码如下

```c++
void counter_sort(int A[], int B[], int n, int k) {
  int C[k];
  // 1. 初始化C
  for (int i = 0; i < k; i++) C[i] = 0;
  // 2. 统计A中各个元素个数
  for (int i = 0; i < n; i++) C[A[i]]++;
  // 3. 统计C[i]中每个小于等于i的个数
  for (int i = 1; i < k; i++) C[i] = C[i - 1];
  // 4. 通过计数，将A中结果放到B中
  for (int i = 0; i < n; i++) {
    B[C[A[i]]] = A[i];
    C[A[i]]--; // 防止重复
  }
}
```

如图所示![aQeood](https://gitee.com/yoyhm/oss/raw/master/uPic/aQeood.png)

时间复杂度：$O(n+k)$

空间复杂度：$O(n+k)$

## 基数排序（待更新）

思路：从低位到高位依次排序，每次排序的时候数值取出顺序不能改变。

![PZVDLt](https://gitee.com/yoyhm/oss/raw/master/uPic/PZVDLt.png)

实现：

```c++
void radix_sort(int A[], int d) {
	for (int i = 1; i <= d; i++) {
    // 对每一位进行排序
  }
}
```

## 桶排序(待更新)

思路：和计数排序类似。

![bkzd9Z](https://gitee.com/yoyhm/oss/raw/master/uPic/bkzd9Z.png)

实现

```c++
void bucket_sort(int A[], int n) {
  
}
```