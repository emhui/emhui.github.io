---
title: 基本排序算法实现（归并、快排、选择、插入）
date: 2021-03-10 12:28:06
update: 2021-04-05 11:24:06
tags: [归并排序, 快速排序, 选择排序, 插入排序, PAT, leetcode]
categories: [LeetCode]
index_img: https://images.unsplash.com/photo-1613631050894-bcf3e8ab2d98?ixlib=rb-1.2.1&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=1080&fit=max
---

# 排序专题

## 二路归并排序

### 递归实现

2路归并排序是将当前区间 **[left, right]**(闭区间)分成两半，对两个区间分别递归进行归并排序

`merge`函数将两个有序的子区间进行合并

```C++
const int MAX = 1000;

void merge(int A[], int l1, int r1, int l2, int r2) {
	int i = l1, j = l2;
	int temp[MAX], idx = 0;
	while (i <= l1 && j <= l2) {
		if (A[i] < A[j]) {
			temp[idx++] = A[i];
			i++;
		} else {
			temp[idx++] = A[j];
			j++;
		}
	}
	while (i <= l1) temp[idx++] = A[i++];
	while (j <= l2) temp[idx++] = A[j++];
	// 还原回去
	for (i = 0; i < idx; i++)
	{
		A[l1 + i] = temp[i];
	}
}

void mergeSort(int A[], int left, int right) {
	if (left < right) {
		int mid = (left + right) >> 1;
		// 先归并在排序
		mergeSort(A, left, mid);
		mergeSort(A, mid + 1, right);
		merge(A, left, mid, mid + 1, right);
		// 在PAT考试中，如果没有要求，可以直接使用
		// sort(A + left, A + right + 1);
	}
}
```

### 非递归版本实现

`merge`函数还是一样的，用来 **合并有序子区间**。所以需要更改的是`mergeSort`函数，归并排序是一开始2个一组，然后是4个一组，8个一组。

```C++
const int MAX = 1000;
void merge(int A[], int left, int mid, int right) {
	int i = left, j = mid + 1;
	int temp[MAX], idx = 0;
	while (i <= mid && j <= right) {
		if (A[i] < A[j]) temp[idx++] = A[i++];
		else temp[idx++] = A[j++];
	}
	while (i <= mid) temp[idx++] = A[i++];
	while (j <= right) temp[idx++] = A[j++];
	for (int i = 0; i < idx; i++) A[left + i] = temp[i];
}

void mergeSort(int A[]) {
	for (int size = 1; size < n; size += size) { // 子区间的大小
		for (int start = 0; start < n - size; start += size * 2) { // 子区间开始索引
			// 合并两个子区间，两个子区间的大小是 size * 2
			// 第一个子区间的范围是 [start, start + size - 1]
			// 第二个子区间的范围是 [start + size, min(start + size * 2 - 1, n  -1)];
			// 最后一个区间可能大小小于size，所以需要和 n-1进行比较。取最小的那个。
			merge(A, start, start + size - 1, min(start + size * 2 - 1, n - 1));
		}
	}
}
```

**性能分析**

时间复杂度

- 和初始序列无关，时间复杂度为$O(nlogn)$

空间复杂度

- 排序的时候需要用到额外空间，所示空间复杂度是$O(n)$

## 快速排序

平均时间复杂度 $O(nlogn)$ .

原理：随机选择待排序序列中的一个数，将小于该数的放在它的右边，大于该数的放在它的左边。

快速排序的切分

```C++
int partition(int A[], int left, int right)
{
	int rand = rand() % (right - left + 1) + left;
	swap(A[left], A[rand]);
	int temp = A[left]; // 这一步最好使用随机选择主元的方法
	while (left < right) {
		while (left < right && A[right] > temp) right--;
		A[left] = A[right];
		// 这里需要添加=号
		while (left < right && A[left] <= temp) left++;
		A[right] = A[left];
	}
	A[left] = temp;
	return left; // 返回相遇的下标
}

void quickSort(int A[], int left, int right) {
	if (left < right) {
		// pos 左边的元素均小于右边的元素
		// 数组分区，找到基准的位置。
		int pos = partition(A, left, right);
		// 排序小于基准的分区
		quickSort(A, left, pos - 1);
		// 排序大于基准的分区
		quickSort(A, pos + 1, right);
	}
}
```


C++ 实现随机数

```C++
#include <stdlib.h>
#include <time.h>

int main () {
	srand((unsigned)time(NULL));
	printf("%d", rand());
	// 生成某个范围内的数字，比如[a, b]
	int rand = rand() % (b - a + 1) + a;
```

**性能分析**

时间复杂度

- 最好情况：数组无序的时候，时间复杂度为 $O(nlogn)$
- 最坏情况：数组有序的时候，`while`会从头到尾扫描一遍，时间复杂度是$O(n)$,时间复杂度$O(n^2)$

空间复杂度

- $O(logn)$，因为快排使用了栈，这里是树的深度（怎么理解）？

> 为什么快速排序和其他排序时间复杂度都为$O(nlogn)$,其他排序不叫快速排序呢？因为其他排序的时间复杂度其实是为$O(xnlogn)$这里的$x$是一个常数。相比较，只有快速排序是真正的$O(nlogn)$。所以在同级别下最好的算法。

**优化**

快速排序可以使用下面几种方法优化

- 当排序范围很小的时候，使用插入排序
- 三值取中法，可以选择第1，2，3个数，取中间值作为标准。

## 堆排序

堆是一个完全二叉树，建立一个堆排序，第一步就是将序列按序放到一个数组里面（在完全二叉树中，数组的顺序就是层序遍历）。

建立好完全二叉树后，就开始 **将节点从上往下调整**

调整方案：当前节点V和左右孩子进行比较，存在比V大的就进行交换，交换完成后继续用V和孩子比较，知道不存在孩子节点或孩子节点没有比V大。

向下调整代码

```C++
// low：V节点， high：最后一个元素的下标
// 闭区间
void downAdjust(int low, int high) {
	int i = low, j = i * 2; // j 左边孩子节点
	while (j <= high) { // 孩子节点存在
		// 首先判断左右孩子谁大
		if (j + 1 <= high && heap[j + 1] > heap[j]) {
			j = j + 1; // 默认将j指向最大孩子
		}
		if (heap[j] > heap[i]) {
			swap(heap[j], haep[i]);
			i = j;
			j = i * 2;
		} else {
			break;
		}
	}
}
```

上面是调整过程，但是还需要对一个个节点判断是否需要调整，逐个调整过程如下

```C++
void createHeap() {
	// 从存在子节点的节点开始调整
	for (int i = n / 2; i >= 1; i--) {
		downAdjust(i, n);
	}
}
```

删除堆顶元素。

```C++
void deleteTop() {
	heap[1] = heap[n--];
	downAdjust(1, n); // 重新调整第一个节点
}
```

最后，堆排序如何实现呢？
我们将每次调整后的堆首和最后一个元素交换

```C++
void heapSort() {
	createHeap();
	for (int i = n; i >= 1; i--) {
		swap(heap[i], heap[1]);
		downAdjust(1, i - 1); // 然后开始调整队首的节点
	}
}
```

**性能分析**

时间复杂度：$O(nlogn)$

空间复杂度: $O(1)$

适用情况：选出$n$个最小的数的时候。

优点: **堆排序在所有时间复杂度为$O(nlogn)$的排序算法中，空间复杂度是最好的。**

## 选择排序

原理：从数组第一个元素开始，每次找到最小的一个元素，把它放到前面。

实现代码如下

```C++
void selectSort(int A[], int n) {
	for (int i = 0; i < n; i++) {
		int min_idx = i;
		for (int j = i + 1; j < n; j++) {
			if (A[min_idx] > A[j]) min_idx = j;
		}
		swap(A[min_idx], A[i]);
	}
}
```

## 插入排序

原理：和上面差不多，但是这个是逐个往前插入。

代码如下

```C++
void insertSort(int A[], int n) {
	for (int i = 0; i < n; i++) {
		int temp = A[i], j = i;
        while (j > 0 && A[j - 1] > temp) {
            A[j] = A[j - 1];
            j--;
        }
		A[j] = temp;
	}
}
```

**适用情况讨论**

可以看到，`while (j > 0 && A[j - 1] > temp) `如果这句话不执行的话，那么时间复杂度可以降低到$O(n)$，而这句话不执行的条件就是 **数组基本有序（A[j - 1] <= temp）**。

**时间复杂度分析**

- 最坏情况：整个数组逆序，那么`while()`每次都会执行，时间复杂度为$O(n^2)$
- 最好情况：整个数组有序，那么`while`不会执行，时间复杂度是$O(n)$
- 综上，平均时间复杂度就是$O(n)$

## 希尔排序(缩小增量排序)

前面提到，**插入排序适用于基本有序的数组**。而希尔排序就是将数组调整到基本有序状态。

**性能分析**

希尔排序和 **增量**选择有关系。希尔排序的规则如下（有很多，这里就写出 希尔 自己提出来的）

`floor(n/2), floor(n/4),...,floor(n/2^k), ..., 2, 1`

这种写法时间复杂度为$O(n^2)$

**代码实现**

> [参考1](https://blog.csdn.net/imudges_Zy/article/details/50346603)
>
> [参考2](https://www.233tw.com/algorithm/32143)

```c++
void shellSort(int A[], int n) {
    int gap = n >> 1; // 初始增量为数组长度的一半
    while (gap >= 1) {
        for (int i = gap; i < n; i++) {
            int j = 0;
            int temp = A[i];
            for (j = i - gap; j >= 0 && temp < A[j]; j -= gap) {
                A[j + gap] = A[j];
            }
            A[j + gap] = temp;
        }
        gap >>= 1; // 增量每次减半
    }
}

//参考2:希尔排序
void shellSort(vector<double>& nums, int n)
{
    int i, j, d;
    int temp;
    d = n / 2;//设置增量
    while (d > 0)//出口
    {
        for (i = d; i < n; i++)//对所有组采用直接插入排序
        {
            temp = nums[i];//对相隔d个为止一组采用直接插入排序
            j = i - d;//假如数组十个元素；d==5时，第一轮：第一、第六个元素为一个组，第二、第七个元素为一组...第五、第十个元素为一组;
            //进行插入排序，第二轮d=d/2==2,第1、3、5、7、9为一个组，第2、4、6、8、10为一个组；进行插入排序
            while (j >= 0&&temp<nums[j])
            {
                nums[j + d] = nums[j];
                j = j - d;
            }
            nums[j + d] = temp;
        }
        d = d / 2;//减小增量
    }
}
```

## 基数排序

## 算法验证

```C++
#include <iostream>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <stdlib.h>
#include <time.h>
using namespace std;

void insertSort(int A[], int n) {
    for (int i = 0; i < n; i++) {
        int temp = A[i], j = i;
        while (j > 0 && A[j - 1] > temp) {
            A[j] = A[j - 1];
            j--;
        }
        A[j] = temp;
    }
}

void selectSort(int A[], int n) {
    for (int i = 0; i < n; i++) {
        int min_idx = i;
        for (int j = i + 1; j < n; j++) {
            if (A[min_idx] > A[j]) min_idx = j;
        }
        swap(A[min_idx], A[i]);
    }
}

void print(int A[], int n) {
    for (int i = 0; i < n; ++i) {
        printf("%d ", A[i]);
    }
    printf("\n");
}

void merge(int A[], int left, int mid, int right) {
    int i = left, j = mid + 1;
    int temp[10], idx = 0;
    while (i <= mid && j <= right) {
        if (A[i] < A[j]) temp[idx++] = A[i++];
        else temp[idx++] = A[j++];
    }
    while (i <= mid) temp[idx++] = A[i++];
    while (j <= right) temp[idx++] = A[j++];
    for (int i = 0; i < idx; i++) A[left + i] = temp[i];
}

// 使用递归的方法
void mergeSort(int A[], int left, int right) {
    // 如果是等于，就不用排序了。
    if (left >= right) return;
    int mid = (left + right) >> 1;
    mergeSort(A, left, mid);
    mergeSort(A, mid + 1, right);
    merge(A, left, mid, right);
}

// 使用迭代的方法
void mergeSort2(int A[], int n) {
    for (int size = 1; size < n; size += size) { // 每轮合并规模
        for (int start = 0; start < n - size; start += size * 2) {
            merge(A, start, start + size - 1, min(start + size * 2 - 1 , n - 1));
        }
    }
}

// 快速排序的切分
int parition(int A[], int left, int right) {
    int temp = A[left];
    while (left < right) {
        while (left < right && A[right] > temp) right--;
        A[left] = A[right];
        // 这里需要添加等于号，不然程序遇到相同的会卡死
        while (left < right && A[left] <= temp) left++;
        A[right] = A[left];
    }
    A[left] = temp;
    return left;
}

int randomPartition(int A[], int left, int right) {
    int r = rand() % (right - left + 1) + left;
    swap(A[left], A[r]);
    return parition(A, left, right);
}

void quickSort(int A[], int left, int right) {
    if (left >= right) return;
    // int pos = parition(A, left, right);
    int pos = randomPartition(A, left, right); // 随机选择一个数做为主元
    quickSort(A, left, pos - 1);
    quickSort(A, pos + 1, right);
}

/** 堆排序 **/
// 向下调整
void downAdjust(int A[], int v, int n) {
    int i = v, j = i * 2;
    while (j <= n) { // 判断是否存在孩子节点
        // 始终将j指向权值最大的节点
        if (j + 1 <= n && A[j + 1] > A[j]) j = j + 1;
        if (A[j] > A[i]) {
            swap(A[i], A[j]);
            i = j;
            j = i * 2;
        } else {break;} // break不能忘记，不然会进入死循环
    }
}

// 开始建堆
void createHeap(int A[], int n) {
    // 从存在叶子节点的节点开始调整
    for (int i = n / 2; i >= 1; i--) {
        downAdjust(A, i, n);
    }
}

// 堆排序
void heapSort(int A[], int n) {
    createHeap(A, n);
    for (int i = n; i >= 1; i--) {
        swap(A[i], A[1]); // 将堆顶元素放到最后面
        downAdjust(A, 1, i - 1); // 调整[1, i - 1] 范围
    }
}

void shellSort(int A[], int n) {
    int gap = n / 2; // 初始增量为数组长度的一半
    while (gap >= 1) {
        for (int i = gap; i < n; i++) {
            int j = 0;
            int temp = A[i];
            for (j = i - gap; j >= 0 && temp < A[j]; j -= gap) {
                A[j + gap] = A[j];
            }
            A[j + gap] = temp;
        }
        gap >>= 1;
    }
}

int main() {
    srand((unsigned)time(NULL));
    int n = 10;
    int A[10] = {91,61,3,90,61,235,61,23,0,-1};
    // insertSort(A, n);
    // selectSort(A, n);
    // mergeSort(A, 0, 9); // 使用递归的方法实现归并排序
    // mergeSort2(A, 10); // 使用迭代的方法实现归并排序
    // quickSort(A, 0, 9);
    // heapSort(A, n - 1); // 下标为0不参加排序
    shellSort(A, n); // 希尔排序
    print(A, 10);
}
```
