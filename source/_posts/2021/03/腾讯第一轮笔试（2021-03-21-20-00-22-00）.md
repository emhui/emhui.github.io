---
title: '腾讯第一轮笔试（2021-03-21 20:00-22:00）'
date: 2021-03-24 17:09:32
tags: [笔试, 算法, 腾讯]
categories: [面试]
hide: true
---

# 腾讯第一轮笔试（2021-03-21 20:00-22:00）

[TOC]

## 1. 求给出二叉树的一系列结点，按照顺序返回根结点到该系列结点的路径。

## 2. 操作一个数

对于一个数字`n`存在下面三种操作

1. `n = n - 1`
2. 如果`n`是偶数，则可以 `n = n / 2`
3. 如果`n`是3的倍数，则可以 `n = n / 3`

求将`n`变成0最少的步骤？

输入

首先输入一个`T`，表示测试用例个数，然后接下来每行输入一个`n`。
$(1 <= n <= 2 * 10^9)$

输出

每个`n`对应的步骤。

示例

```
输入
1
10
输出
4
解释：
1. 先执行步骤1，10 - 1 = 9;
2. 在执行步骤3, 9 / 3 = 3;
3. 在执行步骤3, 3 / 3 = 1;
3. 最后执行步骤1, 1 - 1 = 0;
```

<details>
<summary>实现代码</summary>
<pre>

> 通过用例 74%
<code>
```C++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

const long long MAX = 20000000;
long long dp[MAX] = {0};

void init() {
    dp[0] = 0;
    dp[1] = 1;
    dp[2] = 2;
    dp[3] = 2;
    long long dp1, dp2, dp3;
    for (int i = 4; i < MAX; i++) {
        dp1 = dp[i - 1];
        dp2 = i % 2 == 0 ? dp[i / 2] : MAX;
        dp3 = i % 3 == 0 ? dp[i / 3] : MAX;
        dp[i] = min(dp1, dp2) + 1;
        dp[i] = min(dp[i], dp3 + 1);
    }
}

int main() {
    // 动态规划
    // Fn = min(Fn-1, Fn/2, Fn/3) + 1;
    init(); // 因为查询数据比较多，所以预先处理一下数据
    int T;
    long long n;
    scanf("%d", &T);
    while (T--) {
        scanf("%lld", &n);
        printf("%lld
", dp[n]);
    }
}
```
</code>
</pre>
</details>

## 3. 求n个数组的第k小的值

给定T个数组，给出`q`个查询，每个查询选出`p`个数组，求这`p`个数组中第`k`小的值。

**输入**

先输入一个T，表示数组个数。数组编号从($1 \sim T$)

然后接下来T行，每行第一个数是该数组的长度$m_i$, 接下来是$m_i$个数是该数组的各个值。

输入一个`q`，表示要查询次数。

接下来`q`行，每一行第一个数`p`,表示要选出多少个数组，结下来`p`个数表示数组的编号，最后输入一个`k`，表示找出第`k`小的数。

**输出**

输出`q`行结果，每行输入的是第`k`小的数

示例1

```
输入:
2
1 2
2 1 3
2
1 1 1
2 1 2 2
输出:
2
2
```

示例2

```
输入:

1 1
2 2 3
3 5 10 6
4 4 58 2 1
5 1000000000 9 8 4 5
5
1 2 2
2 2 3 3
3 3 4 5 11
4 5 4 3 2 1
5 1 2 5 4 3 7

输出:
3
5
58
1
4
```

**实现代码**

> 通过用例 60%

```C++
#include <iostream>
#include <vector>
#include <algorithm>
#include <queue>
using namespace std;

int main() {
    freopen("in.txt", "r", stdin);
    int n, cnt, val;
    scanf("%d", &n);
    vector<vector<int> > arr(n + 1);
    for (int i = 1; i <= n; i++) {
        scanf("%d", &cnt);
        for (int j = 0; j < cnt; j++) {
            scanf("%d", &val);
            arr[i].push_back(val);
        }
    }
    int q, p, idx, k;
    vector<int> vi;
    scanf("%d", &q);
    priority_queue<int> pq;
    while (q--) {
        while (!pq.empty()) pq.pop();
        vi.clear();
        scanf("%d", &p);
        vi.resize(p);
        for (int i = 0; i < p; i++) {
            scanf("%d", &val);
            vi[i] = val;
        }
        scanf("%d", &k);
        for (int i = 0; i < vi.size(); i++) {
            idx = vi[i];
            for (int j = 0; j < arr[idx].size(); j++) {
                if (pq.size() < k) {
                    pq.push(arr[idx][j]);
                } else if (pq.top() > arr[idx][j]){
                    pq.pop();
                    pq.push(arr[idx][j]);
                }
            }
        }
        printf("%d
", pq.top());
    }
    return 0;
}
```

## 4. 分工资

一个公司有`n`个人，总奖金有`w`,现在将这些奖金分给出去，假如第`i`个人，给的工资`m`低于`x[i]`或高于`y[i]`都不公平。现在设计一种分配方案，让每个人的工资中位数都最大，求出最大的那个中位数是多少？

输入

首先输入`n, w`分别表示`n`个员工和总奖金

接下来`n`行，每行输入第`i`个的最低工资`x[i]`和最高工资`y[i]`。

输出

最后分配中，工资最高的那个值

示例

```
输入:
3 20
8 10
1 4
7 9
输出:
9
```

**实现代码**

> 通过用例 0%

```C++
#include <iostream>
#include <vector>
#include <algorithm>
#include <queue>
using namespace std;
struct node{
    int low, high, avg;
    node(){}
    node(int _low, int _high, int _avg): low(_low), high(_high), avg(_avg) {}
};

bool cmp(node& a, node& b) {
    if (a.avg != b.avg) return a.avg < b.avg;
    else if (a.low < b.low) return a.low < b.low;
    else return a.high < b.high;
}

int main() {
    freopen("in.txt", "r", stdin);
    int n, w;
    cin >> n >> w;
    vector<node> arr;
    int low, high;
    int max_avg = -1, avg, all_w = 0;
    for (int i = 0; i < n; i++) {
        cin >> low >> high;
        avg = (low + high) >> 1;
        all_w += avg; //
        max_avg = max(max_avg, avg);
        arr.push_back(node(low, high, avg));
    }
    // 最优的策略

    sort(arr.begin(), arr.end(), cmp);
    if (all_w < w) { // 从最后一个人开始加工资，看能否加到最大
        for (int i = n - 1; i >= 0; i--) {
            if (all_w < w && arr[i].avg < arr[i].high - 1) {
                all_w++;
                arr[i].avg++;
            }
            if (all_w == w) break;
        }
    } else if (all_w > w) // 从第一个人开始减工资
    {
        for (int i = 0; i < n; i++) {
            if (all_w > w && arr[i].avg > arr[i].low + 1) {
                all_w--;
                arr[i].avg--;
            }
            if (all_w == w) break;
        }
    }
    sort(arr.begin(), arr.end(), cmp);
    printf("%d
", arr[n-1].avg);
    return 0;
}
```

## 5. 买买买

小牛的妹妹很久没买东西了，到了商城，小牛的妹妹疯狂买买买，每件的东西价值是`w`, 比如第`i`的物品的价值是`wi`, 但是小牛为了不让牛妹这样买下去，就和牛妹说，今天带的💰只能付`m`的倍数。

求小牛在最坏的情况下，还剩下多少钱。

**输入**

一开始输入`T`,表示`T`个测试用例。

接下来每个用例，第一个数`n`表示牛妹买了`n`个东西，第2个数`m`表示小牛能付`m`的倍数💰。

接下来有`n`个数据，分别表示第`i`个的价值`wi`.

**输出**

输出小牛还剩多少钱

示例

```
输入:
2
3 3
3 6 9
3 5
9 6 3
输出:
0
3
解释:
1. 小牛将所有东西都买下来了 3 + 6 + 9 = 18, 18 % 3 = 0; 最后剩下0元
2. 小妹只能买 9 + 6 = 15, 15 % 5 = 0, 最后那件物品（3元）不能付款，所以剩下了3元。
```


