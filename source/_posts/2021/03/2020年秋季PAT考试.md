---
title: 2020年秋季PAT考试
date: 2021-03-08 14:37:14
tags: [PAT, 数学, 前缀和, 二分查找, 拓扑排序, 最短路径, Dijkstra]
categories: [PAT]
index_img: https://images.unsplash.com/photo-1433878455169-4698e60005b1?crop=entropy&cs=tinysrgb&fit=crop&fm=jpg&h=900&ixid=MXwxfDB8MXxyYW5kb218fHx8fHx8fA&ixlib=rb-1.2.1&q=80&utm_campaign=api-credit&utm_medium=referral&utm_source=unsplash_source&w=1600
---
# 2020年秋季PAT考试

## 7-1 Panda and PP Milk (20分)

PP milk （盆盆奶）is Pandas' favorite. They would line up to enjoy it as show in the picture. On the other hand, they could drink in peace only if they believe that the amount of PP milk is fairly distributed, that is, fatter panda can have more milk, and the ones with equal weight may have the same amount. Since they are lined up, each panda can only compare with its neighbor(s), and if it thinks this is unfair, the panda would fight with its neighbor.

Given that the minimum amount of milk a panda must drink is 200 ml. It is only when another bowl of milk is at least 100 ml more than its own that a panda can sense the difference.

Now given the weights of a line of pandas, your job is to help the breeder（饲养员）to decide the minimum total amount of milk that he/she must prepare, provided that the pandas are lined up in the given order.

### Input Specification:

Each input file contains one test case. For each case, first a positive integer n (≤104) is given as the number of pandas. Then in the next line, n positive integers are given as the weights (in kg) of the pandas, each no more than 200. the numbers are separated by spaces.

### Output Specification:

For each test case, print in a line the minimum total amount of milk that the breeder must prepare, to make sure that all the pandas can drink in peace.

### Sample Input:

```
10
180 160 100 150 145 142 138 138 138 140`
```

### Sample Output:

```
3000
```

### Hint:

The distribution of milk is the following:

```
400 300 200 500 400 300 200 200 200 300
```

### 思路

设置两个数组`leftScan, rightScan`，一个从左往右扫描，另一个从右往左扫描。两个数组都需要满足下面逻辑。

- 默认两个数组的起始位置的牛奶量都是200ml。
- 若当前的重量比上一个猫的重量重，则这个猫的牛奶量在上一个猫的基础上+100ml。
- 若当前重量和上一个猫的重量一样，则这个猫的牛奶量和上一个猫一样。
- 若当前重量比上一个猫的重量小，那这个猫的牛奶量为200ml。

伪代码如下

```C++
vector<int> weight;
int curPanda, prePanda;

if (weight[curPanda] > weight[prePanda]) {
	weight[curPanda] = weight[prePanda] + 100;
} else if (weight[curPanda] == weight[prePanda]) {
	weight[curPanda] = weight[prePanda];
} else {
	weight[curPanda] = 200;
}
```

最后取左右扫描后结果最大的值就是所求答案。

### 代码

```C++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    // freopen("in.txt", "r", stdin);
    int n;
    cin >> n;
    vector<int> leftScan(n), rightScan(n), weight(n);
    for (int i = 0; i < n; ++i) {cin >> weight[i];}
    int milk = 200;
    int left = 0, right = n - 1;
    leftScan[left] = rightScan[right] = milk;
    for (int i = 1; i < n; ++i) {
        if (weight[i] > weight[i - 1]) {
            milk += 100;
            leftScan[i] = milk;
        } else if (weight[i] == weight[i - 1]) {
            leftScan[i] = milk;
        } else {
            milk = 200;
            leftScan[i] = milk;
        }
    }
    milk = 200;
    for (int i = n - 2; i >= 0; i--) {
        if (weight[i + 1] > weight[i]) {
            milk = 200;
            rightScan[i] = milk;
        } else if (weight[i + 1] == weight[i]) {
            rightScan[i] = milk;
        } else {
            milk += 100;
            rightScan[i] = milk;
        }
    }
    int sum = 0;
    for (int i = 0; i < n; ++i) {
        sum += max(leftScan[i], rightScan[i]);
    }
    printf("%d\n", sum);
    return 0;
}
```

## 7-2 How Many Ways to Buy a Piece of Land (25分)

The land is for sale in CyberCity, and is divided into several pieces. Here it is assumed that each piece of land has exactly two neighboring pieces, except the first and the last that have only one. One can buy several contiguous（连续的） pieces at a time. Now given the list of prices of the land pieces, your job is to tell a customer in how many different ways that he/she can buy with a certain amount of money.

### Input Specification:

Each input file contains one test case. Each case first gives in a line two positive integers: N (≤104), the number of pieces of the land (hence the land pieces are numbered from 1 to N in order), and M (≤109), the amount of money that your customer has.

Then in the next line, N positive integers are given, where the i-th one is the price of the i-th piece of the land.

It is guaranteed that the total price of the land is no more than 109.

### Output Specification:

For each test case, print the number of different ways that your customer can buy. Notice that the pieces must be contiguous.

### Sample Input:

```
5 85
38 42 15 24 9
```

### Sample Output:

```
11
```

### Hint:

The 11 different ways are:

```
38
42
15
24
9
38 42
42 15
42 15 24
15 24
15 24 9
24 9
```

### 思路

本题考查 **前缀和、二分查找**

题目大意是使用一定的金额购买连续的土地，所以需要求出一定区间内的和，求区间和使用前缀和。

前缀和中，求`sum[i,j] = preSum[j + 1] - [i]`.

题目需要找到区间和满足 `sum[i,j] < k;` k为给定金额。所以可以使用暴力找到所有满足条件的结果或者是使用二分查找，找到第一个区间和大于k的下标。这里主要讲使用二分查找来实现。

找出第一个大于x的二分查找模板如下

```C++
// 找到第一个大于的x的值
int upper_bound(vector<int>& nums, int left, int right, int x) {
    int mid;
    while (left < right) {
        mid = left + ((right - left) >> 1);
        if (nums[mid] > x) right = mid;
        else left = mid + 1;
    }
    return left;
}
```
接下来考虑应该传递什么值到`upper_bound`中呢？

这里主要考虑下面两个问题

- left,right范围？
- x应该是什么？

1. left,right范围？

首先明白二分法的一个概念，查找第一个大于x的值的位置，那么这个值的位置的范围区间是在一个左闭右开区间(假设数组中最后一个值的nums[n - 1], 但是x的值比最后一个值还大，那么x所在的位置肯定是在第n个位置)。本题中需要在前缀和中找到第一个大于x的值，传递到`upper_bound`中的区间范围应该是[0, n + 1). （preSum的范围是[0, n]）.

2. x应该是什么？

在这道题目中，需要找到区间内的和小于k，所以传递的参数应该是`preSum[i] + k`.

得到的和结果是 `preSum[j] - preSum[i]`

但是前面提到过`sum[i, j] = preSum[j + 1] - preSum[i];`

所以最终j的真实区间是`[i, j - 1]`. 即`sum[i, j - 1] = preSum[j] - preSum[i] > k`

所以`upper_bound`中传递的值应该如下所示

```C++
// 使用二分法的话需要-1
int j = upper_bound(preSum, i + 1, n + 1, preSum[i] + k) - 1;
```

最后累加所有满足条件的结果

```C++
ans += (j - i);
```

### 代码

```C++
#include <iostream>
#include <vector>
#include <map>
using namespace std;

int n, m;

// 找到第一个大于的x的值
int upper_bound(vector<int>& nums, int left, int right, int x) {
    int mid;
    while (left < right) {
        mid = left + ((right - left) >> 1);
        if (nums[mid] > x) right = mid;
        else left = mid + 1;
    }
    return left;
}

int main() {
    // freopen("in.txt", "r", stdin);
    cin >> n >> m;
    int piece;
    vector<int> preSum(n + 1, 0);
    for (int i = 0; i < n; i++) {
        cin >> piece;
        preSum[i + 1] = preSum[i] + piece;
    }
    int ans = 0, j;
    for (int i = 0; i < n; i++) {
        // 思考一下这里为什么-1
        // sum[i,j] = preSum[j + 1] - preSum[i];
        // 假如[38, 42, 15]三个值的和是95, 他的范围是 sum[0,3] = preSum[4] - preSum[0];
        // 返回的j的其实存在一个j+1的过程，所以需要-1，这样就是sum[i,j]和了。
        // 二分法是左闭右开区间，preSum的区间在[0,n],二分法区间则在[0, n+1)
        j = upper_bound(preSum, i + 1, n + 1, preSum[i] + m) - 1;
/*         j = i;
        while (j < n && preSum[j + 1] - preSum[i] < m) j++; */
        cout << i << " " << j << endl;
        ans += (j - i);
    }
    printf("%d\n", ans);
    return 0;
}
```

## 7-3 Left-View of Binary Tree (25分)

The **left-view** of a binary tree is a list of nodes obtained by looking at the tree from left hand side and from top down. For example, given a tree shown by the figure, its left-view is { 1, 2, 3, 4, 5 }

![fig.JPG](https://segmentfault.com/img/remote/1460000038392724)

Given the inorder and preorder traversal sequences of a binary tree, you are supposed to output its left-view.

### Input Specification:

Each input file contains one test case. For each case, the first line contains a positive integer N (≤20), which is the total number of nodes in the tree. Then given in the following 2 lines are the inorder and preorder traversal sequences of the tree, respectively. All the keys in the tree are distinct positive integers in the range of **int**.

### Output Specification:

For each case, print in a line the left-view of the tree. All the numbers in a line are separated by exactly 1 space, and there must be no extra space at the beginning or the end of the line.

### Sample Input:

```
2 3 1 5 4 7 8 6
1 2 3 6 7 4 5 8
```

### Sample Output:

```
1 2 3 4 5
```

### 代码

```C++
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

struct TreeNode{
    int val;
    TreeNode *left, *right;
    TreeNode(int _val): val(_val), left(nullptr), right(nullptr) {}
};

int n;
vector<int> preorder, inorder;

TreeNode* create(int preL, int preR, int inL, int inR) {
    if (preL > preR) return nullptr;
    TreeNode* root = new TreeNode(preorder[preL]);
    int mid;
    for (mid = inL; mid <= inR; mid++) {
        if (preorder[preL] == inorder[mid]) break;
    }
    int num = mid - inL;
    root->left = create(preL + 1, preL + num, inL, mid - 1);
    root->right = create(preL + num + 1, preR, mid + 1, inR);
    return root;
}

void bfs(TreeNode* root) {
    queue<TreeNode*> q;
    q.push(root);
    TreeNode* node;
    vector<int> ans;
    while (!q.empty()) {
        int size = q.size();
        for (int i = 0; i < size; i++) {
            node = q.front();
            q.pop();
            if (i == 0) ans.push_back(node->val);
            if (node->left) q.push(node->left);
            if (node->right) q.push(node->right);
        }
    }
    for (int i = 0; i < ans.size(); i++) {
        if (i != 0) printf(" ");
        printf("%d", ans[i]);
    }
    printf("\n");
}

int main() {
    // freopen("in.txt", "r", stdin);
    cin >> n ;
    preorder.resize(n);
    inorder.resize(n);
    for (int i = 0; i < n; i++) cin >> inorder[i];
    for (int i = 0; i < n; i++) cin >> preorder[i];
    TreeNode* root = create(0, n - 1, 0, n - 1);
    bfs(root);
    return 0;
}
```

## 7-4 Professional Ability Test (30分)

Professional Ability Test (PAT) consists of several series of subject tests. Each test is divided into several levels. Level A is a **prerequisite (前置要求)** of Level B if one must pass Level A with a score no less than S in order to be qualified to take Level B. At the mean time, one who passes Level A with a score no less than S will receive a voucher（代金券）of D yuans (Chinese dollar) for taking Level B.

At the moment, this PAT is only in design and hence people would make up different plans. A plan is **NOT** consistent if there exists some test T so that T is a prerequisite of itself. Your job is to test each plan and tell if it is a consistent one, and at the mean time, find the easiest way (with minimum total S) to obtain the certificate of any subject test. If the easiest way is not unique, find the one that one can win the maximum total value of vouchers.

### Input Specification:

Each input file contains one test case. For each case, the first line gives two positive integers N (≤1000) and M, being the total numbers of tests and prerequisite relations, respectively. Then M lines follow, each describes a prerequisite relation in the following format:

```
T1 T2 S D
```

where `T1` and `T2` are the indices (from 0 to N−1) of the two distinct tests; `S` is the minimum score (in the range (0, 100]) required to pass `T1` in order to be qualified to take `T2`; and `D` is the value of the voucher (in the range (0, 500]) one can receive if one passes `T1` with a score no less than `S` and plan to take `T2`. It is guaranteed that at most one pair of `S` and `D` are defined for a prerequisite relation.

Then another positive integer K (≤N) is given, followed by K queries of tests. All the numbers in a line are separated by spaces.

### Output Specification:

Print in the first line `Okay.` if the whole plan is consistent, or `Impossible.` if not.

If the plan is consistent, for each query of test `T`, print in a line the easiest way to obtain the certificate of this test, in the format:

```
T0->T1->...->T
```

However, if `T` is the first level of some subject test (with no prerequisite), print `You may take test T directly.` instead.

If the plan is impossible, for each query of test `T`, check if one can take it directly or not. If the answer is yes, print in a line `You may take test T directly.`; or print `Error.` instead.

### Sample Input 1:

```
8 15
0 1 50 50
1 2 20 20
3 4 90 90
3 7 90 80
4 5 20 20
7 5 10 10
5 6 10 10
0 4 80 60
3 1 50 45
1 4 30 20
1 5 50 20
2 4 10 10
7 2 10 30
2 5 30 20
2 6 40 60
8
0 1 2 3 4 5 6 7
```

### Sample Output 1:

```
Okay.
You may take test 0 directly.
0->1
0->1->2
You may take test 3 directly.
0->1->2->4
0->1->2->4->5
0->1->2->6
3->7
```

### Sample Input 2:

```
4 5
0 1 1 10
1 2 2 10
3 0 4 10
3 2 5 10
2 0 3 10
2
3 1
```

### Sample Output 2:

```
Impossible.
You may take test 3 directly.
Error.
```

### 思路

本题考查 **拓扑排序、有向图、最短路径**

本题题目需要判断该有向图是否连通，使用拓扑排序判断(判断连通这一块比较难想到，因为题目说的是存在一致性，和有向图是否连通判断可能有点难联系)

接下来就是判断以入度为0的点作为起点，然后到达各个点的最短距离。如果把每个入度为0的点都求一次最短路径，可能部分用例会超时，这里参考[7-4 Professional Ability Test (30分)](https://segmentfault.com/a/1190000038393142)做法。

使用一个虚拟头结点，将虚拟头结点指向入度为0的点，本题中，所有的点的范围在`[0~n-1]`。所以将`n`的位置设置为虚拟头结点。只需要求一遍最短路径即可。

### 代码

```C++
#include <iostream>
#include <vector>
#include <queue>
#include <map>
using namespace std;
const int MAX = 987654321;

int n, m;
vector<vector<pair<int, int> > > score, dollar;
vector<int> parent;

bool isTopo(vector<int> inDegree) {
    queue<int> q;
    int num = 0;
    for (int i = 0; i < n; ++i) {
        if (inDegree[i] == 0) {
            // 设置一个虚拟结点指向所以的入度为0的结点
            score[n].push_back(make_pair(i, 0));
            dollar[n].push_back(make_pair(i, 0));
            q.push(i);
        }
    }
    int u;
    while(!q.empty()) {
        u = q.front();
        q.pop();
        num++;
        for (int i = 0; i < score[u].size(); ++i) {
            int v = score[u][i].first;
            if (--inDegree[v] == 0) q.push(v);
        }
    }
    return num == n;
}

void Dijkstra(int s) {
    vector<int> dis(n + 1, MAX), voucher(n + 1, 0), visited(n + 1, 0);
    dis[s] = voucher[s] = 0;
    priority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > pq;
    pq.push(make_pair(0, s));
    for (int i; i < n + 1; ++i) parent[i] = i;
    while (!pq.empty()) {
        int u = pq.top().second;
        pq.pop();
        if (visited[u]) continue;
        visited[u] = 1;
        for (int i = 0; i < score[u].size(); ++i) {
            int v = score[u][i].first, cost = score[u][i].second;
            if (!visited[v]) {
                if (dis[u] + cost < dis[v]) {
                    dis[v] = dis[u] + cost;
                    voucher[v] = voucher[u] + dollar[u][i].second;
                    parent[v] = u;
                    pq.push(make_pair(dis[v], v));
                } else if (dis[u] + cost == dis[v] && voucher[u] + dollar[u][i].second > voucher[v]) {
                    voucher[v] = voucher[u] + dollar[u][i].second;
                    parent[v] = u;
                    pq.push(make_pair(dis[v], v));
                }
            }
        }
    }
}

void dfs(int s) {
    if (s == n) return;
    dfs(parent[s]);
    if (parent[s] != n) printf("->"); // 上一个结点是起点，就不用打印箭头
    printf("%d", s);
}

int main() {
    // freopen("in.txt", "r", stdin);
    cin >> n >> m;
    int t1, t2 ,s, d;
    vector<int> inDegree(n);
    score.resize(n + 1);
    dollar.resize(n + 1);
    parent.resize(n + 1);
    for (int i = 0; i < m; i++) {
        cin >> t1 >> t2 >> s >> d;
        score[t1].push_back(make_pair(t2, s));
        dollar[t1].push_back(make_pair(t2,d));
        inDegree[t2]++;
    }
    bool isConsistent = isTopo(inDegree);
    int k;
    cin >> k;
    if (!isConsistent) {
        printf("Impossible.\n");
        while (k--) {
            cin >> t1;
            if (inDegree[t1] == 0) printf("You may take test %d directly.\n", t1);
            else printf("Error.\n");
        }
    } else {
        printf("Okay.\n");
        Dijkstra(n);
        while (k--) {
            cin >> t1;
            if (inDegree[t1] == 0) printf("You may take test %d directly.\n", t1);
            else {
                dfs(t1);
                printf("\n");
            }
        }
    }
    return 0;
}
```

## 参考

- [7-1 Panda and PP Milk (20分)](https://segmentfault.com/a/1190000038393041)
- [7-2 How Many Ways to Buy a Piece of Land (25分)](https://segmentfault.com/a/1190000038393067)
- [7-3 Left-View of Binary Tree (25分)](https://segmentfault.com/a/1190000038392721)
- [7-4 Professional Ability Test (30分)](https://segmentfault.com/a/1190000038393142)
