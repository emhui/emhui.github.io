---
title: 腾讯面试经验
date: 2021-03-24 22:06:58
tags: [面试]
categories: [面试]
hide: true
---

# 腾讯面试经验(持续更新)

> 记录网上找到的面试经验

> 作者：牛客792235012号
链接：https://www.nowcoder.com/discuss/622306?type=2&order=3&pos=15&page=0&channel=-1&source_id=discuss_tag_nctrack
来源：牛客网

> 面试为Java题目

1、自我介绍

2、说一下static关键字的作用？

<details>
<pre>

static 可以修饰的内容有
- 成员变量和成员方法:让变量和成员被类中的所有对象共享
- 静态代码块:在非静态代码块之前执行,且在类中只执行一次
- 类: 该类是一个静态内部类
- 静态导包: 不需要使用类名就可以调用类中的成员和方法

</pre>
</details>

3、ArrayList与LinkedList的区别？

<details>
<pre>

二者的区别应该从下面几个方面来看.
- 底层实现(数据结构)
	- ArrayList底层是Object[]
	- LinkedList底层实现是双向链表
- 插入和删除效率
	- ArrayList使用数组存储,所以插入和删除效率低于使用链表实现的LinkedList
- 随机访问效率
	- LinkedList使用双链表查询,效率上来看,使用数组的ArrayList随机访问更快
- 内存占用
	- ArraryList 空间不是动态的,可能会有剩余的空间
	- LinkedList 空间可以动态申请,但是存储链表信息也会消耗较多空间.

</pre>
</details>

4、hashmap是否是线程安全的，它是怎样实现的？

<details>
<pre>

hashmap 线程不安全, hashtable线程安全,它内部的方法使用`synchronized`修饰过.
Hashmap的实现原理
在JDK1.8之前和之后底层的实现优点不同,JDK1.8之前是 **数组+链表**, JDK1.8之后是 **数组+链表/红黑树**
大致步骤如下
1. 将key使用哈希方法后获取hash值
2. 使用 `hash & (n - 1)` 计算出该key所在的数组索引值
3. 然后将该key插入到该数组的位置(若相同则覆盖,否则插入到链表首部)

JDK1.8之后在扩容机制上有变化:
- 先对数组进行扩容,当数组长度大于64后
- 再对链表扩容,链表长度大于8,会将链表转成红黑树
JDK1.8之前和之后的实现方法
![hzMSvL](https://gitee.com/yoyhm/oss/raw/master/uPic/hzMSvL.jpg)
![663S5X](https://gitee.com/yoyhm/oss/raw/master/uPic/663S5X.jpg)

</pre>
</details>

5、深拷贝与浅拷贝的区别是什么？

<details>
<pre>

拷贝是创建一个对象,深浅是对该创建该对象的方式.
- 浅拷贝:
	- 对**基本数据类型** 进行值传递
	- 对**引用类型**进行则是复制该对象地址.两个变量指向同一个对象
- 深拷贝:
	- 对**基本数据类型**进行值传递
	- 对**引用数据类型**创建一个新的对象,并复制他的内容.

![rSRtiA](https://gitee.com/yoyhm/oss/raw/master/uPic/rSRtiA.jpg)

</pre>
</details>

6、线程与进程的区别是什么，协程呢？

<details>
<pre>

1. 进程是一个运行中的程序,它可以获取系统的资源.
2. 线程:一个进程内可以有多个线程,这些线程共享进程的资源,而CPU也可以对线程进行调度.所以,线程在上下文切换的时候消耗资源远大于进程.
3. 协程: 是一种轻量级线程,它有自己的 **寄存器上下文和栈(重要,实现切换无开销的关键)** 在协程切换的时候,将寄存器上下文和栈保存起来,切换回来的时候重新回到上一次的调用状态.

这里解释一下寄存器
> 寄存器就是你的口袋。身上只有那么几个，只装最常用或者马上要用的东西。
内存就是你的背包。有时候拿点什么放到口袋里，有时候从口袋里拿出点东西放在背包里。
辅存就是你家里的抽屉。可以放很多东西，但存取不方便。

</pre>
</details>

7、进程间怎样实现通信？

<details>
<pre>

进程之间的通信方式主要有
1. 通道
	在Linux中可以使用`|`就是管道,例如 `ls | grep "t"`
2. 有名管道
3. 信号
	很常见,比如linux中的`kill`就是给进程发送信号,子进程死亡的时候也会给父进程发送 `sigchild`信号.
4. 消息队列
5. 信号量
	一个计数器,可以让多个进程访问一个共享资源
6. 共享内存
	直接访问同一块内存
7. 套接字
	主要用于客服端和服务端中进程的通信
</pre>
</details>

8、线程的同步方法有哪些？

<details>
<pre>

线程同步方式主要有下面几种
1. 互斥量: 互斥机制,一个共享资源只能被一个对象访问.
2. 信号量: 可以实现多个线程对一个共享资源访问.
3. wait/notify: 保持多线程同步

</pre>
</details>

9、计算机网络协议有几层？
OSI七层，学习的话一般抽象为5层，说了下哪五层

<details>
<pre>

计算机网络中IOS协议有7层
- 应用层、表示层、会话层、传输层、网络层、数据链路层、物理层
TCPIP协议有4层
- 应用层、传输层、网际层、网络接口层
最后变成了5层
- 应用层、传输层、网络层、数据链路层、物理层

</pre>
</details>

10、TCP与UDP的区别有哪些？
面向连接，可靠，效率低

<details>
<pre>

先谈一下二者工作方式,然后从工作方式上了解二者的区别.
1. TCP
传输数据之前需要建立连接,传输完成后释放连接.在传输过程中,为了保证数据的可靠,添加很多机制,例如三次握手,超时重传,滑动窗口,拥塞控制和首部添加校验和等.这些措施让TCP传输很可靠,但是这些安全措施会消耗资源,所以在速度上会有劣势.
2. UDP
传输之前不需要建立连接,主机收到数据后也不用发送确认.
3. 综上可以看出在可靠性上,TCP 》 UDP, 但是传输效率上 UDP》TCP

</pre>
</details>

11、详细说一下三次握手，time-wait出现在哪个阶段？
time-wait是在四次挥手客户端最后一次发送确认信号后

<details>
<pre>

三次握手的目的是建立客户端和服务端的连接,而握手过程中可以测试客户端和服务端的接收和发送数据的能力.

在第一次握手过程中,客服端发送数据,若服务器接收成功,证明客户端拥有发送数据的能力,而服务端也拥有接收数据的能力.此次发送的数据为 seq(随机序列x), syn(同步标志)

第二次握手过程中,服务端向客户端发送消息,这个过程证明服务端接收数据正常,此时发送的数据是 seq(随机序列y), syn(同步标志), ACK(确认收到),ack(x + 1, 在之前的seq+1)

第三次握手,则是客户端告诉服务端自己接收数据正常,此时发送的数据是 seq(z), ack(y + 1), ACK(确认收到).

至此,三次握手完成,客户端和服务端接收和发送数据都正常且建立可靠连接,可以发送数据了

time_wait发生在四次挥手的最后一个过程.它主要保证亮点

1. 确保连接断开,防止最后一次挥手服务端没有收到消息.
2. 确保链路中的数据不会在下一次建立连接的时候发送到服务端.

</pre>
</details>

12、select与epoll的区别是什么？

<details>
<pre>

IO多路复用,一个进程可以同时处理多个IO请求.
实现原理: 实现原理：用户将想要监视的文件描述符（File Descriptor）添加到select/poll/epoll函数中，由内核监视，函数阻塞。一旦有文件描述符就绪（读就绪或写就绪），或者超时（设置timeout），函数就会返回，然后该进程可以进行相应的读/写操作。

- select：将文件描述符放入一个集合中，调用select时，将这个集合从用户空间拷贝到内核空间（缺点1：每次都要复制，开销大），由内核根据就绪状态修改该集合的内容。（缺点2）集合大小有限制，32位机默认是1024（64位：2048）；采用水平触发机制。select函数返回后，需要通过遍历这个集合，找到就绪的文件描述符（缺点3：轮询的方式效率较低），当文件描述符的数量增加时，效率会线性下降；
- poll：和select几乎没有区别，区别在于文件描述符的存储方式不同，poll采用链表的方式存储，没有最大存储数量的限制；
- epoll：通过内核和用户空间共享内存，避免了不断复制的问题；支持的同时连接数上限很高（1G左右的内存支持10W左右的连接数）；文件描述符就绪时，采用回调机制，避免了轮询（回调函数将就绪的描述符添加到一个链表中，执行epoll_wait时，返回这个链表）；支持水平触发和边缘触发，采用边缘触发机制时，只有活跃的描述符才会触发回调函数。

主要区别

- 一个线程/进程所能打开的最大连接数
- 文件描述符传递方式（是否复制）
- 水平触发 or 边缘触发
- 查询就绪的描述符时的效率（是否轮询）

</pre>
</details>

13、了不了解什么是一致性哈希算法？

> Redis知识,暂时没有接触过,答案参考网上

<details>
<pre>

一句话概括一致性哈希：就是普通取模哈希算法的改良版，哈希函数计算方法不变，只不过是通过构建环状的 Hash 空间代替普通的线性 Hash 空间。

</pre>
</details>

14、mysql怎样保证的数据一致性？

<details>
<pre>

从数据库层面，数据库通过原子性、隔离性、持久性来保证一致性。也就是说ACID四大特性之中，C(一致性)是目的，A(原子性)、I(隔离性)、D(持久性)是手段，是为了保证一致性，数据库提供的手段。数据库必须要实现AID三大特性，才有可能实现一致性。例如，原子性无法保证，显然一致性也无法保证。

</pre>
</details>

15、对CAP理论了不了解？

> 也是分布式计算中的,暂时没接触过

16、get方法用过吗，说一下？

> 暂时不清楚具体问题

中间还有问是否用过Linux，对设计模式了不了解？

> 不知道具体问题

17. 最后做了个题：leetcode.322   https://leetcode-cn.com/problems/coin-change/

<details>
<summary>实现代码</summary>
<pre>

```C++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        // dp[i] 为凑成金额数量为i的最小金币个数
        vector<int> dp(amount + 1, INT_MAX - 1); // 这里当不存在结果的时候+1就会有溢出，所以需要-1.
        dp[0] = 0;
        for (int i = 1; i < amount + 1; i++) {
            for (auto coin: coins) {
                if (i < coin) {continue;}
                dp[i] = min(dp[i], 1 + dp[i - coin]);
            }
        }
        return dp[amount] == INT_MAX - 1 ? -1 : dp[amount];
    }
};
```

```Java
public class Solution {
    public int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount + 1];
        for (int i = 0; i <= amount; i++) {
            // -1 是防止溢出
            dp[i] = Integer.MAX_VALUE - 1;
        }
        dp[0] = 0;
        for (int i = 1; i <= amount; i++) {
            // 判断是否存在
            for (int coin: coins) {
                if (coin > i) continue;
                dp[i] = Math.min(dp[i], dp[i - coin] + 1);
            }
        }
        return dp[amount] == Integer.MAX_VALUE - 1? -1 : dp[amount];
    }
}
```

</pre>
</details>
