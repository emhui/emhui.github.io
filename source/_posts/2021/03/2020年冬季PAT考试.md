---
title: 2020年冬季PAT考试
date: 2021-03-09 20:06:06
tags:
categories:
---

# 2020年冬季PAT考试

## 7-1 The Closest Fibonacci Number (20 分)

The Fibonacci sequence F​n​​ is defined by F​n+2​​=F​n+1​​+F​n​​ for n≥0, with F​0​​=0 and F​1​​=1. The closest Fibonacci number is defined as the Fibonacci number with the smallest absolute difference with the given integer N.

Your job is to find the closest Fibonacci number for any given N.

### Input Specification:

Each input file contains one test case, which gives a positive integer N (≤10​8​​).

### Output Specification:

For each case, print the closest Fibonacci number. If the solution is not unique, output the smallest one.

### Sample Input:

```
305
```
### Sample Output:

```
233
```

### Hint:

> Since part of the sequence is { 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, ... }, there are two solutions: 233 and 377, both have the smallest distance 72 to 305. The smaller one must be printed out.

### 分析

本题考查 **斐波拉契数列**

题目很简单，直接看代码吧

### 代码

```C++
#include <iostream>
using namespace std;

// 求斐波拉契数列

int main() {
    int n;
    cin >> n;
    int a = 0, b = 1, temp;

    while (b < n) {
        temp = a + b;
        a = b;
        b = temp;
    }
    // 判断 a b 和 n 的差值
    if (n - a <= b - n) printf("%d
", a);
    else printf("%d
", b);
    return 0;
}
```

## 7-2 Subsequence in Substring (25 分)

A substring is a continuous part of a string. A subsequence is the part of a string that might be continuous or not but the order of the elements is maintained. For example, given the string atpaaabpabtt, pabt is a substring, while pat is a subsequence.

Now given a string S and a subsequence P, you are supposed to find the shortest substring of S that contains P. If such a solution is not unique, output the left most one.

### Input Specification:

Each input file contains one test case which consists of two lines. The first line contains S and the second line P. S is non-empty and consists of no more than 10​4​​ lower English letters. P is guaranteed to be a non-empty subsequence of S.

### Output Specification:

For each case, print the shortest substring of S that contains P. If such a solution is not unique, output the left most one.

### Sample Input:

```
atpaaabpabttpcat
pat
```

### Sample Output:

```
pabt
```

### 分析

本体使用暴力求解，在s1中找到第一个等于s2[0]的位置，然后再开始以该位置为起始位置，在s1中逐个寻找s2的元素，直到全部找完。在若干个解中找到字符串长度最小的。

### 代码

```C++
#include <iostream>
#include <string>
using namespace std;

int main() {
    // freopen("in.txt", "r", stdin);
    string s1, s2;
    cin >> s1 >> s2;
    int i = 0, j, dis = 987654321, start;
    while (i < s1.length() - s2.length()) {
        if (s1[i] == s2[0]) {
            j = i;
            for (int k = 0; k < s2.length(); k++) {
                while (j < s1.length() && s1[j] != s2[k]) j++;
            }
            if (dis > j - i + 1) {
                dis = j - i + 1;
                start = i;
            }
        }
        i++;
    }
    printf("%s
", s1.substr(start, dis).c_str());
    return 0;
}
```

## 7-3 File Path (25 分)

![path](https://img-blog.csdnimg.cn/img_convert/8f0c44f4c64c41ee9c46b0f262e93da3.png)
 

The figure shows the tree view of directories in Windows File Explorer. When a file is selected, there is a file path shown in the above navigation bar. Now given a tree view of directories, your job is to print the file path for any selected file.

### Input Specification:

Each input file contains one test case. For each case, the first line gives a positive integer N (≤10​3​​), which is the total number of directories and files. Then N lines follow, each gives the unique 4-digit ID of a file or a directory, starting from the unique root ID 0000. The format is that the files of depth d will have their IDs indented by d spaces. It is guaranteed that there is no conflict in this tree structure.

Then a positive integer K (≤100) is given, followed by K queries of IDs.

### Output Specification:

For each queried ID, print in a line the corresponding path from the root to the file in the format: 0000->ID1->ID2->...->ID. If the ID is not in the tree, print Error: ID is not found. instead.

### Sample Input:

```
14
0000
 1234
  2234
   3234
    4234
    4235
    2333
   5234
   6234
    7234
     9999
  0001
   8234
 0002
4 9999 8234 0002 6666
```

### Sample Output:

```
0000->1234->2234->6234->7234->9999
0000->1234->0001->8234
0000->0002
Error: 6666 is not found.
```

### 分析

本题设置一个结构体，用于存储当前所在的层级，自己的上一层目录是谁。如何找到上一层目录是谁？有三种情况（设置一个变量`pre`表示上一次输入的目录, `cur`表示当前输入的目录）

- 若`cur`和`pre`的层级一样，那么它们的上一层目录一样。
- 若`cur`和`pre`的层级关系是`FP[cur].level = FP[pre].level + 1`，那么`cur`是`pre`的子目录。
- 若`cur`和`pre`的层级关系是`FP[cur].level < FP[pre].level`，则需要从`pre`往上找到和`cur`同一层级的目录，它们的上一层目录一样。

伪代码如下

```c++
if (level == FP[pref].level) {
	FP[f].parent = FP[pref].parent;
	// 如果是子目录
} else if (level == FP[pref].level + 1) {
	FP[f].parent = pref;
	// 不是同级目录，向上找它的父级目录
} else {
	int parent = FP[pref].parent;
	while (FP[parent].level != level) {parent = FP[parent].parent;}
	FP[f].parent = FP[parent].parent;
}
pref = f;
```

具体实现

### 代码

```C++
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;
const int MAX = 100000;

// 创建一个目录
struct F{
    int parent, level;
    F(): parent(-1), level(-1) {}
}FP[MAX];

void split(string s, int& level, int& filename) {
    while (s[level] == ' ') level++;
    filename = stoi(s);
}

void DFS(int f) {
    if (f == 0) {
        printf("0000");
        return;
    }
    DFS(FP[f].parent);
    printf("->%04d", f);
}

int main() {
    // freopen("in.txt", "r", stdin);
    int n, pref = 0;
    string s ;
    cin >> n;
    getchar();

    // 初始化根目录
    FP[0].level = 0;
    FP[0].parent = 0;
    while (n--) {
        getline(cin, s);
        int level = 0, f;
        split(s, level, f);
        FP[f].level = level;
        // 如果目录同级
        if (level == FP[pref].level) {
            FP[f].parent = FP[pref].parent;
            // 如果是子目录
        } else if (level == FP[pref].level + 1) {
            FP[f].parent = pref;
            // 不是同级目录，向上找它的父级目录
        } else {
            int parent = FP[pref].parent;
            while (FP[parent].level != level) {parent = FP[parent].parent;}
            FP[f].parent = FP[parent].parent;
        }
        pref = f;
    }
    int k, f;
    cin >> k;
    while (k--) {
        cin >> f;
        if (FP[f].level == -1) {
            printf("Error: %04d is not found.
", f);
        } else {
            DFS(f);
            printf("
");
        }
    }
    return 0;
}
```

## 7-4 Chemical Equation (30 分)

A chemical equation is the symbolic representation of a chemical reaction in the form of symbols and formulae, wherein the reactant entities are given on the left-hand side and the product entities on the right-hand side. For example, CH​4​​+2O​2​​=CO​2​​+2H​2​​O means that the reactants in this chemical reaction are methane and oxygen: CH​4​​ and O​2​​, and the products of this reaction are carbon dioxide and water: CO​2​​ and H​2​​O.

Given a set of reactants and products, you are supposed to tell that in which way we can obtain these products, provided that each reactant can be used only once. For the sake of simplicity, we will consider all the entities on the right-hand side of the equation as one single product.

### Input Specification:

Each input file contains one test case. For each case, the first line gives an integer N (2≤N≤20), followed by N distinct indices of reactants. The second line gives an integer M (1≤M≤10), followed by M distinct indices of products. The index of an entity is a 2-digit number.

Then a positive integer K (≤50) is given, followed by K lines of equations, in the format:

reactant_1 + reactant_2 + ... + reactant_n -> product
where all the reactants are distinct and are in increasing order of their indices.

Note: It is guaranteed that

one set of reactants will not produce two or more different products, i.e. situation like 01 + 02 -> 03 and 01 + 02 -> 04 is impossible;
a reactant cannot be its product unless it is the only one on the left-hand side, i.e. 01 -> 01 is always true (no matter the equation is given or not), but 01 + 02 -> 01 is impossible; and
there are never more than 5 different ways of obtaining a product given in the equations list.

### Output Specification:

For each case, print the equations that use the given reactants to obtain all the given products. Note that each reactant can be used only once.

Each equation occupies a line, in the same format as we see in the inputs. The equations must be print in the same order as the products given in the input. For each product in order, if the solution is not unique, always print the one with the smallest sequence of reactants -- A sequence { a​1​​,⋯,a​m​​ } is said to be smaller than another sequence { b​1​​,⋯,b​n​​ } if there exists 1≤i≤min(m,n) so that a​j​​=b​j​​ for all j<i, and a​i​​<b​i​​.

It is guaranteed that at least one solution exists.

### Sample Input:

```
8 09 05 03 04 02 01 16 10
3 08 03 04
6
03 + 09 -> 08
02 + 08 -> 04
02 + 04 -> 03
01 + 05 -> 03
01 + 09 + 16 -> 03
02 + 03 + 05 -> 08
```

### Sample Output:

```
02 + 03 + 05 -> 08
01 + 09 + 16 -> 03
04 -> 04
```

### 分析

> 暂时没有思路
