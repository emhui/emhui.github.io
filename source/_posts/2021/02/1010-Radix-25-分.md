---
title: 1010 Radix (25 分)
date: 2021-02-16 21:44:37
tags: [PAT, 进制转换, 二分法]
categories: [PAT]
index_img: https://tva1.sinaimg.cn/large/0060lm7Tly1ftg6ozby6nj31hc0u01cf.jpg
---

# 1010 Radix (25 分)

## 思路

本题考查 **进制转换**和**二分法**

将两个不同进制的数比较，该如何实现呢？

将两个数都转化成十进制方便比较，由于转成10进制可能数字偏大，所以需要用`long long `存储十进制。

将结果转成十进制

```C++
long long convertDecimal(string s, int P) {
    // string s; // 输入的数字
    // int P; // P进制
    int idx = 0; // 表示当前进制
    long long sum = 0, temp;
    for (int i = s.size() - 1; i >= 0; i--) {
        temp = isDigit(s[i]) ? 0 + s[i] : 0 + s[i] - 'a';
        sum += temp * pow(P, idx++);
    }
    return sum;
}
```

将已知进制的数字转成十进制，然后在对未知进制的数字转十进制。

对未知进制的数字转十进制，需要使用二分法，确定未知进制的范围。

- 未知进制的下界为所有数位中最大的那个加1
- 上界为下界与十进制中较大值加1

注意：需要考虑溢出，若溢出，结果会小于0

```C++
long long findRadix(string s, long long num) {
    char maxEle = *max_element(s.begin(), s.end());
    // 下界为所有数位中最大的那个加1
    // 上界为下界与十进制的数较大值加1
    long long low = (isdigit(maxEle) ? maxEle - '0' : 10 + maxEle - 'a') + 1;
    long long high = max(low, num) + 1;
    while (low <= high) {
        long long mid = (low + high) / 2;
        long long temp = convertDecimal(s, mid);
        // 溢出或者是进制过大导致结果超出num
        if (temp < 0 || temp > num) high = mid - 1;
        else if (temp == num) return mid;
        else low = mid + 1;
    }
    return -1;
}
```

## 代码

```C++
#include <iostream>
#include <algorithm>
#include <cmath>
using namespace std;

// string s; // 输入的数字
// int P; // P进制
long long convertDecimal(string s, int P) {
    int idx = 0; // 表示当前进制位
    long long sum = 0, temp;
    for (int i = s.size() - 1; i >= 0; i--) {
        temp = isdigit(s[i]) ? s[i] - '0' : 10 + s[i] - 'a';
        sum += temp * pow(P, idx++);
    }
    return sum;
}

long long findRadix(string s, long long num) {
    char maxEle = *max_element(s.begin(), s.end());
    // 下界为所有数位中最大的那个加1
    // 上界为下界与十进制的数较大值加1
    long long low = (isdigit(maxEle) ? maxEle - '0' : 10 + maxEle - 'a') + 1;
    long long high = max(low, num) + 1;
    while (low <= high) {
        long long mid = (low + high) / 2;
        long long temp = convertDecimal(s, mid);
        // 溢出或者是进制过大导致结果超出num
        if (temp < 0 || temp > num) high = mid - 1;
        else if (temp == num) return mid;
        else low = mid + 1;
    }
    return -1;
}

int main() {
    string n1, n2;
    long long tag = 0, radix = 0, ans;
    cin >> n1 >> n2 >> tag >> radix;
    if (tag == 2) swap(n1, n2);
    ans = findRadix(n2, convertDecimal(n1, radix));
    if (ans != -1) printf("%lld\n", ans);
    else printf("Impossible\n");
    return 0;
}
```

## 参考

- [算法笔记-上机训练实战指南]()
- [[Java] 1010. Radix (25)-PAT甲级](https://blog.csdn.net/liuchuo/article/details/81436415)
