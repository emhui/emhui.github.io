---
title: 二分法查找模板
date: 2021-02-21 15:38:28
tags: [PAT, 二分查找]
categories: [PAT]
---

# 二分法查找模板



二分查找的几种写法，如下图所示（图来源自[二分查找有几种写法？它们的区别是什么？](https://www.zhihu.com/question/36132386)）

![bAVsUI](https://gitee.com/yoyhm/oss/raw/master/uPic/bAVsUI.jpg)



主要分成5种

1. 正好等于给出的`value`的位置

2. 第一个大于等于`value`的值的位置，即`value`的下界(红色箭头表示)

3. 第一个大于`value`的值的位置（蓝色箭头表示）
4. 最后一个等于`value`的值的位置，即`value`的上界（第二黑色箭头表示）
5. 第一个小于`value`的值的位置（第一个黑色箭头表示）



接下来分别对5种进行介绍





## 正好等于`value`值的位置

这一类是最常见，也是最简单的二分查找。

该查找需要注意下面几点：

1. 查找区间在 **[left, right]**，下面例子中的区间是`[0, n-1]`
2. 循环停止条件是`left <= right`

代码如下

```c++
void binarySearch(vector<int>& nums, int value) {
  int left = 0, right = nums.size() - 1, mid;
  while (left <= right) {
    mid = left + ((right - left) >> 1); // 防止溢出
    if (nums[mid] == value) return mid;
    else if (nums[mid] > value) right = mid - 1;
    else left = mid + 1;
  }
  return -1;
}
```

## 第一个大于等于`value`的值的位置

这里其实就是实现C++的`lower_bound`的方法。因为`lower_bound`是一个**左闭右开**的区间，看了很多人的写法，发现各种写法都有，最后个人认为使用**左闭右开**的方法是最简单的。

为什么要**左闭右开**呢？因为要找第一个大于或等于`value`的值的位置，假如一个数组的区间是`[0, n-1]`，如果这个值不在数组所在的区间内，那么一定是在数组的区间的最后一个位置+1，即`n`这个位置。二分查找种，`left,right`表示的就是可能的返回值，所以采用`[0,n)`(证明能取到`n`)这种方法，就比较简单，不需要判断是否越界。

该写法需要注意

1. 搜索区间是 **左闭右开**，下面例子中是`[0, n)`
2. 循环终止的条件是 `left < right`， 和上面的[正好等于`value`值的位置](## 第一个大于等于`value`的值的位置)

代码如下

```c++
int lower_bound(vector<int>& nums, int value) {
  int left = 0, right = nums.size(), mid;
  while (left < right) {
    mid = left + ((right - left) >> 1);
    if (nums[mid] >= value) right = mid; // 第一个大于value的值的位置可能在左侧区间
    else left = mid + 1;
  }
  return left;
}
```

## 第一个大于`value`的值的位置

这里是实现C++中的`upper_bound`方法，也是采用**左闭右开**区间。

代码和上面基本类似，只需要将`if (nums[mid] >= value)`改成`if (nums[mid] > value)`

代码如下

```c++
int upper_bound(vector<int>& nums, int value) {
  int left = 0, right = nums.size(), mid;
  while (left < right) {
    mid = left + ((right - left) >> 1);
    if (nums[mid] > value) right = mid; // 第一个大于value的值的位置可能在左侧区间
    else left = mid + 1;
  }
  return left;
}
```

## 最后一个等于`value`的值的位置

在C++中，只提供了`lower_bound, upper_bound`。为什么没有提供求最后一个等于`value`值的位置呢？其实只需要使用`upper_bound`找到第一个大于`value`的位置，再`-1`就找到了最后一个等于`value`值的位置了。

代码如下

```c++
int findLastPos(vector<int>& nums, int value) {
  return upper_bound(nums, value) - 1;
}

int upper_bound(vector<int>& nums, int value) {
  int left = 0, right = nums.size(), mid;
  while (left < right) {
    mid = left + ((right - left) >> 1);
    if (nums[mid] > value) right = mid; // 第一个大于value的值的位置可能在左侧区间
    else left = mid + 1;
  }
  return left;
}
```

## 第一个小于`value`的值的位置

思路也是和[最后一个等于`value`的值的位置](##最后一个等于`value`的值的位置)一样，使用`lower_bound`获得第一个大于等于`value`值的位置，然后`-1`。

代码如下

```c++
int findFirstPos(vector<int>& nums, int value) {
  return lower_bound(nums, value) - 1;
}

int upper_bound(vector<int>& nums, int value) {
  int left = 0, right = nums.size(), mid;
  while (left < right) {
    mid = left + ((right - left) >> 1);
    if (nums[mid] > value) right = mid; // 第一个大于value的值的位置可能在左侧区间
    else left = mid + 1;
  }
  return left;
}
```

