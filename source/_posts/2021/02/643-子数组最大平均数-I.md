---
title: 643. 子数组最大平均数 I
date: 2021-02-04 08:56:42
tags: [leetcode, 前缀和, 滑动窗口]
categories: [LeetCode]
---

# [643. 子数组最大平均数 I](https://leetcode-cn.com/problems/maximum-average-subarray-i/)

## 题目

给定 n 个整数，找出平均数最大且长度为 k 的连续子数组，并输出该最大平均数。

示例：

> 输入：[1,12,-5,-6,50,3], k = 4
>
> 输出：12.75
>
> 解释：最大平均数 (12-5-6+50)/4 = 51/4 = 12.75

---


## 分析

使用前缀和求出某个范围内的值

```C++
vector<int> preSum(n + 1);
preSum[0] = 0;
for (int i = 0; i < n; i++) {
	preSum[i + 1] = preSum[i] + nums[i];
}
```
![RWxUMT](https://gitee.com/yoyhm/oss/raw/master/uPic/RWxUMT.png)

这里需要注意两点

- preSum[0] 应该为`-10000`,因为nums的范围是`[-10000, 10000]`。
- [i,j]之间的和为`preSum[i+n] - preSum[i]`。

## 代码

```C++
class Solution {
public:
    double findMaxAverage(vector<int>& nums, int k) {
        // 使用前缀和，求出某个范围内最大的值
        int n = nums.size();
        vector<int> preSum(n + 1);
        preSum[0] = 0;
        for (int i = 0; i < n; i++) {
            preSum[i + 1] = preSum[i] + nums[i];
        }
        // 因为存在负数，所以这里不能设置为0
        double maxAverage = -10000;
        int idx = 0;
        while (idx + k < n + 1) {
            double average = 1.0 * (preSum[idx + k] - preSum[idx]) / k;
            maxAverage = max(maxAverage, average);
            idx++;
        }
        return maxAverage;
    }
};
```
