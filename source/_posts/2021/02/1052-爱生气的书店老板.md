---
title: 1052. 爱生气的书店老板
date: 2021-02-23 09:12:52
tags: [leetcode, 滑动窗口]
categories: [LeetCode]
---
# [1052. 爱生气的书店老板](https://leetcode-cn.com/problems/grumpy-bookstore-owner/)

## 题目

![38mmyS](https://gitee.com/yoyhm/oss/raw/master/uPic/38mmyS.png)

## 分析

本题可以使用 **滑动窗口**和**暴力法**来实现。

> 暴力会超时，所以使用滑动窗口，暴力法放在最后面

### 滑动窗口

先记录所有满意的客户，再设置一个大小为X的滑动窗口，依次滑动该窗口，找到里面因为老板愤怒而不满意的用户，将这类用户成为*回心转意的用户*，使用`back`变量表示，该类用户数量最多的窗口即是使用X的最佳时间。所以最后将该类用户和之前就满意的用户累加起来就是结果了。

代码如下

```C++
class Solution {
public:
    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int X) {
        // 暴力法，依次遍历，使用技能时间从0-0+x, 1-1+x, 2-2+x分钟，然后更新答案
        int n = customers.size();
        // 1+1+1+1+7+5 = 16
        int back = -1; // 回心转意的人数
        int left, right;
        int sum = 0;
        // 满意的顾客数量
        for (int i = 0; i < n; i++) if (grumpy[i] == 0) sum += customers[i];
        // 求在滑动窗口内的挽回的生气人数
        for (int i = 0; i + X <= n; i++) {
            int temp = 0;
            left = i;
            while (left < i + X) {
                if (grumpy[left]) temp += customers[left];
                left++;
            }
            back = max(back, temp);
        }
        return back + sum;
    }
};
```

### 暴力法

依次从0开始，计算0-0+x，1-1+x... n-n+x 使用X技能的时候顾客数量，最后取最大值。

代码如下

```C++
class Solution {
public:
    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int X) {
        // 暴力法，依次遍历，使用技能时间从0-0+x, 1-1+x, 2-2+x分钟，然后更新答案
        int n = customers.size();
        int ans = -1;
        int left, right;
        for (int i = 0; i + X <= n; i++) {
            // 计算i-i+x使用了技能的时候最多人数
            int temp = 0;
            // 先计算到i的人数
            left = 0;
            // 计算到达i的这部分满意的人数
            while (left < i) {
                if (grumpy[left] == 0) temp += customers[left];
                left++;
            }
            // 使用技能的人数
            while (left < i + X) {
                temp += customers[left++];
            }
            // 最后达到目的地时候
            while (left < n) {
                if (grumpy[left] == 0) temp += customers[left];
                left++;
            }
            ans = max(ans, temp);
        }
        return ans;
    }
};
```
