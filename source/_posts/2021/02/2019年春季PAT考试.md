---
title: 2019年春季PAT考试
date: 2021-02-27 10:28:29
tags: [PAT]
categories: [PAT]
index_img: https://tva2.sinaimg.cn/large/87c01ec7gy1frmr2kh3xkj21kw0w0e8e.jpg
---
# 2019年春季PAT考试

## 7-1 Sexy Primes (20分)

Sexy primes are pairs of primes of the form (p, p+6), so-named since "sex" is the Latin word for "six". (Quoted from http://mathworld.wolfram.com/SexyPrimes.html)

> 性感素数是一对（p,p+6）形式的素数，为什么这样叫呢？因为在拉丁语中six和sex一样

Now given an integer, you are supposed to tell if it is a sexy prime.

> 现在给你一个整数，你要判断是否它是一个性感素数。

**Input Specification:**

Each input file contains one test case. Each case gives a positive integer N (≤10^8).

**Output Specification:**

For each case, print in a line Yes if N is a sexy prime, then print in the next line the other sexy prime paired with N (if the answer is not unique, output the smaller number).

> 如果是一个性感素数，打印`YES`，然后在下一行打印出另一个和N配对的素数(如果答案不唯一，就打印出最小的那个答案)。

Or if N is not a sexy prime, print No instead, then print in the next line the smallest sexy prime which is larger than N.

> 或者如果N不是性感素数，就打印No，然后打印出最小的性感素数，这个素数需要大于N。

**Sample Input 1:**

> 47

**Sample Output 1:**

> Yes
>
> 41

**Sample Input 2:**

> 21

**Sample Output 2:**

> No
>
> 23

### 题解

本题考查 **素数**。

设置三个参数`b1, b2, b3`分别表示`n - 6, n + 6, n`是否是素数，若满足

`b3 && (b1 || b2) == true` 就证明该数字是性感素数，那么优先打印最小的那个素数（n-6或n+6）。如果不为真，那么就继续寻找下一个最小的的素数,`n++`,再回到刚刚的性感素数判断，直到为true，就打印出`n`

代码如下

```C++
#include <iostream>
#include <cmath>
using namespace std;

bool isPrime(int n) {
    if (n < 2) return false;
	// not forget <= .
    for (int i = 2; i <= (int)sqrt(1.0 * n); i++) {
        if (n % i == 0) return false;
    }
    return true;
}

bool isSexyPrime(int n) {
    return isPrime(n) && (isPrime(n - 6) || isPrime(n + 6));
}

int main() {
    int n;
    cin >> n;
    if (isSexyPrime(n)) {
        printf("Yes\n%d\n", isPrime(n - 6) ? n - 6 : n + 6);
    } else {
        while (!isSexyPrime(++n));
        printf("No\n%d", n);
    }
    return 0;
}
```

## 7-2 Anniversary (25分)

Zhejiang University is about to celebrate her 122th anniversary in 2019.

> 浙江大学打算在2019年庆祝她的第122个周年庆。

To prepare for the celebration, the alumni association （校友会） has gathered the ID's of all her alumni.

> 为了准备这个庆典，校友会已经获取到她的所有校友的ID。

Now your job is to write a program to count the number of alumni among all the people who come to the celebration.

> 你的工作就是写一个程序统计来参加庆典的所有人中，校友的数量。

**Input Specification:**

Each input file contains one test case. For each case, the first part is about the information of all the alumni. Given in the first line is a positive integer N (≤10^5).Then N lines follow, each contains an ID number of an alumnus. An ID number is a string of 18 digits or the letter X. It is guaranteed that all the ID's are distinct.

The next part gives the information of all the people who come to the celebration. Again given in the first line is a positive integer M(≤10^5). Then M lines follow, each contains an ID number of a guest. It is guaranteed that all the ID's are distinct.

**Output Specification:**

First print in a line the number of alumni among all the people who come to the celebration. Then in the second line, print the ID of the oldest alumnus -- notice that the 7th - 14th digits of the ID gives one's birth date. If no alumnus comes, output the ID of the oldest guest instead. It is guaranteed that such an alumnus or guest is unique.

**Sample Input:**

> 5
>
> 372928196906118710
>
> 610481197806202213
>
> 440684198612150417
>
> 13072819571002001X
>
> 150702193604190912
>
> 6
>
> 530125197901260019
>
> 150702193604190912
>
> 220221196701020034
>
> 610481197806202213
>
> 440684198612150417
>
> 370205198709275042

**Sample Output:**

> 3
>
> 150702193604190912

代码如下

```C++
#include <iostream>
#include <string>
#include <unordered_set>
using namespace std;

int main() {
    // 将出生年月日设置为最大的一天
    string oldAlumnu = "999999999999999999", oldGuest = "999999999999999999", s;
    int cnt = 0, n, m;
    unordered_set<string> alumni;
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> s;
        alumni.insert(s);
    }
    cin >> m;
    for (int i = 0; i < m; i++) {
        cin >> s;
        if (alumni.count(s)) { // 如果是校友
            cnt++;
            if (oldAlumnu.substr(6, 8) > s.substr(6, 8)) oldAlumnu = s;
        }
        if (oldGuest.substr(6, 8) > s.substr(6, 8)) oldGuest = s;
    }
    if (cnt) printf("%d\n%s\n", cnt, oldAlumnu.c_str());
    else printf("0\n%s\n", oldGuest.c_str());
    return 0;
}
```

## 7-3 Telefraud Detection (25分)

Telefraud（电信诈骗） remains a common and persistent problem in our society.

> 在我们的社会中，电信诈骗仍然是一个常见和持续存在的问题。

In some cases, unsuspecting victims lose their entire life savings.

> 在某些情况下，毫无戒心的受害者会失去他们一生的积蓄。

To stop this crime, you are supposed to write a program to detect those suspects from a huge amount of phone call records.

> 为了制止这种犯罪，你要写一个程序去从大量的电话记录中侦测这些嫌疑犯。

A person must be detected as a suspect if he/she makes more than K short phone calls to different people everyday, but no more than 20% of these people would call back. And more, if two suspects are calling each other, we say they might belong to the same gang.

> 一个人被认定为嫌疑犯的条件。如果他/她每天给不同的人打了超过K个较短的电话（时间不超过5分钟的通话被认为是较短的通话），但是在所有打电话人数中，只有不超过20%的人回拨了。而且，如果两个嫌疑犯互通电话，我们可以认为他们也许属于同一个团伙。

A makes a short phone call to B means that the total duration of the calls from A to B is no more than 5 minutes.

> A给B打了一个最短的通话是指：A和B的**总通话时常不超过5分钟**。

**Input Specification:**

Each input file contains one test case. For each case, the first line gives 3 positive integers K (≤500K, the threshold（阈值） of the amount of short phone calls), N (≤10^3, the number of different phone numbers), and M (≤10^5,the number of phone call records). Then M lines of one day's records are given, each in the format:

> caller receiver duration

where caller and receiver are numbered from 1 to N, and duration is no more than 1440 minutes in a day.

**Output Specification:**

Print in each line all the detected suspects in a gang, in ascending order of their numbers. The gangs are printed in ascending order of their first members. The numbers in a line must be separated by exactly 1 space, and there must be no extra space at the beginning or the end of the line.

If no one is detected, output None instead.

**Sample Input 1:**

> 5 15 31
>
> 1 4 2
>
> 1 5 2
>
> 1 5 4
>
> 1 7 5
>
> 1 8 3
>
> 1 9 1
>
> 1 6 5
>
> 1 15 2
>
> 1 15 5
>
> 3 2 2
>
> 3 5 15
>
> 3 13 1
>
> 3 12 1
>
> 3 14 1
>
> 3 10 2
>
> 3 11 5
>
> 5 2 1
>
> 5 3 10
>
> 5 1 1
>
> 5 7 2
>
> 5 6 1
>
> 5 13 4
>
> 5 15 1
>
> 11 10 5
>
> 12 14 1
>
> 6 1 1
>
> 6 9 2
>
> 6 10 5
>
> 6 11 2
>
> 6 12 1
>
> 6 13 1

**Sample Output 1:**

> 3 5
>
> 6

Note: In sample 1, although `1` had 9 records, but there were 7 distinct receivers, among which `5` and `15` both had conversations lasted more than 5 minutes in total. Hence `1` had made 5 short phone calls and didn't exceed the threshold 5, and therefore is not a suspect.

**Sample Input 2:**

> 5 7 8
>
> 1 2 1
>
> 1 3 1
>
> 1 4 1
>
> 1 5 1
>
> 1 6 1
>
> 1 7 1
>
> 2 1 1
>
> 3 1 1

**Sample Output 2:**

> None

代码如下

```C++
#include <iostream>
#include <vector>
using namespace std;

const int MAX = 1001;
int k, n, m;
int records[MAX][MAX] = {0}; // 记录i->j的通话时间
vector<int> suspects, visited;

void dfs(int s, vector<int>& gang) {
    visited[s] = 1;
    gang.push_back(suspects[s]);
    int call = suspects[s];
    for (int i = 0; i < suspects.size(); i++) {
        int rev = suspects[i];
        // 如果两个人嫌疑人有过通话，就添加到一个犯罪团伙中
        if (!visited[i] && records[call][rev] != 0 && records[rev][call] != 0) {
            dfs(i, gang);
        }
    }
}

int main() {
    cin >> k >> n >> m;
    int call, rev, dur;
    for (int i = 0; i < m; i++) {
        cin >> call >> rev >> dur;
        records[call][rev] += dur; // 统计通话时常
    }
    int callNum, revNum; // 打电话数量，回电话数量
    for (int i = 1; i <= n; i++) {
        callNum = revNum = 0;
        for (int j = 1; j <= n; j++) {
            if (records[i][j] != 0 && records[i][j] <= 5) { // 存在通话&&通话不超过5分钟的人
                callNum++;
                // 统计回电话的人数
                if (records[j][i] != 0) revNum++;
            }
        }
        // 判断这个人是否是嫌疑人
		// 超过k个最短电话&&回电话的人数不到20%
        if (callNum > k && callNum * 0.2 >= revNum) suspects.push_back(i);
    }
    // 找是否属于同一个犯罪团伙，统一团伙属于同一个连通图
    vector<vector<int>> ans;
    visited.resize(suspects.size(), 0);
    for (int i = 0; i < suspects.size(); i++) {
        vector<int> gang;
        if (!visited[i]) {
            dfs(i, gang);
            ans.push_back(gang);
        }
    }
    for (int i = 0; i < ans.size(); i++) {
        for (int j = 0; j < ans[i].size(); j++) {
            printf("%d", ans[i][j]);
            if (j < ans[i].size() - 1) printf(" ");
        }
        printf("\n");
    }
    if (ans.size() == 0) printf("None\n");
    return 0;
}
```

## 7-4 Structure of a Binary Tree (30分)

Suppose that all the keys in a binary tree are distinct positive integers. Given the postorder and inorder traversal sequences, a binary tree can be uniquely determined.

Now given a sequence of statements about the structure of the resulting tree, you are supposed to tell if they are correct or not. A statment is one of the following:

- A is the root
- A and B are siblings
- A is the parent of B
- A is the left child of B
- A is the right child of B
- A and B are on the same level
- It is a full tree

Note:

Two nodes are on the same level, means that they have the same depth.

A **full binary tree** is a tree in which every node other than the leaves has two children.

**Input Specification:**

Each input file contains one test case. For each case, the first line gives a positive integer N (≤30)N(≤30), the total number of nodes in the binary tree. The second line gives the postorder sequence and the third line gives the inorder sequence. All the numbers in a line are no more than 10^31 and are separated by a space.

Then another positive integer M (≤30) is given, followed by M lines of statements. It is guaranteed that both A and B in the statements are in the tree.

**Output Specification:**

For each statement, print in a line Yes if it is correct, or No if not.

**Sample Input:**

> 9
>
> 16 7 11 32 28 2 23 8 15
>
> 16 23 7 32 11 2 28 15 8
>
> 7
>
> 15 is the root
>
> 8 and 2 are siblings
>
> 32 is the parent of 11
>
> 23 is the left child of 16
>
> 28 is the right child of 2
>
> 7 and 11 are on the same level
>
> It is a full tree

**Sample Output:**

> Yes
>
> No
>
> Yes
>
> No
>
> Yes
>
> Yes
>
> Yes

代码如下

```C++
#include <iostream>
#include <vector>
#include <string>
#include <stack>
using namespace std;

struct TreeNode{
    int val, depth;
    TreeNode *left, *right, *parent, *siblings;
}*root;

vector<int> postorder, inorder;
bool isFullBinaryTree = true;

TreeNode* create(int inl, int inr, int postl, int postr, TreeNode* parent, int depth) {
    if (postl > postr) return NULL;
    TreeNode* root = new TreeNode;
    root->val = postorder[postr];
    root->depth = depth;
    if (parent != NULL) root->parent = parent;
    int mid;
    for (mid = inl; mid <= inr; mid++) if (inorder[mid] == postorder[postr]) break;
    int num = mid - inl;
    root->left = create(inl, mid - 1, postl, postl + num - 1, root, depth + 1);
    root->right = create(mid + 1, inr, postl + num, postr - 1, root, depth + 1);
	// 判断是否是full tree，若左右子结点只存在一个，那么就不是full tree
    if ((root->left && !root->right) || (!root->left && root->right)) isFullBinaryTree = false;
	// 左右子树互相建立兄妹结点联系
    if (root->left && root->right) {
        root->left->siblings = root->right;
        root->right->siblings = root->left;
    }
    return root;
}

int getA(string s) {
    int idx = 0;
    while (s[idx] != ' ') idx++;
    return stoi(s.substr(0, idx));
}

int getLastB(string s) {
    int idx = s.size() - 1;
    while (s[idx] != ' ') idx--;
    return stoi(s.substr(idx + 1));
}

int getMidB(string s) {
    int left = s.find("and") + 4;
    int right = left;
    while (s[right] != ' ') right++;
    return stoi(s.substr(left, right - left));
}

// 从根结点开始获取val值为n的结点
TreeNode* getNode(int n) {
    stack<TreeNode*> st;
    st.push(root);
    TreeNode* node;
    while (!st.empty()) {
        node = st.top();
        if (node->val == n) return node;
        st.pop();
        if (node->right) st.push(node->right);
        if (node->left) st.push(node->left);
    }
    return NULL;
}

bool isParent(int a, int b) {
    TreeNode* node = getNode(b);
    return node->parent->val == a;
}

bool isSiblings(int a, int b) {
    TreeNode* node = getNode(b);
    if (node == NULL || node->siblings->val != a) return false;
    return true;
}

bool isSameDepth(int a, int b) {
    return getNode(a)->depth == getNode(b)->depth;
}

// 从给定的结点作为根结点，返回其子树中val为n的结点
TreeNode* getNode2(TreeNode* substree, int n) {
    if (substree == NULL) return NULL;
    stack<TreeNode*> st;
    st.push(substree);
    TreeNode* node;
    while (!st.empty()) {
        node = st.top();
        if (node->val == n) return node;
        st.pop();
        if (node->right) st.push(node->right);
        if (node->left) st.push(node->left);
    }
    return NULL;
}

bool isLeftTree(int a, int b) {
    TreeNode* node = getNode(b);
    return getNode2(node->left, a) != NULL;
}

bool isRightTree(int a, int b) {
    TreeNode* node = getNode(b);
    return getNode2(node->right, a) != NULL;
}

int main() {
    int n;
    cin >> n;
    postorder.resize(n);
    inorder.resize(n);
    for (int i = 0; i < n; i++) cin >> postorder[i];
    for (int i = 0; i < n; i++) cin >> inorder[i];
    root = create(0, n - 1, 0, n - 1, NULL, 0);
    int m;
    string s;
    cin >> m;
    getchar();
    for (int i = 0; i < m; i++) {
        getline(cin, s);
        if (s.find("root") != s.npos) { // 找到根结点操作
            printf("%s\n", getA(s) == postorder[n - 1] ? "Yes" : "No");
        } else if (s.find("siblings") != s.npos) {
            printf("%s\n", isSiblings(getA(s), getMidB(s)) ? "Yes" : "No");
        } else if (s.find("parent") != s.npos) {
            printf("%s\n", isParent(getA(s), getLastB(s)) ? "Yes" : "No");
        } else if (s.find("left") != s.npos) {
            printf("%s\n", isLeftTree(getA(s), getLastB(s)) ? "Yes" : "No");
        } else if (s.find("right") != s.npos) {
            printf("%s\n", isRightTree(getA(s), getLastB(s)) ? "Yes" : "No");
        } else if (s.find("level") != s.npos) {
            printf("%s\n", isSameDepth(getA(s), getMidB(s)) ? "Yes" : "No");
        } else if (s.find("full") != s.npos) {
            printf("%s\n", isFullBinaryTree ? "Yes" : "No");
        }
    }
    return 0;
}
```

## 参考

- [7-1 Sexy Primes (20分)](https://segmentfault.com/a/1190000038350501)
- [7-2 Anniversary (25分)](https://segmentfault.com/a/1190000038350861)
- [7-3 Telefraud Detection (25分)](https://segmentfault.com/a/1190000038352553)
- [7-4 Structure of a Binary Tree (30分)](https://segmentfault.com/a/1190000038352797)
