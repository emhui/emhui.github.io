---
title: 1438. 绝对差不超过限制的最长连续子数组
date: 2021-02-21 09:03:18
tags: [leetcode, 滑动窗口]
categories: [LeetCode]
---
# [1438. 绝对差不超过限制的最长连续子数组](https://leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/)

## 题目

![GcE882](https://gitee.com/yoyhm/oss/raw/master/uPic/GcE882.png)

## 分析

本题考查 **滑动窗口**。

其实本题需要一直维护窗口内的最大值和最小值。因此可以设置两个参数表示窗口内的最大值和最小值，并且每次移动都更新这两个值。

使用`left, right`表示窗口的范围，`maxVal, minVal`表示窗口内的最大值和最小值

- 若最大值和最小值的差值小于等于`limit`，`right++`,同时更新最大最小值。
- 若最大值和最小值的差大于`limit`, `left++`,同时`right`重新从`left`出发，最大值和最小值更新成`nums[left]`

### 代码如下

```C++
class Solution {
public:
    int longestSubarray(vector<int>& nums, int limit) {
        int left = 0, right = 0;
        int ans = 0, n = nums.size();
        int maxVal = nums[left], minVal = nums[right];
        while (left < n && right < n) {
            while (right < n && maxVal - minVal <= limit) {
                right++; // 更新最大值和最小值
                if (right < n && maxVal < nums[right]) {
                    maxVal = nums[right];
                }
                if (right < n && minVal > nums[right]) {
                    minVal = nums[right];
                }
            }
            ans = max(ans, right - left);
			right = ++left; // 重新出发
            maxVal = minVal = nums[left];
        }
        return ans;
    }
};
```

但是上面这种方法会出现超时，看到官方题解后，发现需要使用`multiset`数据结构来维护窗口内的最大值和最小值。具体方法如下

### 官方题解

```C++
class Solution {
public:
    int longestSubarray(vector<int>& nums, int limit) {
        multiset<int> s;
        int left = 0, right = 0;
        int ans = 0, n = nums.size();
        while (left < n && right < n) {
            s.insert(nums[right]);
            while (*s.rbegin() - *s.begin() > limit) {
                s.erase(s.find(nums[left++])); // 删除最左边的窗口值
            }
            ans = max(ans, right - left + 1);
            right++;
        }
        return ans;
    }
};
```
