---
title: 1013 数素数 (20 分)
date: 2021-02-09 18:01:00
tags: [PAT, 素数]
categories: [PAT]
---

# 1013 数素数 (20 分)

## 题目

![Iifv8h](https://gitee.com/yoyhm/oss/raw/master/uPic/Iifv8h.png)

## 分析

本题考查 **求素数**。

求素数模板如下

```C++
// 注意最大N=10000，即第10000个素数大约在105000 内；这也是测试点4所测试的。
const int MAX = 1e6;

vector<int> primes;
bool visited[MAX] = {false};

bool isPrime(int n) {
    if (n < 2) return false;
    for (int i = 2; i <= (int)sqrt(1.0 * n); i++) {
        if (n % i == 0) return false;
    }
    return true;
}
void findPrime(int n) {
    for (int i = 1; i < MAX; i++) {
        if (!visited[i] && isPrime(i)) {
            primes.push_back(i);
            if (primes.size() > n) break;
            for (int j = i; j < MAX; j += i) {
                visited[j] = true;
            }
        }
    }
}

```

注意：测试点4的N的范围比较大，所以`MAX`的值也需要设大一点。

## 代码

```C++
#include <iostream>
#include <vector>
#include <cmath>
using namespace std;

// 注意最大N=10000，即第10000个素数大约在105000 内；这也是测试点4所测试的。
const int MAX = 1e6;

vector<int> primes;
bool visited[MAX] = {false};

bool isPrime(int n) {
    if (n < 2) return false;
    for (int i = 2; i <= (int)sqrt(1.0 * n); i++) {
        if (n % i == 0) return false;
    }
    return true;
}
void findPrime(int n) {
    for (int i = 1; i < MAX; i++) {
        if (!visited[i] && isPrime(i)) {
            primes.push_back(i);
            if (primes.size() > n) break;
            for (int j = i; j < MAX; j += i) {
                visited[j] = true;
            }
        }
    }
}

int main() {

    int m, n;
    cin >> m >> n;
    findPrime(n);
    int cnt = 0;
    for (int i = m; i <= n; i++) {
        printf("%d", primes[i - 1]);
        cnt++;
        if (cnt % 10 != 0 && i < n) printf(" ");
        else printf("\n");
    }
}
```

## 相似题目

- [1059 Prime Factors (25 分)](https://emhui.fun/2021/02/09/1059-Prime-Factors-25-%E5%88%86/)
