---
title: 2019年秋季PAT考试
date: 2021-02-27 12:06:08
tags: [PAT]
categories: [PAT]
index_img: https://tva2.sinaimg.cn/large/87c01ec7gy1frmry78dkhj21hc0u0n6b.jpg
---
# 2019年秋季PAT考试

## 7-1 Forever (20分)

"Forever number" is a positive integer A with K digits, satisfying the following constrains:

- the sum of all the digits of A is m;
- the sum of all the digits of A+1 is n;
- and the greatest common divisor of m and n is a prime number which is greater than 2.

Now you are supposed to find these forever numbers.

**Input Specification:**

Each input file contains one test case. For each test case, the first line contains a positive integer N (≤5). Then N lines follow, each gives a pair of K (3<K<10) and m (1<m<90), of which the meanings are given in the problem description.

> k,m的含义在上面的问题描述中已给出。

**Output Specification:**

For each pair of K and m, first print in a line Case X, where X is the case index (starts from 1). Then print n and A in the following line. The numbers must be separated by a space. If the solution is not unique, output in the ascending order of n. If still not unique, output in the ascending order of A. If there is no solution, output No Solution.

**Sample Input:**

> 2
>
> 6 45
>
> 7 80

**Sample Output:**

> Case 1
>
> 10 189999
>
> 10 279999
>
> 10 369999
>
> 10 459999
>
> 10 549999
>
> 10 639999
>
> 10 729999
>
> 10 819999
>
> 10 909999
>
> Case 2
>
> No Solution

代码如下

```C++
#include <iostream>
#include <cmath>
using namespace std;

int n, k, m;
bool isOk = false;

int gcd(int m, int n) {
    return n == 0 ? m : gcd(n, m % n);
}

bool isPrime(int n) {
    if (n < 2) return false;
    for (int i = 2; i * i < n; i++) {
        if (n % i == 0) return false;
    }
    return true;
}

int getNum(int n) {
    int sum = 0;
    while (n) {
        sum += n % 10;
        n /= 10;
    }
    return sum;
}

// sum 位数和, cnt 位数, res A
void backtrack(int sum, int cnt, int res) {
    if (sum == m && cnt == k) {
        // 判断res是否是forever
        int n = getNum(res + 1);
        int g = gcd(m, n);
        if (g > 2 && isPrime(g)) {
            isOk = true;
            printf("%d %d", n, res);
        }
        return;
    }
    if (sum > m || cnt > k) return;
    // 如何保证第一位不是0？ 最后两位一定是9
    // 一开始两位是99，第一位肯定是1
    int min = cnt == k - 1 ? 1 : ((cnt == 0)|| (cnt == 1)) ? 9 : 0;

    for (int i = 9; i >= min; i--) {
        backtrack(sum + i, cnt + 1, res + i * pow(10, cnt));
    }
}

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> k >> m;
        isOk = false;
        printf("Case %d", i);
        backtrack(0, 0, 0);
        if (!isOk) printf("No Solution");
    }
    return 0;
}
```

## 7-2 Merging Linked Lists (25分)

Given two singly linked lists $L1=a_1→a_2→⋯→a_{n-1}$ and $L2=b_1→b_2→⋯→b_{m-1}.$ If n≥2m, you are supposed to reverse and merge the shorter one into the longer one to obtain a list like a1→a2→bm→a3→a4→bm−1⋯. For example, given one list being 6→7 and the other one 1→2→3→4→5, you must output 1→2→7→3→4→6→5.

### Input Specification:

Each input file contains one test case. For each case, the first line contains the two addresses of the first nodes of L1 and L2, plus a positive N (≤10^5)*N*(≤105) which is the total number of nodes given. The address of a node is a 5-digit nonnegative integer, and NULL is represented by `-1`.

Then N lines follow, each describes a node in the format:

```
Address Data Next
```

where `Address` is the position of the node, `Data` is a positive integer no more than 10^5, and `Next` is the position of the next node. It is guaranteed that no list is empty, and the longer list is at least twice as long as the shorter one.

### Output Specification:

For each case, output in order the resulting linked list. Each node occupies a line, and is printed in the same format as in the input.

### Sample Input:

```bash
00100 01000 7
02233 2 34891
00100 6 00001
34891 3 10086
01000 1 02233
00033 5 -1
10086 4 00033
00001 7 -1
```

### Sample Output:

```
01000 1 02233
02233 2 00001
00001 7 34891
34891 3 10086
10086 4 00100
00100 6 00033
00033 5 -1
```

代码如下

```C++
// 两个链表夹着一个，使用vector存储短的那个链表
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
const int MAX = 100000;

struct node{
    int address, val, next;
}links[MAX];

void getValidLink(int begin, vector<node>& vlinks) {
    while (begin != -1) {
        vlinks.push_back(links[begin]);
        begin = links[begin].next;
    }
}

int main() {
    int b1, b2, n; // b1, b2: 两个链表的头结点
    int address, val, next;
    scanf("%d%d%d", &b1, &b2, &n);
    for (int i = 0; i < n; i++) {
        scanf("%d%d%d", &address, &val, &next);
        links[address].address = address;
        links[address].val = val;
        links[address].next = next;
    }
    vector<node> vlinks1, vlinks2;
    getValidLink(b1, vlinks1);
    getValidLink(b2, vlinks2);
    // 默认将vlinks1作为较长的那个链表
    if (vlinks2.size() > vlinks1.size()) swap(vlinks1, vlinks2);
    int m = vlinks2.size() - 1;
    int cnt = 0, i;
    for (i = 0; i < vlinks1.size() - 1; i++) {
        printf("%05d %d ", vlinks1[i].address, vlinks1[i].val);
        cnt++;
        if (cnt % 2 == 0 && m >= 0) {
            printf("%05d", vlinks2[m].address);
            printf("%05d %d %05d", vlinks2[m].address, vlinks2[m].val, vlinks1[i + 1].address);
            m--;
        } else {
            printf("%05d", vlinks1[i + 1].address);
        }
    }
    printf("%05d %d -1", vlinks1[i].address, vlinks1[i].val);
    return 0;
}
```

## 7-3 Postfix Expression (25分)

Given a syntax tree (binary), you are supposed to output the corresponding postfix expression, with parentheses reflecting the precedences of the operators.

### Input Specification:

Each input file contains one test case. For each case, the first line gives a positive integer N (≤ 20) which is the total number of nodes in the syntax tree. Then N lines follow, each gives the information of a node (the i-th line corresponds to the i-th node) in the format:

```
data left_child right_child
```

where `data` is a string of no more than 10 characters, `left_child` and `right_child` are the indices of this node's left and right children, respectively. The nodes are indexed from 1 to N. The NULL link is represented by −1. The figures 1 and 2 correspond to the samples 1 and 2, respectively.

![infix1.JPG](https://segmentfault.com/img/remote/1460000038366119)
Figure 1
![infix2.JPG](https://segmentfault.com/img/remote/1460000038366118)

Figure 2

### Output Specification:

For each case, print in a line the postfix expression, with parentheses reflecting the precedences of the operators.There must be no space between any symbols.

### Sample Input 1:

```
8
* 8 7
a -1 -1
* 4 1
+ 2 5
b -1 -1
d -1 -1
- -1 6
c -1 -1
```

### Sample Output 1:

```
(((a)(b)+)((c)(-(d))*)*)
```

### Sample Input 2:

```
8
2.35 -1 -1
* 6 1
- -1 4
% 7 8
+ 2 3
a -1 -1
str -1 -1
871 -1 -1
```

### Sample Output 2:

```
(((a)(2.35)*)(-((str)(871)%))+)
```

代码如下

> 注意要对`+,-`做特殊的判断，他们两个可以不是操作符

```C++
#include <iostream>
#include <vector>
#include <string>
using namespace std;

// 每个子树都需要添加括号
// 还需要找到根结点
const int MAX = 21;

struct TreeNode{
    string val;
    int left, right;
}tree[MAX];

string posttravel(int root) {
    if (root == -1) return "";
    string temp = "(";
    // 不属于操作符，那就选择先访问该结点,在访问其他结点
    if ((tree[root].val == "-" || tree[root].val == "+") && tree[root].left == -1) {
        temp += tree[root].val;
        temp += posttravel(tree[root].right);
        temp += ")";
        return temp;
    }
    temp += posttravel(tree[root].left);
    temp += posttravel(tree[root].right);
    temp += tree[root].val;
    temp += ")";
    return temp;
}

int main() {
    int n;
    string val;
    int left, right;
    cin >> n;
    vector<int> inDegree(n + 1, 0);
    for (int i = 1; i <= n; i++) {
        cin >> tree[i].val >> tree[i].left >> tree[i].right;
        if (tree[i].left != -1) inDegree[tree[i].left]++;
        if (tree[i].right != -1) inDegree[tree[i].right]++;
    }
    int root;
		// 根据root入度为0，找到root
    for (int i = 1; i <= n; i++) {
        if (inDegree[i] == 0) {
            root = i;
            break;
        }
    }
    string ans = posttravel(root);
    cout << ans << endl;
    return 0;
}
```

## 7-4 Dijkstra Sequence (30分)

Dijkstra's algorithm is one of the very famous greedy algorithms. It is used for solving the single source shortest path problem which gives the shortest paths from one particular source vertex to all the other vertices of the given graph. It was conceived by computer scientist Edsger W. Dijkstra in 1956 and published three years later.

In this algorithm, a set contains vertices included in shortest path tree is maintained. During each step, we find one vertex which is not yet included and has a minimum distance from the source, and collect it into the set. Hence step by step an ordered sequence of vertices, let's call it **Dijkstra sequence**, is generated by Dijkstra's algorithm.

On the other hand, for a given graph, there could be more than one Dijkstra sequence. For example, both { 5, 1, 3, 4, 2 } and { 5, 3, 1, 2, 4 } are Dijkstra sequences for the graph, where 5 is the source. Your job is to check whether a given sequence is Dijkstra sequence or not.

### Input Specification:

Each input file contains one test case. For each case, the first line contains two positive integers Nv (≤10^3)*N**v*(≤103)andNe (≤10^5)*N**e*(≤105), which are the total numbers of vertices and edges, respectively. Hence the vertices are numbered from 1 to Nv.

Then Ne lines follow, each describes an edge by giving the indices of the vertices at the two ends, followed by a positive integer weight (≤100) of the edge. It is guaranteed that the given graph is connected.

Finally the number of queries, K, is given as a positive integer no larger than 100, followed by K lines of sequences, each contains a permutationof the Nv vertices. It is assumed that the first vertex is the source for each sequence.

All the inputs in a line are separated by a space.

### Output Specification:

For each of the K sequences, print in a line `Yes` if it is a Dijkstra sequence, or `No` if not.

### Sample Input:

```
5 7
1 2 2
1 5 1
2 3 1
2 4 1
2 5 2
3 5 1
3 4 1
4
5 1 3 4 2
5 3 1 2 4
2 3 4 5 1
3 2 1 5 4
```

### Sample Output:

```
Yes
Yes
Yes
No
```

代码如下

```C++
// 找到到每个点的最短路径。
// 然后判断集合是否满足
// 求出各个的到其他点的最短路径
// 接下来如何判断是否是Dijkstra？
// 判断路径是否是递增的即可
#include <iostream>
#include <vector>
#include <queue>
#include <algorithm>
#include <map>
using namespace std;
const int MAX = 987654321;
int nv, ne, k;
vector<vector<int>> allDis; // 存储各个点到其他点的最短距离
vector<vector<pair<int, int>>> G; // 邻接表

// 从start结点开始
void Dijkstra(int start) {
    vector<int> dis(nv + 1, MAX), visited(nv + 1, 0);
    dis[start] = 0;
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
    pq.push(make_pair(0, start));
    while (!pq.empty()) {
        int u = pq.top().second;
        pq.pop();
        if (visited[u]) continue;
        visited[u] = 1;
        // 更新u到v的结点
        for (int i = 0; i < G[u].size(); i++) {
            int v = G[u][i].first, w = G[u][i].second;
            if (!visited[v] && dis[u] + w < dis[v]) {
                dis[v] = dis[u] + w;
                pq.push(make_pair(dis[v], v));
            }
        }
    }
    // 添加到路径中
    allDis[start] = dis;
}

int main() {
    int n1, n2, w; // n1,n2:node结点,w:权重
    cin >> nv >> ne;
    allDis.resize(nv + 1);
    G.resize(nv + 1);
    for (int i = 0; i < ne; i++) {
        cin >> n1 >> n2 >> w;
        G[n1].push_back(make_pair(n2, w));
        G[n2].push_back(make_pair(n1, w));
    }
    // 求从每个点开始到其他点的最短路径
    for (int i = 1; i <= nv; i++) {
        Dijkstra(i);
    }
    cin >> k;
    int source, node, preDis, isOk;
    while (k--) {
        isOk = 1;
        preDis = 0;
        cin >> source;
        for (int i = 1; i < nv; i++) {
            cin >> node;
            // 如果前面那个距离比后面那个距离大，证明不是Dijkstra序列
            if (preDis > allDis[source][node]) isOk = 0;
            preDis = allDis[source][node];
        }
        printf("%s", isOk ? "Yes" : "No");
    }
}
```
## 参考

- [PAT（甲级）2019年秋季考试 7-1 Forever](https://segmentfault.com/a/1190000038365624)
- [7-2 Merging Linked Lists (25分)](https://segmentfault.com/a/1190000038365930)
- [7-3 Postfix Expression (25分)](https://segmentfault.com/a/1190000038366115)
- [7-4 Dijkstra Sequence (30分)](https://segmentfault.com/a/1190000038366311)
