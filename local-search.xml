<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>1078 Hashing (25 分)</title>
    <link href="/2021/03/10/1078-Hashing-25-%E5%88%86/"/>
    <url>/2021/03/10/1078-Hashing-25-%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1078-Hashing-25-分"><a href="#1078-Hashing-25-分" class="headerlink" title="1078 Hashing (25 分)"></a>1078 Hashing (25 分)</h1><p>The task of this problem is simple: insert a sequence of distinct positive integers into a hash table, and output the positions of the input numbers. The hash function is defined to be H(key)=key%TSize where TSize is the maximum size of the hash table. Quadratic probing (with positive increments only) is used to solve the collisions.</p><p>Note that the table size is better to be prime. If the maximum size given by the user is not prime, you must re-define the table size to be the smallest prime number which is larger than the size given by the user.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains two positive numbers: MSize (≤104) and N (≤MSize) which are the user-defined table size and the number of input numbers, respectively. Then N distinct positive integers are given in the next line. All the numbers in a line are separated by a space.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print the corresponding positions (index starts from 0) of the input numbers in one line. All the numbers in a line are separated by a space, and there must be no extra space at the end of the line. In case it is impossible to insert the number, print “-“ instead.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">10 </span><span class="hljs-number">6</span> <span class="hljs-number">4</span> <span class="hljs-number">15</span><br></code></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">4</span> -<br></code></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-comment">// Hi = (H(key) + di) % m; // i范围[0~m-1]</span><br><span class="hljs-comment">// 当是平方探测法的时候 di是 0^2, +-1^2, +-2^2....</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPrime</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 不要忘记等于号</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i * i &lt;= x; i++) &#123;<br>        <span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> m, n, val;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; m &gt;&gt; n;<br>    <span class="hljs-keyword">while</span> (!isPrime(m)) ++m;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">table</span><span class="hljs-params">(m, <span class="hljs-number">-1</span>)</span></span>; <span class="hljs-comment">// -1表示为空</span><br>    <span class="hljs-keyword">int</span> i, j, key, pos;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; val;<br>        key = val % m;<br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>            pos = (key + j * j) % m;<br>            <span class="hljs-keyword">if</span> (table[pos] == <span class="hljs-number">-1</span>) &#123;<br>                table[pos] = val;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);<br>        <span class="hljs-keyword">if</span> (j == m) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, pos);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;</span><br><span class="hljs-string">&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1145 Hashing - Average Search Time (25 分)</title>
    <link href="/2021/03/10/1145-Hashing-Average-Search-Time-25-%E5%88%86/"/>
    <url>/2021/03/10/1145-Hashing-Average-Search-Time-25-%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1145-Hashing-Average-Search-Time-25-分"><a href="#1145-Hashing-Average-Search-Time-25-分" class="headerlink" title="1145 Hashing - Average Search Time (25 分)"></a>1145 Hashing - Average Search Time (25 分)</h1><p>The task of this problem is simple: insert a sequence of distinct positive integers into a hash table first. Then try to find another sequence of integer keys from the table and output the average search time (the number of comparisons made to find whether or not the key is in the table). The hash function is defined to be H(key)=key%TSize where TSize is the maximum size of the hash table. Quadratic probing (with positive increments only) is used to solve the collisions.</p><p>Note that the table size is better to be prime. If the maximum size given by the user is not prime, you must re-define the table size to be the smallest prime number which is larger than the size given by the user.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains 3 positive numbers: MSize, N, and M, which are the user-defined table size, the number of input numbers, and the number of keys to be found, respectively. All the three numbers are no more than 10<br>4. Then N distinct positive integers are given in the next line, followed by M positive integer keys in the next line. All the numbers in a line are separated by a space and are no more than 105.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, in case it is impossible to insert some number, print in a line X cannot be inserted. where X is the input number. Finally print in a line the average search time for all the M keys, accurate up to 1 decimal place.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">5</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">10 </span><span class="hljs-number">6</span> <span class="hljs-number">4</span> <span class="hljs-number">15</span> <span class="hljs-number">11</span><br><span class="hljs-symbol">11 </span><span class="hljs-number">4</span> <span class="hljs-number">15</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">15 </span>cannot be inserted.<br><span class="hljs-number">2.8</span><br></code></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题考查 <strong>哈希表建立</strong>和<strong>哈希表查询</strong></p><p>哈希表插入公式</p><p>$$<br>H_{i}(k) = (H(k) + d_i) % m \ \ \ (0 &lt;= i &lt;= m - 1)<br>$$</p><ul><li>其中$i$的范围 $[0 \sim m - 1]$.</li><li>$d_{i}$ 是解决冲突的方法，若为平方探测法，则$d_{i}$表示$+1^2, -1^2, +2^2, -2^2, +3^2, -3^2 …$</li></ul><p>伪代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">cin</span> &gt;&gt; key;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>pos = (key + i * i) % m;<br><span class="hljs-keyword">if</span> (table[pos] == <span class="hljs-number">-1</span>) &#123;<br>table[pos] = key;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 若查询到最后没有插入，证明无法插入</span><br><span class="hljs-keyword">if</span> (i == m) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Insert fail</span><br><span class="hljs-string">&quot;</span>);<br></code></pre></td></tr></table></figure><p>接下来是哈希表查询，查询结束有三种情况</p><ul><li>查询到了结果</li><li>查询到的位置没有结果</li><li>最后查询回到了原来位置（重要，最后当$d_{i} = m ^2$的时候，即查询回到了原点，所以查询的时候$i$的范围是$[0 \sim m]$）</li></ul><p>伪代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++">cnt = <span class="hljs-number">0</span>; <span class="hljs-comment">// 查询次数</span><br><span class="hljs-built_in">cin</span> &gt;&gt; key;<br><span class="hljs-comment">// i = m的时候，证明回到了原点位置</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= m; i++) &#123;<br>pos = (key + i * i) % m;<br><span class="hljs-keyword">if</span> (table[pos] == key || table[pos] == <span class="hljs-number">-1</span>) &#123;<br>cnt++;<br><span class="hljs-keyword">break</span>; <span class="hljs-comment">// 查询结束</span><br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">int</span> mSize, n, m, k;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; arr, table;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPrime</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i * i &lt;= x; i++) &#123;<br>        <span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> val, pos;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; mSize &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-comment">// 找到最近的那个素数</span><br>    <span class="hljs-keyword">while</span>(!isPrime(mSize)) mSize++;<br>    arr.resize(n);<br>    table.resize(mSize, <span class="hljs-number">-1</span>);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; val; <span class="hljs-comment">// 开始插入到哈希表中</span><br>        <span class="hljs-keyword">int</span> j;<br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; mSize; j++) &#123;<br>            pos = (val + j * j) % mSize;<br>            <span class="hljs-keyword">if</span> (table[pos] == <span class="hljs-number">-1</span>) &#123;<br>                table[pos] = val;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (j == mSize) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d cannot be inserted.</span><br><span class="hljs-string">&quot;</span>, val);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 查询的个数</span><br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; val;<br>        <span class="hljs-keyword">int</span> j;<br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt;= mSize; j++) &#123; <span class="hljs-comment">// 查询为什么是等于？因为=mSize就证明查到了自己，若查到了自己，还是没有找到结果</span><br>            cnt++;<br>            pos = (val + j * j) % mSize;<br>            <span class="hljs-keyword">if</span> (table[pos] == val || table[pos] == <span class="hljs-number">-1</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.1lf</span><br><span class="hljs-string">&quot;</span>, <span class="hljs-number">1.0</span> * cnt / m);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><ul><li><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805389634158592">1078 Hashing (25 分)</a></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/liuchuo/article/details/79819316">评论区</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基本排序算法实现（归并、快排、选择、插入）</title>
    <link href="/2021/03/10/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%EF%BC%88%E5%BD%92%E5%B9%B6%E3%80%81%E5%BF%AB%E6%8E%92%E3%80%81%E9%80%89%E6%8B%A9%E3%80%81%E6%8F%92%E5%85%A5%EF%BC%89/"/>
    <url>/2021/03/10/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%EF%BC%88%E5%BD%92%E5%B9%B6%E3%80%81%E5%BF%AB%E6%8E%92%E3%80%81%E9%80%89%E6%8B%A9%E3%80%81%E6%8F%92%E5%85%A5%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="排序专题"><a href="#排序专题" class="headerlink" title="排序专题"></a>排序专题</h1><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><p>2路归并排序是将当前区间 <strong>[left, right]</strong>(闭区间)分成两半，对两个区间分别递归进行归并排序</p><p><code>merge</code>函数将两个有序的子区间进行合并</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">1000</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> A[], <span class="hljs-keyword">int</span> l1, <span class="hljs-keyword">int</span> r1, <span class="hljs-keyword">int</span> l2, <span class="hljs-keyword">int</span> r2)</span> </span>&#123;<br><span class="hljs-keyword">int</span> i = l1, j = l2;<br><span class="hljs-keyword">int</span> temp[MAX], idx = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (i &lt;= l1 &amp;&amp; j &lt;= l2) &#123;<br><span class="hljs-keyword">if</span> (A[i] &lt; A[j]) &#123;<br>temp[idx++] = A[i];<br>i++;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>temp[idx++] = A[j];<br>j++;<br>&#125;<br>&#125;<br><span class="hljs-keyword">while</span> (i &lt;= l1) temp[idx++] = A[i++];<br><span class="hljs-keyword">while</span> (j &lt;= l2) temp[idx++] = A[j++];<br><span class="hljs-comment">// 还原回去</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; idx; i++)<br>&#123;<br>A[l1 + i] = temp[i];<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> A[], <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (left &lt; right) &#123;<br><span class="hljs-keyword">int</span> mid = (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 先归并在排序</span><br>mergeSort(A, left, mid);<br>mergeSort(A, mid + <span class="hljs-number">1</span>, right);<br>merge(A, left, mid, mid + <span class="hljs-number">1</span>, right);<br><span class="hljs-comment">// 在PAT考试中，如果没有要求，可以直接使用</span><br><span class="hljs-comment">// sort(A + left, A + right + 1);</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="非递归版本实现"><a href="#非递归版本实现" class="headerlink" title="非递归版本实现"></a>非递归版本实现</h3><p><code>merge</code>函数还是一样的，用来 <strong>合并有序子区间</strong>。所以需要更改的是<code>mergeSort</code>函数，归并排序是一开始2个一组，然后是4个一组，8个一组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">1000</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> A[], <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br><span class="hljs-keyword">int</span> i = left, j = mid + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> temp[MAX], idx = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;<br><span class="hljs-keyword">if</span> (A[i] &lt; A[j]) temp[idx++] = A[i++];<br><span class="hljs-keyword">else</span> temp[idx++] = A[j++];<br>&#125;<br><span class="hljs-keyword">while</span> (i &lt;= mid) temp[idx++] = A[i++];<br><span class="hljs-keyword">while</span> (j &lt;= right) temp[idx++] = A[j++];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; idx; i++) A[left + i] = temp[i];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> A[])</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> size = <span class="hljs-number">1</span>; size &lt; n; size += size) &#123; <span class="hljs-comment">// 子区间的大小</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>; start &lt; n - size; start += size * <span class="hljs-number">2</span>) &#123; <span class="hljs-comment">// 子区间开始索引</span><br><span class="hljs-comment">// 合并两个子区间，两个子区间的大小是 size * 2</span><br><span class="hljs-comment">// 第一个子区间的范围是 [start, start + size - 1]</span><br><span class="hljs-comment">// 第二个子区间的范围是 [start + size, min(start + size * 2 - 1, n  -1)];</span><br><span class="hljs-comment">// 最后一个区间可能大小小于size，所以需要和 n-1进行比较。取最小的那个。</span><br>merge(A, start, start + size - <span class="hljs-number">1</span>, min(start + size * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>));<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>平均时间复杂度 $O(nlogn)$ .</p><p>原理：随机选择待排序序列中的一个数，将小于该数的放在它的右边，大于该数的放在它的左边。</p><p>快速排序的切分</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span> A[], <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> rand = rand() % (right - left + <span class="hljs-number">1</span>) + left;<br>swap(A[left], A[rand]);<br><span class="hljs-keyword">int</span> temp = A[left]; <span class="hljs-comment">// 这一步最好使用随机选择主元的方法</span><br><span class="hljs-keyword">while</span> (left &lt; right) &#123;<br><span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; A[right] &gt; temp) right--;<br>A[left] = A[right];<br><span class="hljs-comment">// 这里需要添加=号</span><br><span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; A[left] &lt;= temp) left++;<br>A[right] = A[left];<br>&#125;<br>A[left] = temp;<br><span class="hljs-keyword">return</span> left; <span class="hljs-comment">// 返回相遇的下标</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> A[], <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (left &lt; right) &#123;<br><span class="hljs-comment">// pos 左边的元素均小于右边的元素</span><br><span class="hljs-comment">// 数组分区，找到基准的位置。</span><br><span class="hljs-keyword">int</span> pos = partition(A, left, right);<br><span class="hljs-comment">// 排序小于基准的分区</span><br>quickSort(A, left, pos - <span class="hljs-number">1</span>);<br><span class="hljs-comment">// 排序大于基准的分区</span><br>quickSort(A, pos + <span class="hljs-number">1</span>, right);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>C++ 实现随机数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;time.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;<br>srand((<span class="hljs-keyword">unsigned</span>)time(<span class="hljs-literal">NULL</span>));<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, rand());<br><span class="hljs-comment">// 生成某个范围内的数字，比如[a, b]</span><br><span class="hljs-keyword">int</span> rand = rand() % (b - a + <span class="hljs-number">1</span>) + a;<br></code></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>原理：从数组第一个元素开始，每次找到最小的一个元素，把它放到前面。</p><p>实现代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">selectSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> A[], <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br><span class="hljs-keyword">int</span> min_idx = i;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br><span class="hljs-keyword">if</span> (A[min_idx] &gt; A[j]) min_idx = j;<br>&#125;<br>swap(A[min_idx], A[i]);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>原理：和上面差不多，但是这个是逐个往前插入。</p><p>代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insertSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> A[], <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br><span class="hljs-keyword">int</span> temp = A[i], j = i;<br>        <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; A[j - <span class="hljs-number">1</span>] &gt; temp) &#123;<br>            A[j] = A[j - <span class="hljs-number">1</span>];<br>            j--;<br>        &#125;<br>A[j] = temp;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="算法验证"><a href="#算法验证" class="headerlink" title="算法验证"></a>算法验证</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;time.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insertSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> A[], <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br><span class="hljs-keyword">int</span> temp = A[i], j = i;<br>        <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; A[j - <span class="hljs-number">1</span>] &gt; temp) &#123;<br>            A[j] = A[j - <span class="hljs-number">1</span>];<br>            j--;<br>        &#125;<br>A[j] = temp;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">selectSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> A[], <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br><span class="hljs-keyword">int</span> min_idx = i;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br><span class="hljs-keyword">if</span> (A[min_idx] &gt; A[j]) min_idx = j;<br>&#125;<br>swap(A[min_idx], A[i]);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> A[], <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, A[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> A[], <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i = left, j = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> temp[<span class="hljs-number">10</span>], idx = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;<br>        <span class="hljs-keyword">if</span> (A[i] &lt; A[j]) temp[idx++] = A[i++];<br>        <span class="hljs-keyword">else</span> temp[idx++] = A[j++];<br>    &#125;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid) temp[idx++] = A[i++];<br>    <span class="hljs-keyword">while</span> (j &lt;= right) temp[idx++] = A[j++];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; idx; i++) A[left + i] = temp[i];<br>&#125;<br><br><span class="hljs-comment">// 使用递归的方法</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> A[], <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>    <span class="hljs-comment">// 如果是等于，就不用排序了。</span><br>    <span class="hljs-keyword">if</span> (left &gt;= right) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">int</span> mid = (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br>    mergeSort(A, left, mid);<br>    mergeSort(A, mid + <span class="hljs-number">1</span>, right);<br>    merge(A, left, mid, right);<br>&#125;<br><br><span class="hljs-comment">// 使用迭代的方法</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> A[], <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> size = <span class="hljs-number">1</span>; size &lt; n; size += size) &#123; <span class="hljs-comment">// 每轮合并规模</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>; start &lt; n - size; start += size * <span class="hljs-number">2</span>) &#123;<br>            merge(A, start, start + size - <span class="hljs-number">1</span>, min(start + size * <span class="hljs-number">2</span> - <span class="hljs-number">1</span> , n - <span class="hljs-number">1</span>));<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">parition</span><span class="hljs-params">(<span class="hljs-keyword">int</span> A[], <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> temp = A[left];<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; A[right] &gt; temp) right--;<br>        A[left] = A[right];<br>        <span class="hljs-comment">// 这里需要添加等于号，不然程序遇到相同的会卡死</span><br>        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; A[left] &lt;= temp) left++;<br>        A[right] = A[left];<br>    &#125;<br>    A[left] = temp;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">randomPartition</span><span class="hljs-params">(<span class="hljs-keyword">int</span> A[], <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> r = rand() % (right - left + <span class="hljs-number">1</span>) + left;<br>    swap(A[left], A[r]);<br>    <span class="hljs-keyword">return</span> parition(A, left, right);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> A[], <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (left &gt;= right) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// int pos = parition(A, left, right);</span><br>    <span class="hljs-keyword">int</span> pos = randomPartition(A, left, right); <span class="hljs-comment">// 随机选择一个数做为主元</span><br>    quickSort(A, left, pos - <span class="hljs-number">1</span>);<br>    quickSort(A, pos + <span class="hljs-number">1</span>, right);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    srand((<span class="hljs-keyword">unsigned</span>)time(<span class="hljs-literal">NULL</span>));<br>    <span class="hljs-keyword">int</span> n = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">int</span> A[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">91</span>,<span class="hljs-number">61</span>,<span class="hljs-number">3</span>,<span class="hljs-number">90</span>,<span class="hljs-number">61</span>,<span class="hljs-number">235</span>,<span class="hljs-number">61</span>,<span class="hljs-number">23</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;;<br>    insertSort(A, n);<br>    <span class="hljs-comment">// selectSort(A, n);</span><br>    <span class="hljs-comment">// mergeSort(A, 0, 9); // 使用递归的方法实现归并排序</span><br>    <span class="hljs-comment">// mergeSort2(A, 10); // 使用迭代的方法实现归并排序</span><br>    <span class="hljs-comment">// quickSort(A, 0, 9);</span><br>    print(A, <span class="hljs-number">10</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>leetcode</tag>
      
      <tag>快速排序</tag>
      
      <tag>归并排序</tag>
      
      <tag>插入排序</tag>
      
      <tag>选择排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020年冬季PAT考试</title>
    <link href="/2021/03/09/2020%E5%B9%B4%E5%86%AC%E5%AD%A3PAT%E8%80%83%E8%AF%95/"/>
    <url>/2021/03/09/2020%E5%B9%B4%E5%86%AC%E5%AD%A3PAT%E8%80%83%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="2020年冬季PAT考试"><a href="#2020年冬季PAT考试" class="headerlink" title="2020年冬季PAT考试"></a>2020年冬季PAT考试</h1><h2 id="7-1-The-Closest-Fibonacci-Number-20-分"><a href="#7-1-The-Closest-Fibonacci-Number-20-分" class="headerlink" title="7-1 The Closest Fibonacci Number (20 分)"></a>7-1 The Closest Fibonacci Number (20 分)</h2><p>The Fibonacci sequence F​n​​ is defined by F​n+2​​=F​n+1​​+F​n​​ for n≥0, with F​0​​=0 and F​1​​=1. The closest Fibonacci number is defined as the Fibonacci number with the smallest absolute difference with the given integer N.</p><p>Your job is to find the closest Fibonacci number for any given N.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case, which gives a positive integer N (≤10​8​​).</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each case, print the closest Fibonacci number. If the solution is not unique, output the smallest one.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-number">305</span><br></code></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-number">233</span><br></code></pre></td></tr></table></figure><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint:"></a>Hint:</h3><blockquote><p>Since part of the sequence is { 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, … }, there are two solutions: 233 and 377, both have the smallest distance 72 to 305. The smaller one must be printed out.</p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>本题考查 <strong>斐波拉契数列</strong></p><p>题目很简单，直接看代码吧</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">// 求斐波拉契数列</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">1</span>, temp;<br><br>    <span class="hljs-keyword">while</span> (b &lt; n) &#123;<br>        temp = a + b;<br>        a = b;<br>        b = temp;<br>    &#125;<br>    <span class="hljs-comment">// 判断 a b 和 n 的差值</span><br>    <span class="hljs-keyword">if</span> (n - a &lt;= b - n) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d</span><br><span class="hljs-string">&quot;</span>, a);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d</span><br><span class="hljs-string">&quot;</span>, b);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-2-Subsequence-in-Substring-25-分"><a href="#7-2-Subsequence-in-Substring-25-分" class="headerlink" title="7-2 Subsequence in Substring (25 分)"></a>7-2 Subsequence in Substring (25 分)</h2><p>A substring is a continuous part of a string. A subsequence is the part of a string that might be continuous or not but the order of the elements is maintained. For example, given the string atpaaabpabtt, pabt is a substring, while pat is a subsequence.</p><p>Now given a string S and a subsequence P, you are supposed to find the shortest substring of S that contains P. If such a solution is not unique, output the left most one.</p><h3 id="Input-Specification-1"><a href="#Input-Specification-1" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case which consists of two lines. The first line contains S and the second line P. S is non-empty and consists of no more than 10​4​​ lower English letters. P is guaranteed to be a non-empty subsequence of S.</p><h3 id="Output-Specification-1"><a href="#Output-Specification-1" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each case, print the shortest substring of S that contains P. If such a solution is not unique, output the left most one.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">atpaaabpabttpcat</span><br><span class="hljs-attribute">pat</span><br></code></pre></td></tr></table></figure><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">pabt</span><br></code></pre></td></tr></table></figure><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>本体使用暴力求解，在s1中找到第一个等于s2[0]的位置，然后再开始以该位置为起始位置，在s1中逐个寻找s2的元素，直到全部找完。在若干个解中找到字符串长度最小的。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);</span><br>    <span class="hljs-built_in">string</span> s1, s2;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; s1 &gt;&gt; s2;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j, dis = <span class="hljs-number">987654321</span>, start;<br>    <span class="hljs-keyword">while</span> (i &lt; s1.length() - s2.length()) &#123;<br>        <span class="hljs-keyword">if</span> (s1[i] == s2[<span class="hljs-number">0</span>]) &#123;<br>            j = i;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; s2.length(); k++) &#123;<br>                <span class="hljs-keyword">while</span> (j &lt; s1.length() &amp;&amp; s1[j] != s2[k]) j++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (dis &gt; j - i + <span class="hljs-number">1</span>) &#123;<br>                dis = j - i + <span class="hljs-number">1</span>;<br>                start = i;<br>            &#125;<br>        &#125;<br>        i++;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s</span><br><span class="hljs-string">&quot;</span>, s1.substr(start, dis).c_str());<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-3-File-Path-25-分"><a href="#7-3-File-Path-25-分" class="headerlink" title="7-3 File Path (25 分)"></a>7-3 File Path (25 分)</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/8f0c44f4c64c41ee9c46b0f262e93da3.png" alt="path"> </p><p>The figure shows the tree view of directories in Windows File Explorer. When a file is selected, there is a file path shown in the above navigation bar. Now given a tree view of directories, your job is to print the file path for any selected file.</p><h3 id="Input-Specification-2"><a href="#Input-Specification-2" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line gives a positive integer N (≤10​3​​), which is the total number of directories and files. Then N lines follow, each gives the unique 4-digit ID of a file or a directory, starting from the unique root ID 0000. The format is that the files of depth d will have their IDs indented by d spaces. It is guaranteed that there is no conflict in this tree structure.</p><p>Then a positive integer K (≤100) is given, followed by K queries of IDs.</p><h3 id="Output-Specification-2"><a href="#Output-Specification-2" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each queried ID, print in a line the corresponding path from the root to the file in the format: 0000-&gt;ID1-&gt;ID2-&gt;…-&gt;ID. If the ID is not in the tree, print Error: ID is not found. instead.</p><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-number">14</span><br><span class="hljs-number">0000</span><br> <span class="hljs-number">1234</span><br>  <span class="hljs-number">2234</span><br>   <span class="hljs-number">3234</span><br>    <span class="hljs-number">4234</span><br>    <span class="hljs-number">4235</span><br>    <span class="hljs-number">2333</span><br>   <span class="hljs-number">5234</span><br>   <span class="hljs-number">6234</span><br>    <span class="hljs-number">7234</span><br>     <span class="hljs-number">9999</span><br>  <span class="hljs-number">0001</span><br>   <span class="hljs-number">8234</span><br> <span class="hljs-number">0002</span><br><span class="hljs-number">4</span> <span class="hljs-number">9999</span> <span class="hljs-number">8234</span> <span class="hljs-number">0002</span> <span class="hljs-number">6666</span><br></code></pre></td></tr></table></figure><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-number">0000</span>-&gt;<span class="hljs-number">1234</span>-&gt;<span class="hljs-number">2234</span>-&gt;<span class="hljs-number">6234</span>-&gt;<span class="hljs-number">7234</span>-&gt;<span class="hljs-number">9999</span><br><span class="hljs-number">0000</span>-&gt;<span class="hljs-number">1234</span>-&gt;<span class="hljs-number">0001</span>-&gt;<span class="hljs-number">8234</span><br><span class="hljs-number">0000</span>-&gt;<span class="hljs-number">0002</span><br>Error: <span class="hljs-number">6666</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> found.<br></code></pre></td></tr></table></figure><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>本题设置一个结构体，用于存储当前所在的层级，自己的上一层目录是谁。如何找到上一层目录是谁？有三种情况（设置一个变量<code>pre</code>表示上一次输入的目录, <code>cur</code>表示当前输入的目录）</p><ul><li>若<code>cur</code>和<code>pre</code>的层级一样，那么它们的上一层目录一样。</li><li>若<code>cur</code>和<code>pre</code>的层级关系是<code>FP[cur].level = FP[pre].level + 1</code>，那么<code>cur</code>是<code>pre</code>的子目录。</li><li>若<code>cur</code>和<code>pre</code>的层级关系是<code>FP[cur].level &lt; FP[pre].level</code>，则需要从<code>pre</code>往上找到和<code>cur</code>同一层级的目录，它们的上一层目录一样。</li></ul><p>伪代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (level == FP[pref].level) &#123;<br>FP[f].parent = FP[pref].parent;<br><span class="hljs-comment">// 如果是子目录</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (level == FP[pref].level + <span class="hljs-number">1</span>) &#123;<br>FP[f].parent = pref;<br><span class="hljs-comment">// 不是同级目录，向上找它的父级目录</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">int</span> parent = FP[pref].parent;<br><span class="hljs-keyword">while</span> (FP[parent].level != level) &#123;parent = FP[parent].parent;&#125;<br>FP[f].parent = FP[parent].parent;<br>&#125;<br>pref = f;<br></code></pre></td></tr></table></figure><p>具体实现</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">100000</span>;<br><br><span class="hljs-comment">// 创建一个目录</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">F</span>&#123;</span><br>    <span class="hljs-keyword">int</span> parent, level;<br>    F(): parent(<span class="hljs-number">-1</span>), level(<span class="hljs-number">-1</span>) &#123;&#125;<br>&#125;FP[MAX];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-keyword">int</span>&amp; level, <span class="hljs-keyword">int</span>&amp; filename)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (s[level] == <span class="hljs-string">&#x27; &#x27;</span>) level++;<br>    filename = stoi(s);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-keyword">int</span> f)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (f == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0000&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    DFS(FP[f].parent);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-&gt;%04d&quot;</span>, f);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);</span><br>    <span class="hljs-keyword">int</span> n, pref = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">string</span> s ;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    getchar();<br><br>    <span class="hljs-comment">// 初始化根目录</span><br>    FP[<span class="hljs-number">0</span>].level = <span class="hljs-number">0</span>;<br>    FP[<span class="hljs-number">0</span>].parent = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (n--) &#123;<br>        getline(<span class="hljs-built_in">cin</span>, s);<br>        <span class="hljs-keyword">int</span> level = <span class="hljs-number">0</span>, f;<br>        split(s, level, f);<br>        FP[f].level = level;<br>        <span class="hljs-comment">// 如果目录同级</span><br>        <span class="hljs-keyword">if</span> (level == FP[pref].level) &#123;<br>            FP[f].parent = FP[pref].parent;<br>            <span class="hljs-comment">// 如果是子目录</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (level == FP[pref].level + <span class="hljs-number">1</span>) &#123;<br>            FP[f].parent = pref;<br>            <span class="hljs-comment">// 不是同级目录，向上找它的父级目录</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">int</span> parent = FP[pref].parent;<br>            <span class="hljs-keyword">while</span> (FP[parent].level != level) &#123;parent = FP[parent].parent;&#125;<br>            FP[f].parent = FP[parent].parent;<br>        &#125;<br>        pref = f;<br>    &#125;<br>    <span class="hljs-keyword">int</span> k, f;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; k;<br>    <span class="hljs-keyword">while</span> (k--) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; f;<br>        <span class="hljs-keyword">if</span> (FP[f].level == <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error: %04d is not found.</span><br><span class="hljs-string">&quot;</span>, f);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            DFS(f);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;</span><br><span class="hljs-string">&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-4-Chemical-Equation-30-分"><a href="#7-4-Chemical-Equation-30-分" class="headerlink" title="7-4 Chemical Equation (30 分)"></a>7-4 Chemical Equation (30 分)</h2><p>A chemical equation is the symbolic representation of a chemical reaction in the form of symbols and formulae, wherein the reactant entities are given on the left-hand side and the product entities on the right-hand side. For example, CH​4​​+2O​2​​=CO​2​​+2H​2​​O means that the reactants in this chemical reaction are methane and oxygen: CH​4​​ and O​2​​, and the products of this reaction are carbon dioxide and water: CO​2​​ and H​2​​O.</p><p>Given a set of reactants and products, you are supposed to tell that in which way we can obtain these products, provided that each reactant can be used only once. For the sake of simplicity, we will consider all the entities on the right-hand side of the equation as one single product.</p><h3 id="Input-Specification-3"><a href="#Input-Specification-3" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line gives an integer N (2≤N≤20), followed by N distinct indices of reactants. The second line gives an integer M (1≤M≤10), followed by M distinct indices of products. The index of an entity is a 2-digit number.</p><p>Then a positive integer K (≤50) is given, followed by K lines of equations, in the format:</p><p>reactant_1 + reactant_2 + … + reactant_n -&gt; product<br>where all the reactants are distinct and are in increasing order of their indices.</p><p>Note: It is guaranteed that</p><p>one set of reactants will not produce two or more different products, i.e. situation like 01 + 02 -&gt; 03 and 01 + 02 -&gt; 04 is impossible;<br>a reactant cannot be its product unless it is the only one on the left-hand side, i.e. 01 -&gt; 01 is always true (no matter the equation is given or not), but 01 + 02 -&gt; 01 is impossible; and<br>there are never more than 5 different ways of obtaining a product given in the equations list.</p><h3 id="Output-Specification-3"><a href="#Output-Specification-3" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each case, print the equations that use the given reactants to obtain all the given products. Note that each reactant can be used only once.</p><p>Each equation occupies a line, in the same format as we see in the inputs. The equations must be print in the same order as the products given in the input. For each product in order, if the solution is not unique, always print the one with the smallest sequence of reactants – A sequence { a​1​​,⋯,a​m​​ } is said to be smaller than another sequence { b​1​​,⋯,b​n​​ } if there exists 1≤i≤min(m,n) so that a​j​​=b​j​​ for all j&lt;i, and a​i​​&lt;b​i​​.</p><p>It is guaranteed that at least one solution exists.</p><h3 id="Sample-Input-3"><a href="#Sample-Input-3" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">8 </span><span class="hljs-number">09</span> <span class="hljs-number">05</span> <span class="hljs-number">03</span> <span class="hljs-number">04</span> <span class="hljs-number">02</span> <span class="hljs-number">01</span> <span class="hljs-number">16</span> <span class="hljs-number">10</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">08</span> <span class="hljs-number">03</span> <span class="hljs-number">04</span><br><span class="hljs-number">6</span><br><span class="hljs-symbol">03 </span>+ <span class="hljs-number">09</span> -&gt; <span class="hljs-number">08</span><br><span class="hljs-symbol">02 </span>+ <span class="hljs-number">08</span> -&gt; <span class="hljs-number">04</span><br><span class="hljs-symbol">02 </span>+ <span class="hljs-number">04</span> -&gt; <span class="hljs-number">03</span><br><span class="hljs-symbol">01 </span>+ <span class="hljs-number">05</span> -&gt; <span class="hljs-number">03</span><br><span class="hljs-symbol">01 </span>+ <span class="hljs-number">09</span> + <span class="hljs-number">16</span> -&gt; <span class="hljs-number">03</span><br><span class="hljs-symbol">02 </span>+ <span class="hljs-number">03</span> + <span class="hljs-number">05</span> -&gt; <span class="hljs-number">08</span><br></code></pre></td></tr></table></figure><h3 id="Sample-Output-3"><a href="#Sample-Output-3" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">02 </span>+ <span class="hljs-number">03</span> + <span class="hljs-number">05</span> -&gt; <span class="hljs-number">08</span><br><span class="hljs-symbol">01 </span>+ <span class="hljs-number">09</span> + <span class="hljs-number">16</span> -&gt; <span class="hljs-number">03</span><br><span class="hljs-symbol">04 </span>-&gt; <span class="hljs-number">04</span><br></code></pre></td></tr></table></figure><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><blockquote><p>暂时没有思路</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>2020年秋季PAT考试</title>
    <link href="/2021/03/08/2020%E5%B9%B4%E7%A7%8B%E5%AD%A3PAT%E8%80%83%E8%AF%95/"/>
    <url>/2021/03/08/2020%E5%B9%B4%E7%A7%8B%E5%AD%A3PAT%E8%80%83%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="2020年秋季PAT考试"><a href="#2020年秋季PAT考试" class="headerlink" title="2020年秋季PAT考试"></a>2020年秋季PAT考试</h1><h2 id="7-1-Panda-and-PP-Milk-20分"><a href="#7-1-Panda-and-PP-Milk-20分" class="headerlink" title="7-1 Panda and PP Milk (20分)"></a>7-1 Panda and PP Milk (20分)</h2><p>PP milk （盆盆奶）is Pandas’ favorite. They would line up to enjoy it as show in the picture. On the other hand, they could drink in peace only if they believe that the amount of PP milk is fairly distributed, that is, fatter panda can have more milk, and the ones with equal weight may have the same amount. Since they are lined up, each panda can only compare with its neighbor(s), and if it thinks this is unfair, the panda would fight with its neighbor.</p><p>Given that the minimum amount of milk a panda must drink is 200 ml. It is only when another bowl of milk is at least 100 ml more than its own that a panda can sense the difference.</p><p>Now given the weights of a line of pandas, your job is to help the breeder（饲养员）to decide the minimum total amount of milk that he/she must prepare, provided that the pandas are lined up in the given order.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, first a positive integer n (≤104) is given as the number of pandas. Then in the next line, n positive integers are given as the weights (in kg) of the pandas, each no more than 200. the numbers are separated by spaces.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print in a line the minimum total amount of milk that the breeder must prepare, to make sure that all the pandas can drink in peace.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-number">10</span><br><span class="hljs-number">180</span> <span class="hljs-number">160</span> <span class="hljs-number">100</span> <span class="hljs-number">150</span> <span class="hljs-number">145</span> <span class="hljs-number">142</span> <span class="hljs-number">138</span> <span class="hljs-number">138</span> <span class="hljs-number">138</span> <span class="hljs-number">140</span>`<br></code></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-number">3000</span><br></code></pre></td></tr></table></figure><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint:"></a>Hint:</h3><p>The distribution of milk is the following:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-number">400</span> <span class="hljs-number">300</span> <span class="hljs-number">200</span> <span class="hljs-number">500</span> <span class="hljs-number">400</span> <span class="hljs-number">300</span> <span class="hljs-number">200</span> <span class="hljs-number">200</span> <span class="hljs-number">200</span> <span class="hljs-number">300</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>设置两个数组<code>leftScan, rightScan</code>，一个从左往右扫描，另一个从右往左扫描。两个数组都需要满足下面逻辑。</p><ul><li>默认两个数组的起始位置的牛奶量都是200ml。</li><li>若当前的重量比上一个猫的重量重，则这个猫的牛奶量在上一个猫的基础上+100ml。</li><li>若当前重量和上一个猫的重量一样，则这个猫的牛奶量和上一个猫一样。</li><li>若当前重量比上一个猫的重量小，那这个猫的牛奶量为200ml。</li></ul><p>伪代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; weight;<br><span class="hljs-keyword">int</span> curPanda, prePanda;<br><br><span class="hljs-keyword">if</span> (weight[curPanda] &gt; weight[prePanda]) &#123;<br>weight[curPanda] = weight[prePanda] + <span class="hljs-number">100</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (weight[curPanda] == weight[prePanda]) &#123;<br>weight[curPanda] = weight[prePanda];<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>weight[curPanda] = <span class="hljs-number">200</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后取左右扫描后结果最大的值就是所求答案。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);</span><br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    vector&lt;int&gt; leftScan(n), rightScan(n), weight(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<span class="hljs-built_in">cin</span> &gt;&gt; weight[i];&#125;<br>    <span class="hljs-keyword">int</span> milk = <span class="hljs-number">200</span>;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;<br>    leftScan[left] = rightScan[right] = milk;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (weight[i] &gt; weight[i - <span class="hljs-number">1</span>]) &#123;<br>            milk += <span class="hljs-number">100</span>;<br>            leftScan[i] = milk;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (weight[i] == weight[i - <span class="hljs-number">1</span>]) &#123;<br>            leftScan[i] = milk;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            milk = <span class="hljs-number">200</span>;<br>            leftScan[i] = milk;<br>        &#125;<br>    &#125;<br>    milk = <span class="hljs-number">200</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">if</span> (weight[i + <span class="hljs-number">1</span>] &gt; weight[i]) &#123;<br>            milk = <span class="hljs-number">200</span>;<br>            rightScan[i] = milk;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (weight[i + <span class="hljs-number">1</span>] == weight[i]) &#123;<br>            rightScan[i] = milk;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            milk += <span class="hljs-number">100</span>;<br>            rightScan[i] = milk;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        sum += max(leftScan[i], rightScan[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, sum);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-2-How-Many-Ways-to-Buy-a-Piece-of-Land-25分"><a href="#7-2-How-Many-Ways-to-Buy-a-Piece-of-Land-25分" class="headerlink" title="7-2 How Many Ways to Buy a Piece of Land (25分)"></a>7-2 How Many Ways to Buy a Piece of Land (25分)</h2><p>The land is for sale in CyberCity, and is divided into several pieces. Here it is assumed that each piece of land has exactly two neighboring pieces, except the first and the last that have only one. One can buy several contiguous（连续的） pieces at a time. Now given the list of prices of the land pieces, your job is to tell a customer in how many different ways that he/she can buy with a certain amount of money.</p><h3 id="Input-Specification-1"><a href="#Input-Specification-1" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case first gives in a line two positive integers: N (≤104), the number of pieces of the land (hence the land pieces are numbered from 1 to N in order), and M (≤109), the amount of money that your customer has.</p><p>Then in the next line, N positive integers are given, where the i-th one is the price of the i-th piece of the land.</p><p>It is guaranteed that the total price of the land is no more than 109.</p><h3 id="Output-Specification-1"><a href="#Output-Specification-1" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print the number of different ways that your customer can buy. Notice that the pieces must be contiguous.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">85</span><br><span class="hljs-symbol">38 </span><span class="hljs-number">42</span> <span class="hljs-number">15</span> <span class="hljs-number">24</span> <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-number">11</span><br></code></pre></td></tr></table></figure><h3 id="Hint-1"><a href="#Hint-1" class="headerlink" title="Hint:"></a>Hint:</h3><p>The 11 different ways are:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">38</span><br><span class="hljs-number">42</span><br><span class="hljs-number">15</span><br><span class="hljs-number">24</span><br><span class="hljs-number">9</span><br><span class="hljs-symbol">38 </span><span class="hljs-number">42</span><br><span class="hljs-symbol">42 </span><span class="hljs-number">15</span><br><span class="hljs-symbol">42 </span><span class="hljs-number">15</span> <span class="hljs-number">24</span><br><span class="hljs-symbol">15 </span><span class="hljs-number">24</span><br><span class="hljs-symbol">15 </span><span class="hljs-number">24</span> <span class="hljs-number">9</span><br><span class="hljs-symbol">24 </span><span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>本题考查 <strong>前缀和、二分查找</strong></p><p>题目大意是使用一定的金额购买连续的土地，所以需要求出一定区间内的和，求区间和使用前缀和。</p><p>前缀和中，求<code>sum[i,j] = preSum[j + 1] - [i]</code>.</p><p>题目需要找到区间和满足 <code>sum[i,j] &lt; k;</code> k为给定金额。所以可以使用暴力找到所有满足条件的结果或者是使用二分查找，找到第一个区间和大于k的下标。这里主要讲使用二分查找来实现。</p><p>找出第一个大于x的二分查找模板如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 找到第一个大于的x的值</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">upper_bound</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> mid;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        mid = left + ((right - left) &gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (nums[mid] &gt; x) right = mid;<br>        <span class="hljs-keyword">else</span> left = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来考虑应该传递什么值到<code>upper_bound</code>中呢？</p><p>这里主要考虑下面两个问题</p><ul><li>left,right范围？</li><li>x应该是什么？</li></ul><ol><li>left,right范围？</li></ol><p>首先明白二分法的一个概念，查找第一个大于x的值的位置，那么这个值的位置的范围区间是在一个左闭右开区间(假设数组中最后一个值的nums[n - 1], 但是x的值比最后一个值还大，那么x所在的位置肯定是在第n个位置)。本题中需要在前缀和中找到第一个大于x的值，传递到<code>upper_bound</code>中的区间范围应该是[0, n + 1). （preSum的范围是[0, n]）.</p><ol start="2"><li>x应该是什么？</li></ol><p>在这道题目中，需要找到区间内的和小于k，所以传递的参数应该是<code>preSum[i] + k</code>.</p><p>得到的和结果是 <code>preSum[j] - preSum[i]</code></p><p>但是前面提到过<code>sum[i, j] = preSum[j + 1] - preSum[i];</code></p><p>所以最终j的真实区间是<code>[i, j - 1]</code>. 即<code>sum[i, j - 1] = preSum[j] - preSum[i] &gt; k</code></p><p>所以<code>upper_bound</code>中传递的值应该如下所示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 使用二分法的话需要-1</span><br><span class="hljs-keyword">int</span> j = upper_bound(preSum, i + <span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>, preSum[i] + k) - <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>最后累加所有满足条件的结果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">ans += (j - i);<br></code></pre></td></tr></table></figure><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">int</span> n, m;<br><br><span class="hljs-comment">// 找到第一个大于的x的值</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">upper_bound</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> mid;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        mid = left + ((right - left) &gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (nums[mid] &gt; x) right = mid;<br>        <span class="hljs-keyword">else</span> left = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);</span><br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">int</span> piece;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">preSum</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; piece;<br>        preSum[i + <span class="hljs-number">1</span>] = preSum[i] + piece;<br>    &#125;<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>, j;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-comment">// 思考一下这里为什么-1</span><br>        <span class="hljs-comment">// sum[i,j] = preSum[j + 1] - preSum[i];</span><br>        <span class="hljs-comment">// 假如[38, 42, 15]三个值的和是95, 他的范围是 sum[0,3] = preSum[4] - preSum[0];</span><br>        <span class="hljs-comment">// 返回的j的其实存在一个j+1的过程，所以需要-1，这样就是sum[i,j]和了。</span><br>        <span class="hljs-comment">// 二分法是左闭右开区间，preSum的区间在[0,n],二分法区间则在[0, n+1)</span><br>        j = upper_bound(preSum, i + <span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>, preSum[i] + m) - <span class="hljs-number">1</span>;<br><span class="hljs-comment">/*         j = i;</span><br><span class="hljs-comment">        while (j &lt; n &amp;&amp; preSum[j + 1] - preSum[i] &lt; m) j++; */</span><br>        <span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; j &lt;&lt; <span class="hljs-built_in">endl</span>;<br>        ans += (j - i);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-3-Left-View-of-Binary-Tree-25分"><a href="#7-3-Left-View-of-Binary-Tree-25分" class="headerlink" title="7-3 Left-View of Binary Tree (25分)"></a>7-3 Left-View of Binary Tree (25分)</h2><p>The <strong>left-view</strong> of a binary tree is a list of nodes obtained by looking at the tree from left hand side and from top down. For example, given a tree shown by the figure, its left-view is { 1, 2, 3, 4, 5 }</p><p><img src="https://segmentfault.com/img/remote/1460000038392724" alt="fig.JPG"></p><p>Given the inorder and preorder traversal sequences of a binary tree, you are supposed to output its left-view.</p><h3 id="Input-Specification-2"><a href="#Input-Specification-2" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains a positive integer N (≤20), which is the total number of nodes in the tree. Then given in the following 2 lines are the inorder and preorder traversal sequences of the tree, respectively. All the keys in the tree are distinct positive integers in the range of <strong>int</strong>.</p><h3 id="Output-Specification-2"><a href="#Output-Specification-2" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each case, print in a line the left-view of the tree. All the numbers in a line are separated by exactly 1 space, and there must be no extra space at the beginning or the end of the line.</p><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">6</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>&#123;</span><br>    <span class="hljs-keyword">int</span> val;<br>    TreeNode *left, *right;<br>    TreeNode(<span class="hljs-keyword">int</span> _val): val(_val), left(<span class="hljs-literal">nullptr</span>), right(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">int</span> n;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; preorder, inorder;<br><br><span class="hljs-function">TreeNode* <span class="hljs-title">create</span><span class="hljs-params">(<span class="hljs-keyword">int</span> preL, <span class="hljs-keyword">int</span> preR, <span class="hljs-keyword">int</span> inL, <span class="hljs-keyword">int</span> inR)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (preL &gt; preR) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    TreeNode* root = <span class="hljs-keyword">new</span> TreeNode(preorder[preL]);<br>    <span class="hljs-keyword">int</span> mid;<br>    <span class="hljs-keyword">for</span> (mid = inL; mid &lt;= inR; mid++) &#123;<br>        <span class="hljs-keyword">if</span> (preorder[preL] == inorder[mid]) <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> num = mid - inL;<br>    root-&gt;left = create(preL + <span class="hljs-number">1</span>, preL + num, inL, mid - <span class="hljs-number">1</span>);<br>    root-&gt;right = create(preL + num + <span class="hljs-number">1</span>, preR, mid + <span class="hljs-number">1</span>, inR);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-built_in">queue</span>&lt;TreeNode*&gt; q;<br>    q.push(root);<br>    TreeNode* node;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans;<br>    <span class="hljs-keyword">while</span> (!q.empty()) &#123;<br>        <span class="hljs-keyword">int</span> size = q.size();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            node = q.front();<br>            q.pop();<br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) ans.push_back(node-&gt;val);<br>            <span class="hljs-keyword">if</span> (node-&gt;left) q.push(node-&gt;left);<br>            <span class="hljs-keyword">if</span> (node-&gt;right) q.push(node-&gt;right);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ans.size(); i++) &#123;<br>        <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ans[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);</span><br>    <span class="hljs-built_in">cin</span> &gt;&gt; n ;<br>    preorder.resize(n);<br>    inorder.resize(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) <span class="hljs-built_in">cin</span> &gt;&gt; inorder[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) <span class="hljs-built_in">cin</span> &gt;&gt; preorder[i];<br>    TreeNode* root = create(<span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    bfs(root);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-4-Professional-Ability-Test-30分"><a href="#7-4-Professional-Ability-Test-30分" class="headerlink" title="7-4 Professional Ability Test (30分)"></a>7-4 Professional Ability Test (30分)</h2><p>Professional Ability Test (PAT) consists of several series of subject tests. Each test is divided into several levels. Level A is a <strong>prerequisite (前置要求)</strong> of Level B if one must pass Level A with a score no less than S in order to be qualified to take Level B. At the mean time, one who passes Level A with a score no less than S will receive a voucher（代金券）of D yuans (Chinese dollar) for taking Level B.</p><p>At the moment, this PAT is only in design and hence people would make up different plans. A plan is <strong>NOT</strong> consistent if there exists some test T so that T is a prerequisite of itself. Your job is to test each plan and tell if it is a consistent one, and at the mean time, find the easiest way (with minimum total S) to obtain the certificate of any subject test. If the easiest way is not unique, find the one that one can win the maximum total value of vouchers.</p><h3 id="Input-Specification-3"><a href="#Input-Specification-3" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line gives two positive integers N (≤1000) and M, being the total numbers of tests and prerequisite relations, respectively. Then M lines follow, each describes a prerequisite relation in the following format:</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-built_in">T1</span> <span class="hljs-built_in">T2</span> S D<br></code></pre></td></tr></table></figure><p>where <code>T1</code> and <code>T2</code> are the indices (from 0 to N−1) of the two distinct tests; <code>S</code> is the minimum score (in the range (0, 100]) required to pass <code>T1</code> in order to be qualified to take <code>T2</code>; and <code>D</code> is the value of the voucher (in the range (0, 500]) one can receive if one passes <code>T1</code> with a score no less than <code>S</code> and plan to take <code>T2</code>. It is guaranteed that at most one pair of <code>S</code> and <code>D</code> are defined for a prerequisite relation.</p><p>Then another positive integer K (≤N) is given, followed by K queries of tests. All the numbers in a line are separated by spaces.</p><h3 id="Output-Specification-3"><a href="#Output-Specification-3" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>Print in the first line <code>Okay.</code> if the whole plan is consistent, or <code>Impossible.</code> if not.</p><p>If the plan is consistent, for each query of test <code>T</code>, print in a line the easiest way to obtain the certificate of this test, in the format:</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">T0-&gt;T1-&gt;...-&gt;T<br></code></pre></td></tr></table></figure><p>However, if <code>T</code> is the first level of some subject test (with no prerequisite), print <code>You may take test T directly.</code> instead.</p><p>If the plan is impossible, for each query of test <code>T</code>, check if one can take it directly or not. If the answer is yes, print in a line <code>You may take test T directly.</code>; or print <code>Error.</code> instead.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">8 </span><span class="hljs-number">15</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">50</span> <span class="hljs-number">50</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">20</span> <span class="hljs-number">20</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span> <span class="hljs-number">90</span> <span class="hljs-number">90</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">7</span> <span class="hljs-number">90</span> <span class="hljs-number">80</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">5</span> <span class="hljs-number">20</span> <span class="hljs-number">20</span><br><span class="hljs-symbol">7 </span><span class="hljs-number">5</span> <span class="hljs-number">10</span> <span class="hljs-number">10</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">6</span> <span class="hljs-number">10</span> <span class="hljs-number">10</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">4</span> <span class="hljs-number">80</span> <span class="hljs-number">60</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">1</span> <span class="hljs-number">50</span> <span class="hljs-number">45</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">4</span> <span class="hljs-number">30</span> <span class="hljs-number">20</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">5</span> <span class="hljs-number">50</span> <span class="hljs-number">20</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span> <span class="hljs-number">10</span> <span class="hljs-number">10</span><br><span class="hljs-symbol">7 </span><span class="hljs-number">2</span> <span class="hljs-number">10</span> <span class="hljs-number">30</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">5</span> <span class="hljs-number">30</span> <span class="hljs-number">20</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">6</span> <span class="hljs-number">40</span> <span class="hljs-number">60</span><br><span class="hljs-number">8</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">Okay.<br>You may take test <span class="hljs-number">0</span> directly.<br><span class="hljs-number">0</span>-&gt;<span class="hljs-number">1</span><br><span class="hljs-number">0</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span><br>You may take test <span class="hljs-number">3</span> directly.<br><span class="hljs-number">0</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">4</span><br><span class="hljs-number">0</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span><br><span class="hljs-number">0</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">6</span><br><span class="hljs-number">3</span>-&gt;<span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">10</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">10</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">0</span> <span class="hljs-number">4</span> <span class="hljs-number">10</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">10</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">0</span> <span class="hljs-number">3</span> <span class="hljs-number">10</span><br><span class="hljs-number">2</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs erlang">Impossible.<br>You may take test <span class="hljs-number">3</span> directly.<br>Error.<br></code></pre></td></tr></table></figure><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>本题考查 <strong>拓扑排序、有向图、最短路径</strong></p><p>本题题目需要判断该有向图是否连通，使用拓扑排序判断(判断连通这一块比较难想到，因为题目说的是存在一致性，和有向图是否连通判断可能有点难联系)</p><p>接下来就是判断以入度为0的点作为起点，然后到达各个点的最短距离。如果把每个入度为0的点都求一次最短路径，可能部分用例会超时，这里参考<a href="https://segmentfault.com/a/1190000038393142">7-4 Professional Ability Test (30分)</a>做法。</p><p>使用一个虚拟头结点，将虚拟头结点指向入度为0的点，本题中，所有的点的范围在<code>[0~n-1]</code>。所以将<code>n</code>的位置设置为虚拟头结点。只需要求一遍最短路径即可。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">987654321</span>;<br><br><span class="hljs-keyword">int</span> n, m;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; &gt; &gt; score, dollar;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; parent;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isTopo</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; inDegree)</span> </span>&#123;<br>    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q;<br>    <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (inDegree[i] == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 设置一个虚拟结点指向所以的入度为0的结点</span><br>            score[n].push_back(<span class="hljs-built_in">make_pair</span>(i, <span class="hljs-number">0</span>));<br>            dollar[n].push_back(<span class="hljs-built_in">make_pair</span>(i, <span class="hljs-number">0</span>));<br>            q.push(i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">int</span> u;<br>    <span class="hljs-keyword">while</span>(!q.empty()) &#123;<br>        u = q.front();<br>        q.pop();<br>        num++;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; score[u].size(); ++i) &#123;<br>            <span class="hljs-keyword">int</span> v = score[u][i].first;<br>            <span class="hljs-keyword">if</span> (--inDegree[v] == <span class="hljs-number">0</span>) q.push(v);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> num == n;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span> </span>&#123;<br>    vector&lt;int&gt; dis(n + 1, MAX), voucher(n + 1, 0), visited(n + 1, 0);<br>    dis[s] = voucher[s] = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">priority_queue</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; &gt;, greater&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; &gt; &gt; pq;<br>    pq.push(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">0</span>, s));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i; i &lt; n + <span class="hljs-number">1</span>; ++i) parent[i] = i;<br>    <span class="hljs-keyword">while</span> (!pq.empty()) &#123;<br>        <span class="hljs-keyword">int</span> u = pq.top().second;<br>        pq.pop();<br>        <span class="hljs-keyword">if</span> (visited[u]) <span class="hljs-keyword">continue</span>;<br>        visited[u] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; score[u].size(); ++i) &#123;<br>            <span class="hljs-keyword">int</span> v = score[u][i].first, cost = score[u][i].second;<br>            <span class="hljs-keyword">if</span> (!visited[v]) &#123;<br>                <span class="hljs-keyword">if</span> (dis[u] + cost &lt; dis[v]) &#123;<br>                    dis[v] = dis[u] + cost;<br>                    voucher[v] = voucher[u] + dollar[u][i].second;<br>                    parent[v] = u;<br>                    pq.push(<span class="hljs-built_in">make_pair</span>(dis[v], v));<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dis[u] + cost == dis[v] &amp;&amp; voucher[u] + dollar[u][i].second &gt; voucher[v]) &#123;<br>                    voucher[v] = voucher[u] + dollar[u][i].second;<br>                    parent[v] = u;<br>                    pq.push(<span class="hljs-built_in">make_pair</span>(dis[v], v));<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (s == n) <span class="hljs-keyword">return</span>;<br>    dfs(parent[s]);<br>    <span class="hljs-keyword">if</span> (parent[s] != n) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-&gt;&quot;</span>); <span class="hljs-comment">// 上一个结点是起点，就不用打印箭头</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, s);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);</span><br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">int</span> t1, t2 ,s, d;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">inDegree</span><span class="hljs-params">(n)</span></span>;<br>    score.resize(n + <span class="hljs-number">1</span>);<br>    dollar.resize(n + <span class="hljs-number">1</span>);<br>    parent.resize(n + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; t1 &gt;&gt; t2 &gt;&gt; s &gt;&gt; d;<br>        score[t1].push_back(<span class="hljs-built_in">make_pair</span>(t2, s));<br>        dollar[t1].push_back(<span class="hljs-built_in">make_pair</span>(t2,d));<br>        inDegree[t2]++;<br>    &#125;<br>    <span class="hljs-keyword">bool</span> isConsistent = isTopo(inDegree);<br>    <span class="hljs-keyword">int</span> k;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; k;<br>    <span class="hljs-keyword">if</span> (!isConsistent) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Impossible.\n&quot;</span>);<br>        <span class="hljs-keyword">while</span> (k--) &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; t1;<br>            <span class="hljs-keyword">if</span> (inDegree[t1] == <span class="hljs-number">0</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;You may take test %d directly.\n&quot;</span>, t1);<br>            <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error.\n&quot;</span>);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Okay.\n&quot;</span>);<br>        Dijkstra(n);<br>        <span class="hljs-keyword">while</span> (k--) &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; t1;<br>            <span class="hljs-keyword">if</span> (inDegree[t1] == <span class="hljs-number">0</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;You may take test %d directly.\n&quot;</span>, t1);<br>            <span class="hljs-keyword">else</span> &#123;<br>                dfs(t1);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://segmentfault.com/a/1190000038393041">7-1 Panda and PP Milk (20分)</a></li><li><a href="https://segmentfault.com/a/1190000038393067">7-2 How Many Ways to Buy a Piece of Land (25分)</a></li><li><a href="https://segmentfault.com/a/1190000038392721">7-3 Left-View of Binary Tree (25分)</a></li><li><a href="https://segmentfault.com/a/1190000038393142">7-4 Professional Ability Test (30分)</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>数学</tag>
      
      <tag>Dijkstra</tag>
      
      <tag>最短路径</tag>
      
      <tag>拓扑排序</tag>
      
      <tag>前缀和</tag>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020年春季PAT考试</title>
    <link href="/2021/03/06/2020%E5%B9%B4%E6%98%A5%E5%AD%A3PAT%E8%80%83%E8%AF%95/"/>
    <url>/2021/03/06/2020%E5%B9%B4%E6%98%A5%E5%AD%A3PAT%E8%80%83%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="2020年春季PAT考试"><a href="#2020年春季PAT考试" class="headerlink" title="2020年春季PAT考试"></a>2020年春季PAT考试</h1><h2 id="7-1-Prime-Day-20分"><a href="#7-1-Prime-Day-20分" class="headerlink" title="7-1 Prime Day (20分)"></a>7-1 Prime Day (20分)</h2><p>The above picture is from Sina Weibo, showing May 23rd, 2019 as a very cool “Prime Day”. That is, not only that the corresponding number of the date <code>20190523</code> is a prime, but all its sub-strings ended at the last digit <code>3</code> are prime numbers.</p><p>Now your job is to tell if a given date is a Prime Day.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, a date between January 1st, 0001 and December 31st, 9999 is given, in the format <code>yyyymmdd</code>.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each given date, output in the decreasing order of the length of the substrings, each occupies a line. In each line, print the string first, followed by a space, then <code>Yes</code> if it is a prime number, or <code>No</code> if not. If this date is a Prime Day, print in the last line <code>All Prime!</code>.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-number">20190523</span><br></code></pre></td></tr></table></figure><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">20190523</span> <span class="hljs-literal">Yes</span><br><span class="hljs-number">0190523</span> <span class="hljs-literal">Yes</span><br><span class="hljs-number">190523</span> <span class="hljs-literal">Yes</span><br><span class="hljs-number">90523</span> <span class="hljs-literal">Yes</span><br><span class="hljs-number">0523 </span><span class="hljs-literal">Yes</span><br><span class="hljs-number">523</span> <span class="hljs-literal">Yes</span><br><span class="hljs-number">23</span> <span class="hljs-literal">Yes</span><br><span class="hljs-number">3</span> <span class="hljs-literal">Yes</span><br><span class="hljs-string">All</span> <span class="hljs-string">Prime!</span><br></code></pre></td></tr></table></figure><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-number">20191231</span><br></code></pre></td></tr></table></figure><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">20191231 </span>Yes<br><span class="hljs-symbol">0191231 </span>Yes<br><span class="hljs-symbol">191231 </span>Yes<br><span class="hljs-symbol">91231 </span>No<br><span class="hljs-symbol">1231 </span>Yes<br><span class="hljs-symbol">231 </span>No<br><span class="hljs-symbol">31 </span>Yes<br><span class="hljs-symbol">1 </span>No<br></code></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>本题考查 <strong>判断素数</strong>和<strong>字符串分割</strong></p><blockquote><p>求<strong>素数</strong>不要忘记是**&lt;=**</p></blockquote><h3 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">// 本题考查 素数判断、字符串提取</span><br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPrime</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 不要忘记等于号</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= (<span class="hljs-keyword">int</span>)<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">1.0</span> * x); i++) &#123;<br>        <span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">string</span> s, temp;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; s;<br>    <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.size(); i++) &#123;<br>        temp = s.substr(i);<br>        <span class="hljs-keyword">if</span> (isPrime(stoi(temp))) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s Yes\n&quot;</span>, temp.c_str());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            flag = <span class="hljs-literal">false</span>;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s No\n&quot;</span>, temp.c_str());<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (flag)<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;All Prime!&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-2-The-Judger-25分"><a href="#7-2-The-Judger-25分" class="headerlink" title="7-2 The Judger (25分)"></a>7-2 The Judger (25分)</h2><p>A game of numbers has the following rules: at the beginning, two distinct positive integers are given by the judge. Then each player in turn must give a number to the judge. The number must be the difference of two numbers that are previously given, and must not be duplicated to any of the existed numbers. The game will run for several rounds. The one who gives a duplicate number or even a wrong number will be kicked out.</p><p>Your job is to write a judger program to judge the players’ numbers and to determine the final winners.</p><h3 id="Input-Specification-1"><a href="#Input-Specification-1" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line gives two distinct positive integers to begin with. Both numbers are in [1,10^5][1,105].</p><p>In the second line, two numbers are given: N (2≤N≤10), the number of players, and M (2≤M≤10^3)<em>M</em>(2≤<em>M</em>≤103), the number of rounds.</p><p>Then N lines follow, each contains M positive integers. The i-th line corresponds to the i-th player (i=1,⋯,N). The game is to start from the 1st player giving his/her 1st number, followed by everybody else giving their 1st numbers in the 1st round; then everyone give their 2nd numbers in the 2nd round, and so on so forth.</p><h3 id="Output-Specification-1"><a href="#Output-Specification-1" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>If the <code>i</code>-th player is kicked out in the <code>k</code>-th round, print in a line <code>Round #k: i is out.</code>. The rest of the numbers given by the one who is out of the game will be ignored. If more than one player is out in the same round, print them in increasing order of their indices. When the game is over, print in the last line <code>Winner(s): W1 W2 ... Wn</code>, where <code>W1 ... Wn</code> are the indices of the winners in increasing order. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the beginning or the end of the line. If there is no winner, print <code>No winner.</code> instead.</p><h3 id="Sample-Input-1-1"><a href="#Sample-Input-1-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">101 </span><span class="hljs-number">42</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">59 </span><span class="hljs-number">34</span> <span class="hljs-number">67</span> <span class="hljs-number">9</span> <span class="hljs-number">7</span><br><span class="hljs-symbol">17 </span><span class="hljs-number">9</span> <span class="hljs-number">8</span> <span class="hljs-number">50</span> <span class="hljs-number">7</span><br><span class="hljs-symbol">25 </span><span class="hljs-number">92</span> <span class="hljs-number">43</span> <span class="hljs-number">26</span> <span class="hljs-number">37</span><br><span class="hljs-symbol">76 </span><span class="hljs-number">51</span> <span class="hljs-number">1</span> <span class="hljs-number">41</span> <span class="hljs-number">40</span><br></code></pre></td></tr></table></figure><h3 id="Sample-Output-1-1"><a href="#Sample-Output-1-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">Round #<span class="hljs-number">4</span>: <span class="hljs-number">1</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">out</span>.<br>Round #<span class="hljs-number">5</span>: <span class="hljs-number">3</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">out</span>.<br>Winner(s): <span class="hljs-number">2</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h3 id="Sample-Input-2-1"><a href="#Sample-Input-2-1" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">42 </span><span class="hljs-number">101</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">59 </span><span class="hljs-number">34</span> <span class="hljs-number">67</span> <span class="hljs-number">9</span> <span class="hljs-number">7</span><br><span class="hljs-symbol">17 </span><span class="hljs-number">9</span> <span class="hljs-number">18</span> <span class="hljs-number">50</span> <span class="hljs-number">49</span><br><span class="hljs-symbol">25 </span><span class="hljs-number">92</span> <span class="hljs-number">58</span> <span class="hljs-number">1</span> <span class="hljs-number">39</span><br><span class="hljs-symbol">102 </span><span class="hljs-number">32</span> <span class="hljs-number">2</span> <span class="hljs-number">6</span> <span class="hljs-number">41</span><br></code></pre></td></tr></table></figure><h3 id="Sample-Output-2-1"><a href="#Sample-Output-2-1" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">Round #<span class="hljs-number">1</span>: <span class="hljs-number">4</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">out</span>.<br>Round #<span class="hljs-number">3</span>: <span class="hljs-number">2</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">out</span>.<br>Round #<span class="hljs-number">4</span>: <span class="hljs-number">1</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">out</span>.<br>Round #<span class="hljs-number">5</span>: <span class="hljs-number">3</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">out</span>.<br>No winner.<br></code></pre></td></tr></table></figure><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>本题考查 <strong>set</strong>的应用。题目比较难理解，大致意思是：每个人给出的数字必须是之前出现过的任意两数字的<strong>差值（difference）</strong>且非之前已经出现过的数字。因此设置两个<code>unordered_set&lt;int&gt; diff, nums</code>分别存储已经出现过的任意两数字差值和已经出现过的数字。每轮每个人给出新的数字后，都需要更新<code>diff,nums</code>。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_set&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">// 本题考查 set</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, m, n1, n2;<br>    <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">int</span>&gt; diff, nums; <span class="hljs-comment">// 存储差值和给出的数字</span><br>    <span class="hljs-built_in">cin</span> &gt;&gt; n1 &gt;&gt; n2;<br>    nums.insert(n1);<br>    nums.insert(n2);<br>    diff.insert(<span class="hljs-built_in">abs</span>(n1 - n2));<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &gt; <span class="hljs-title">arr</span><span class="hljs-params">(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(m))</span></span>;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">isWin</span><span class="hljs-params">(n, <span class="hljs-literal">true</span>)</span></span>; <span class="hljs-comment">// 一开始谁都是赢家</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; arr[i][j];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> loser = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (!isWin[i]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">int</span> val = arr[i][j];<br>            <span class="hljs-comment">// 不是差值或者存在重复就淘汰</span><br>            <span class="hljs-keyword">if</span> (diff.count(val) == <span class="hljs-number">0</span> || nums.count(val) == <span class="hljs-number">1</span>) &#123;<br>                isWin[i] = <span class="hljs-literal">false</span>;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Round #%d: %d is out.\n&quot;</span>, j + <span class="hljs-number">1</span>, i + <span class="hljs-number">1</span>);<br>                loser++;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">// 最后剩下的就是满足条件的</span><br>            <span class="hljs-comment">// nums.insert(val);</span><br>            <span class="hljs-comment">// 更新差值</span><br><span class="hljs-comment">/*             for (auto it: nums) &#123;</span><br><span class="hljs-comment">                diff.insert(abs(val - it));</span><br><span class="hljs-comment">            &#125; */</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator it = nums.begin(); it != nums.end(); ++it) &#123;<br>                diff.insert(<span class="hljs-built_in">abs</span>(*it - val));<br>            &#125;<br>            nums.insert(val);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (loser == n) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No winner.\n&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Winners(s):&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (isWin[i]) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d&quot;</span>, i + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-3-Safari-Park-25分"><a href="#7-3-Safari-Park-25分" class="headerlink" title="7-3 Safari Park (25分)"></a>7-3 Safari Park (25分)</h2><p>A safari park（野生动物园）has K species of animals, and is divided into N regions. The managers hope to spread the animals to all the regions, but not the same animals in the two neighboring regions. Of course, they also realize that this is an NP complete problem, you are not expected to solve it. Instead, they have designed several distribution plans. Your job is to write a program to help them tell if a plan is feasible.</p><h3 id="Input-Specification-2"><a href="#Input-Specification-2" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line gives 3 integers: N (0&lt;N≤500), the number of regions; R (≥0), the number of neighboring relations, and K (0&lt;K≤N), the number of species of animals. The regions and the species are both indexed from 1 to N.</p><p>Then R lines follow, each gives the indices of a pair of neighboring regions, separated by a space.</p><p>Finally there is a positive M (≤20) followed by M lines of distribution plans. Each plan gives N indices of species in a line (the i-th index is the animal in the i-th rigion), separated by spaces. It is guaranteed that any pair of neighboring regions must be different, and there is no duplicated neighboring relations.</p><h3 id="Output-Specification-2"><a href="#Output-Specification-2" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each plan, print in a line <code>Yes</code> if no animals in the two neighboring regions are the same, or <code>No</code> otherwise. However, if the number of species given in a plan is not K, you must print <code>Error: Too many species.</code> or <code>Error: Too few species.</code> according to the case.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">6 </span><span class="hljs-number">8</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">6</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">6</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">6</span><br><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">6</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs subunit">Yes<br><span class="hljs-keyword">Error: </span>Too many species.<br>Yes<br>No<br><span class="hljs-keyword">Error: </span>Too few species.<br></code></pre></td></tr></table></figure><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>本题考查 <strong>邻接表</strong>。</p><p>题目也不难，就是建立一个邻接表，然后根据根据给出的序列安排位置。若相邻的边坐着同一种类的动物，就输出<code>false</code>.</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_set&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">// 本题考查 图，判断两个顶点不能一样</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, r, k, m;<br>    <span class="hljs-keyword">int</span> s1, s2;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; r &gt;&gt; k;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &gt; <span class="hljs-title">adj</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">// 邻接关系</span><br>    <span class="hljs-comment">// r条边</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; r; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; s1 &gt;&gt; s2;<br>        adj[s1].push_back(s2);<br>        adj[s2].push_back(s1);<br>    &#125;<br><br>    <span class="hljs-built_in">cin</span> &gt;&gt; m;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">neg</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-keyword">bool</span> flag; <span class="hljs-comment">// 判断是否满足条件</span><br>    <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">int</span>&gt; spec; <span class="hljs-comment">//动物种类</span><br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        fill(neg.begin(), neg.end(), <span class="hljs-number">0</span>); <span class="hljs-comment">// 默认没有邻居</span><br>        flag = <span class="hljs-literal">true</span>;<br>        spec.clear();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; s1;<br>            <span class="hljs-comment">// if (!flag) continue;</span><br>            neg[i] = s1;<br>            spec.insert(s1);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; adj[i].size(); j++) &#123;<br>                s2 = adj[i][j];<br>                <span class="hljs-comment">// 判断他的邻居</span><br>                <span class="hljs-keyword">if</span> (neg[s2] == s1) flag = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (spec.size() == k) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, flag ? <span class="hljs-string">&quot;Yes&quot;</span> : <span class="hljs-string">&quot;No&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(spec.size() &gt; k) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error: Too many species.\n&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error: Too few species.\n&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-4-Replacement-Selection-30分"><a href="#7-4-Replacement-Selection-30分" class="headerlink" title="7-4 Replacement Selection (30分)"></a>7-4 Replacement Selection (30分)</h2><p>When the input is much too large to fit into memory, we have to do <strong>external sorting</strong> instead of internal sorting. One of the key steps in external sorting is to generate sets of sorted records (also called <strong>runs</strong>) with limited internal memory. The simplest method is to read as many records as possible into the memory, and sort them internally, then write the resulting run back to some tape. The size of each run is the same as the capacity of the internal memory.</p><p><strong>Replacement Selection</strong> sorting algorithm was described in 1965 by Donald Knuth. Notice that as soon as the first record is written to an output tape, the memory it used becomes available for another record. Assume that we are sorting in ascending order, if the next record is not smaller than the record we have just output, then it can be included in the run.</p><p>For example, suppose that we have a set of input { 81, 94, 11, 96, 12, 99, 35 }, and our memory can sort 3 records only. By the simplest method we will obtain three runs: { 11, 81, 94 }, { 12, 96, 99 } and { 35 }. According to the replacement selection algorithm, we would read and sort the first 3 records { 81, 94, 11 } and output 11 as the smallest one. Then one space is available so 96 is read in and will join the first run since it is larger than 11. Now we have { 81, 94, 96 }. After 81 is out, 12 comes in but it must belong to the next run since it is smaller than 81. Hence we have { 94, 96, 12 } where 12 will stay since it belongs to the next run. When 94 is out and 99 is in, since 99 is larger than 94, it must belong to the <strong>first run</strong>. Eventually we will obtain two runs: the first one contains { 11, 81, 94, 96, 99 } and the second one contains { 12, 35 }.</p><p>Your job is to implement this replacement selection algorithm.</p><h3 id="Input-Specification-3"><a href="#Input-Specification-3" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains several test cases. The first line gives two positive integers N (≤10^5)<em>N</em>(≤105) and M (&lt;N/2)<em>M</em>(&lt;<em>N</em>/2), which are the total number of records to be sorted, and the capacity of the internal memory. Then N numbers are given in the next line, all in the range of <strong>int</strong>. All the numbers in a line are separated by a space.</p><h3 id="Output-Specification-3"><a href="#Output-Specification-3" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print in each line a run (in ascending order) generated by the replacement selection algorithm. All the numbers in a line must be separated by exactly 1 space, and there must be no extra space at the beginning or the end of the line.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">13 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">81 </span><span class="hljs-number">94</span> <span class="hljs-number">11</span> <span class="hljs-number">96</span> <span class="hljs-number">12</span> <span class="hljs-number">99</span> <span class="hljs-number">17</span> <span class="hljs-number">35</span> <span class="hljs-number">28</span> <span class="hljs-number">58</span> <span class="hljs-number">41</span> <span class="hljs-number">75</span> <span class="hljs-number">15</span><br></code></pre></td></tr></table></figure><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">11 </span><span class="hljs-number">81</span> <span class="hljs-number">94</span> <span class="hljs-number">96</span> <span class="hljs-number">99</span><br><span class="hljs-symbol">12 </span><span class="hljs-number">17</span> <span class="hljs-number">28</span> <span class="hljs-number">35</span> <span class="hljs-number">41</span> <span class="hljs-number">58</span> <span class="hljs-number">75</span><br><span class="hljs-number">15</span><br></code></pre></td></tr></table></figure><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>本题题目有点没看明白，后来参考<a href="https://blog.csdn.net/allisonshing/article/details/107626332">2020年7月第4题 PAT甲级真题 Replacement Selection (30分)</a>,代码中描述很清楚，根据代码的意思。题目描述的意思应该是。内部内存具有排序功能，每一轮排序都会输出内部内存中的最小值。同时外部内存中即将进入内部内存的值会和该最小值比较，若大于该最小值，则参与到该内部排序中，否则将这个值暂时保存起来且不进入到内部排序，等到当前这轮内部排序完成后再处理刚刚保存起来的值，进入新的一轮内部排序。</p><blockquote><p>觉得题目中<code>&#123; 94, 96, 12 &#125;</code>这个存在误导性。理论上<code>12</code>其实不应该放到内部内存中的，因为当前这轮排序还在继续，而<code>12</code>在下一轮的排序才参与排序。</p></blockquote><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">// 本题考查 外部排序算法</span><br><span class="hljs-comment">// 步骤：1. 尽可能读取记录，在进行内部排序 2. 将结果写入到run中</span><br><span class="hljs-comment">// 重要重要重要：本题把小于内部内存中有序队列的第一个值的值的放在下一轮中等待比较比较</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, m; <span class="hljs-comment">// m 内存大小</span><br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">arr</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) <span class="hljs-built_in">cin</span> &gt;&gt; arr[i];<br>    <span class="hljs-built_in">priority_queue</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;, greater&lt;<span class="hljs-keyword">int</span>&gt; &gt; pq;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; cur, next;<br>    <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>, idx = m, top;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) pq.push(arr[i]);<br>    <span class="hljs-keyword">while</span> (num != n) &#123;<br>        top = pq.top(); <span class="hljs-comment">// 和这个比较</span><br>        cur.push_back(top);<br>        num++;<br>        pq.pop();<br>        <span class="hljs-keyword">if</span> (idx &lt; n) &#123; <span class="hljs-comment">// 处理接下来的数字</span><br>            <span class="hljs-comment">// 若大于最小的数字放进队列中，否则加入到下一轮的比较</span><br>            <span class="hljs-keyword">if</span> (arr[idx] &gt; top) pq.push(arr[idx++]);<br>            <span class="hljs-keyword">else</span> next.push_back(arr[idx++]);<br>        &#125;<br>        <span class="hljs-comment">// 当前该轮结果比较完成</span><br>        <span class="hljs-keyword">if</span> (pq.empty()) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cur.size(); i++) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, cur[i]);<br>                <span class="hljs-keyword">if</span> (i &lt; cur.size() - <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);<br>            &#125;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>            cur.clear();<br>            <span class="hljs-comment">// 将下轮结果设置为当前这轮</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; next.size(); i++) &#123;<br>                pq.push(next[i]);<br>            &#125;<br>            next.clear();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://segmentfault.com/a/1190000038372948">7-1 Prime Day (20分)</a></li><li><a href="https://segmentfault.com/a/1190000038377285">7-2 The Judger (25分)</a></li><li><a href="https://segmentfault.com/a/1190000038373148">7-3 Safari Park (25分)</a></li><li><a href="https://segmentfault.com/a/1190000038377906">7-4 Replacement Selection (30分)</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>图</tag>
      
      <tag>素数</tag>
      
      <tag>优先队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树遍历所有路径的模板</title>
    <link href="/2021/03/04/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84%E7%9A%84%E6%A8%A1%E6%9D%BF/"/>
    <url>/2021/03/04/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84%E7%9A%84%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉树遍历所有路径的模板"><a href="#二叉树遍历所有路径的模板" class="headerlink" title="二叉树遍历所有路径的模板"></a>二叉树遍历所有路径的模板</h1><blockquote><p>注意：和图的遍历是有些不同的</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; ans;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; path, TreeNode* root)</span> </span>&#123;<br>path.push_back(root-&gt;val);<br><span class="hljs-comment">// 完成一条路径</span><br><span class="hljs-keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;<br>ans.push_back(path);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (root-&gt;left) &#123;<br>traversal(path, root-&gt;left);<br>path.pop_back();<br>&#125;<br><span class="hljs-keyword">if</span> (root-&gt;right) &#123;<br>traversal(path, root-&gt;right);<br>path.pop_back();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><ul><li>[1155 Heap Paths (30分)]:(<a href="https://emhui.fun/2021/01/23/1155-Heap-Paths-30%E5%88%86/">https://emhui.fun/2021/01/23/1155-Heap-Paths-30%E5%88%86/</a>)</li><li>[988. 从叶结点开始的最小字符串]:(<a href="https://leetcode-cn.com/problems/smallest-string-starting-from-leaf/">https://leetcode-cn.com/problems/smallest-string-starting-from-leaf/</a>)</li><li><a href="https://leetcode-cn.com/problems/binary-tree-paths/">257. 二叉树的所有路径</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>leetcode</tag>
      
      <tag>路径</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2019年秋季PAT考试</title>
    <link href="/2021/02/27/2019%E5%B9%B4%E7%A7%8B%E5%AD%A3PAT%E8%80%83%E8%AF%95/"/>
    <url>/2021/02/27/2019%E5%B9%B4%E7%A7%8B%E5%AD%A3PAT%E8%80%83%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="2019年秋季PAT考试"><a href="#2019年秋季PAT考试" class="headerlink" title="2019年秋季PAT考试"></a>2019年秋季PAT考试</h1><h2 id="7-1-Forever-20分"><a href="#7-1-Forever-20分" class="headerlink" title="7-1 Forever (20分)"></a>7-1 Forever (20分)</h2><p>“Forever number” is a positive integer A with K digits, satisfying the following constrains:</p><ul><li>the sum of all the digits of A is m;</li><li>the sum of all the digits of A+1 is n;</li><li>and the greatest common divisor of m and n is a prime number which is greater than 2.</li></ul><p>Now you are supposed to find these forever numbers.</p><p><strong>Input Specification:</strong></p><p>Each input file contains one test case. For each test case, the first line contains a positive integer N (≤5). Then N lines follow, each gives a pair of K (3&lt;K&lt;10) and m (1&lt;m&lt;90), of which the meanings are given in the problem description.</p><blockquote><p>k,m的含义在上面的问题描述中已给出。</p></blockquote><p><strong>Output Specification:</strong></p><p>For each pair of K and m, first print in a line Case X, where X is the case index (starts from 1). Then print n and A in the following line. The numbers must be separated by a space. If the solution is not unique, output in the ascending order of n. If still not unique, output in the ascending order of A. If there is no solution, output No Solution.</p><p><strong>Sample Input:</strong></p><blockquote><p>2</p><p>6 45</p><p>7 80</p></blockquote><p><strong>Sample Output:</strong></p><blockquote><p>Case 1</p><p>10 189999</p><p>10 279999</p><p>10 369999</p><p>10 459999</p><p>10 549999</p><p>10 639999</p><p>10 729999</p><p>10 819999</p><p>10 909999</p><p>Case 2</p><p>No Solution</p></blockquote><p>代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">int</span> n, k, m;<br><span class="hljs-keyword">bool</span> isOk = <span class="hljs-literal">false</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> n == <span class="hljs-number">0</span> ? m : gcd(n, m % n);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPrime</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i * i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (n) &#123;<br>        sum += n % <span class="hljs-number">10</span>;<br>        n /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-comment">// sum 位数和, cnt 位数, res A</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sum, <span class="hljs-keyword">int</span> cnt, <span class="hljs-keyword">int</span> res)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (sum == m &amp;&amp; cnt == k) &#123;<br>        <span class="hljs-comment">// 判断res是否是forever</span><br>        <span class="hljs-keyword">int</span> n = getNum(res + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">int</span> g = gcd(m, n);<br>        <span class="hljs-keyword">if</span> (g &gt; <span class="hljs-number">2</span> &amp;&amp; isPrime(g)) &#123;<br>            isOk = <span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, n, res);<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (sum &gt; m || cnt &gt; k) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 如何保证第一位不是0？ 最后两位一定是9</span><br>    <span class="hljs-comment">// 一开始两位是99，第一位肯定是1</span><br>    <span class="hljs-keyword">int</span> min = cnt == k - <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : ((cnt == <span class="hljs-number">0</span>)|| (cnt == <span class="hljs-number">1</span>)) ? <span class="hljs-number">9</span> : <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">9</span>; i &gt;= min; i--) &#123;<br>        backtrack(sum + i, cnt + <span class="hljs-number">1</span>, res + i * <span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>, cnt));<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; k &gt;&gt; m;<br>        isOk = <span class="hljs-literal">false</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Case %d&quot;</span>, i);<br>        backtrack(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (!isOk) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No Solution&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-2-Merging-Linked-Lists-25分"><a href="#7-2-Merging-Linked-Lists-25分" class="headerlink" title="7-2 Merging Linked Lists (25分)"></a>7-2 Merging Linked Lists (25分)</h2><p>Given two singly linked lists $L1=a_1→a_2→⋯→a_{n-1}$ and $L2=b_1→b_2→⋯→b_{m-1}.$ If n≥2m, you are supposed to reverse and merge the shorter one into the longer one to obtain a list like a1→a2→bm→a3→a4→bm−1⋯. For example, given one list being 6→7 and the other one 1→2→3→4→5, you must output 1→2→7→3→4→6→5.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains the two addresses of the first nodes of L1 and L2, plus a positive N (≤10^5)<em>N</em>(≤105) which is the total number of nodes given. The address of a node is a 5-digit nonnegative integer, and NULL is represented by <code>-1</code>.</p><p>Then N lines follow, each describes a node in the format:</p><figure class="highlight purebasic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs purebasic">Address <span class="hljs-keyword">Data</span> <span class="hljs-keyword">Next</span><br></code></pre></td></tr></table></figure><p>where <code>Address</code> is the position of the node, <code>Data</code> is a positive integer no more than 10^5, and <code>Next</code> is the position of the next node. It is guaranteed that no list is empty, and the longer list is at least twice as long as the shorter one.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each case, output in order the resulting linked list. Each node occupies a line, and is printed in the same format as in the input.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">00100 01000 7<br>02233 2 34891<br>00100 6 00001<br>34891 3 10086<br>01000 1 02233<br>00033 5 -1<br>10086 4 00033<br>00001 7 -1<br></code></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">01000 </span><span class="hljs-number">1</span> <span class="hljs-number">02233</span><br><span class="hljs-symbol">02233 </span><span class="hljs-number">2</span> <span class="hljs-number">00001</span><br><span class="hljs-symbol">00001 </span><span class="hljs-number">7</span> <span class="hljs-number">34891</span><br><span class="hljs-symbol">34891 </span><span class="hljs-number">3</span> <span class="hljs-number">10086</span><br><span class="hljs-symbol">10086 </span><span class="hljs-number">4</span> <span class="hljs-number">00100</span><br><span class="hljs-symbol">00100 </span><span class="hljs-number">6</span> <span class="hljs-number">00033</span><br><span class="hljs-symbol">00033 </span><span class="hljs-number">5</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 两个链表夹着一个，使用vector存储短的那个链表</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">100000</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span><br>    <span class="hljs-keyword">int</span> address, val, next;<br>&#125;links[MAX];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getValidLink</span><span class="hljs-params">(<span class="hljs-keyword">int</span> begin, <span class="hljs-built_in">vector</span>&lt;node&gt;&amp; vlinks)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (begin != <span class="hljs-number">-1</span>) &#123;<br>        vlinks.push_back(links[begin]);<br>        begin = links[begin].next;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> b1, b2, n; <span class="hljs-comment">// b1, b2: 两个链表的头结点</span><br>    <span class="hljs-keyword">int</span> address, val, next;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;b1, &amp;b2, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;address, &amp;val, &amp;next);<br>        links[address].address = address;<br>        links[address].val = val;<br>        links[address].next = next;<br>    &#125;<br>    <span class="hljs-built_in">vector</span>&lt;node&gt; vlinks1, vlinks2;<br>    getValidLink(b1, vlinks1);<br>    getValidLink(b2, vlinks2);<br>    <span class="hljs-comment">// 默认将vlinks1作为较长的那个链表</span><br>    <span class="hljs-keyword">if</span> (vlinks2.size() &gt; vlinks1.size()) swap(vlinks1, vlinks2);<br>    <span class="hljs-keyword">int</span> m = vlinks2.size() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>, i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; vlinks1.size() - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d %d &quot;</span>, vlinks1[i].address, vlinks1[i].val);<br>        cnt++;<br>        <span class="hljs-keyword">if</span> (cnt % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> &amp;&amp; m &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d&quot;</span>, vlinks2[m].address);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d %d %05d&quot;</span>, vlinks2[m].address, vlinks2[m].val, vlinks1[i + <span class="hljs-number">1</span>].address);<br>            m--;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d&quot;</span>, vlinks1[i + <span class="hljs-number">1</span>].address);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d %d -1&quot;</span>, vlinks1[i].address, vlinks1[i].val);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-3-Postfix-Expression-25分"><a href="#7-3-Postfix-Expression-25分" class="headerlink" title="7-3 Postfix Expression (25分)"></a>7-3 Postfix Expression (25分)</h2><p>Given a syntax tree (binary), you are supposed to output the corresponding postfix expression, with parentheses reflecting the precedences of the operators.</p><h3 id="Input-Specification-1"><a href="#Input-Specification-1" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line gives a positive integer N (≤ 20) which is the total number of nodes in the syntax tree. Then N lines follow, each gives the information of a node (the i-th line corresponds to the i-th node) in the format:</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> left_child right_child</span><br></code></pre></td></tr></table></figure><p>where <code>data</code> is a string of no more than 10 characters, <code>left_child</code> and <code>right_child</code> are the indices of this node’s left and right children, respectively. The nodes are indexed from 1 to N. The NULL link is represented by −1. The figures 1 and 2 correspond to the samples 1 and 2, respectively.</p><p><img src="https://segmentfault.com/img/remote/1460000038366119" alt="infix1.JPG"><br>Figure 1<br><img src="https://segmentfault.com/img/remote/1460000038366118" alt="infix2.JPG"></p><p>Figure 2</p><h3 id="Output-Specification-1"><a href="#Output-Specification-1" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each case, print in a line the postfix expression, with parentheses reflecting the precedences of the operators.There must be no space between any symbols.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-number">8</span><br>* <span class="hljs-number">8</span> <span class="hljs-number">7</span><br>a <span class="hljs-number">-1</span> <span class="hljs-number">-1</span><br>* <span class="hljs-number">4</span> <span class="hljs-number">1</span><br>+ <span class="hljs-number">2</span> <span class="hljs-number">5</span><br>b <span class="hljs-number">-1</span> <span class="hljs-number">-1</span><br>d <span class="hljs-number">-1</span> <span class="hljs-number">-1</span><br>- <span class="hljs-number">-1</span> <span class="hljs-number">6</span><br>c <span class="hljs-number">-1</span> <span class="hljs-number">-1</span><br></code></pre></td></tr></table></figure><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(((<span class="hljs-name">a</span>)(<span class="hljs-name">b</span>)+)((<span class="hljs-name">c</span>)(<span class="hljs-name"><span class="hljs-builtin-name">-</span></span>(<span class="hljs-name">d</span>))*)*)<br></code></pre></td></tr></table></figure><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-number">8</span><br><span class="hljs-number">2.35</span> <span class="hljs-number">-1</span> <span class="hljs-number">-1</span><br>* <span class="hljs-number">6</span> <span class="hljs-number">1</span><br>- <span class="hljs-number">-1</span> <span class="hljs-number">4</span><br>% <span class="hljs-number">7</span> <span class="hljs-number">8</span><br>+ <span class="hljs-number">2</span> <span class="hljs-number">3</span><br>a <span class="hljs-number">-1</span> <span class="hljs-number">-1</span><br>str <span class="hljs-number">-1</span> <span class="hljs-number">-1</span><br><span class="hljs-number">871</span> <span class="hljs-number">-1</span> <span class="hljs-number">-1</span><br></code></pre></td></tr></table></figure><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(((<span class="hljs-name">a</span>)(<span class="hljs-name">2.35</span>)*)(<span class="hljs-name"><span class="hljs-builtin-name">-</span></span>((<span class="hljs-name">str</span>)(<span class="hljs-name">871</span>)%))+)<br></code></pre></td></tr></table></figure><p>代码如下</p><blockquote><p>注意要对<code>+,-</code>做特殊的判断，他们两个可以不是操作符</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">// 每个子树都需要添加括号</span><br><span class="hljs-comment">// 还需要找到根结点</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">21</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>&#123;</span><br>    <span class="hljs-built_in">string</span> val;<br>    <span class="hljs-keyword">int</span> left, right;<br>&#125;tree[MAX];<br><br><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">posttravel</span><span class="hljs-params">(<span class="hljs-keyword">int</span> root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-built_in">string</span> temp = <span class="hljs-string">&quot;(&quot;</span>;<br>    <span class="hljs-comment">// 不属于操作符，那就选择先访问该结点,在访问其他结点</span><br>    <span class="hljs-keyword">if</span> ((tree[root].val == <span class="hljs-string">&quot;-&quot;</span> || tree[root].val == <span class="hljs-string">&quot;+&quot;</span>) &amp;&amp; tree[root].left == <span class="hljs-number">-1</span>) &#123;<br>        temp += tree[root].val;<br>        temp += posttravel(tree[root].right);<br>        temp += <span class="hljs-string">&quot;)&quot;</span>;<br>        <span class="hljs-keyword">return</span> temp;<br>    &#125;<br>    temp += posttravel(tree[root].left);<br>    temp += posttravel(tree[root].right);<br>    temp += tree[root].val;<br>    temp += <span class="hljs-string">&quot;)&quot;</span>;<br>    <span class="hljs-keyword">return</span> temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">string</span> val;<br>    <span class="hljs-keyword">int</span> left, right;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">inDegree</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; tree[i].val &gt;&gt; tree[i].left &gt;&gt; tree[i].right;<br>        <span class="hljs-keyword">if</span> (tree[i].left != <span class="hljs-number">-1</span>) inDegree[tree[i].left]++;<br>        <span class="hljs-keyword">if</span> (tree[i].right != <span class="hljs-number">-1</span>) inDegree[tree[i].right]++;<br>    &#125;<br>    <span class="hljs-keyword">int</span> root;<br><span class="hljs-comment">// 根据root入度为0，找到root</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (inDegree[i] == <span class="hljs-number">0</span>) &#123;<br>            root = i;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">string</span> ans = posttravel(root);<br>    <span class="hljs-built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-4-Dijkstra-Sequence-30分"><a href="#7-4-Dijkstra-Sequence-30分" class="headerlink" title="7-4 Dijkstra Sequence (30分)"></a>7-4 Dijkstra Sequence (30分)</h2><p>Dijkstra’s algorithm is one of the very famous greedy algorithms. It is used for solving the single source shortest path problem which gives the shortest paths from one particular source vertex to all the other vertices of the given graph. It was conceived by computer scientist Edsger W. Dijkstra in 1956 and published three years later.</p><p>In this algorithm, a set contains vertices included in shortest path tree is maintained. During each step, we find one vertex which is not yet included and has a minimum distance from the source, and collect it into the set. Hence step by step an ordered sequence of vertices, let’s call it <strong>Dijkstra sequence</strong>, is generated by Dijkstra’s algorithm.</p><p>On the other hand, for a given graph, there could be more than one Dijkstra sequence. For example, both { 5, 1, 3, 4, 2 } and { 5, 3, 1, 2, 4 } are Dijkstra sequences for the graph, where 5 is the source. Your job is to check whether a given sequence is Dijkstra sequence or not.</p><h3 id="Input-Specification-2"><a href="#Input-Specification-2" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains two positive integers Nv (≤10^3)<em>N**v</em>(≤103)andNe (≤10^5)<em>N**e</em>(≤105), which are the total numbers of vertices and edges, respectively. Hence the vertices are numbered from 1 to Nv.</p><p>Then Ne lines follow, each describes an edge by giving the indices of the vertices at the two ends, followed by a positive integer weight (≤100) of the edge. It is guaranteed that the given graph is connected.</p><p>Finally the number of queries, K, is given as a positive integer no larger than 100, followed by K lines of sequences, each contains a permutationof the Nv vertices. It is assumed that the first vertex is the source for each sequence.</p><p>All the inputs in a line are separated by a space.</p><h3 id="Output-Specification-2"><a href="#Output-Specification-2" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each of the K sequences, print in a line <code>Yes</code> if it is a Dijkstra sequence, or <code>No</code> if not.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">7</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">5</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">5</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">5</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span> <span class="hljs-number">1</span><br><span class="hljs-number">4</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">5</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-literal">Yes</span><br><span class="hljs-literal">Yes</span><br><span class="hljs-literal">Yes</span><br><span class="hljs-literal">No</span><br></code></pre></td></tr></table></figure><p>代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 找到到每个点的最短路径。</span><br><span class="hljs-comment">// 然后判断集合是否满足</span><br><span class="hljs-comment">// 求出各个的到其他点的最短路径</span><br><span class="hljs-comment">// 接下来如何判断是否是Dijkstra？</span><br><span class="hljs-comment">// 判断路径是否是递增的即可</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">987654321</span>;<br><span class="hljs-keyword">int</span> nv, ne, k;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; allDis; <span class="hljs-comment">// 存储各个点到其他点的最短距离</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt;&gt; G; <span class="hljs-comment">// 邻接表</span><br><br><span class="hljs-comment">// 从start结点开始</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start)</span> </span>&#123;<br>    vector&lt;int&gt; dis(nv + 1, MAX), visited(nv + 1, 0);<br>    dis[start] = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">priority_queue</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt;, greater&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt;&gt; pq;<br>    pq.push(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">0</span>, start));<br>    <span class="hljs-keyword">while</span> (!pq.empty()) &#123;<br>        <span class="hljs-keyword">int</span> u = pq.top().second;<br>        pq.pop();<br>        <span class="hljs-keyword">if</span> (visited[u]) <span class="hljs-keyword">continue</span>;<br>        visited[u] = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 更新u到v的结点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; G[u].size(); i++) &#123;<br>            <span class="hljs-keyword">int</span> v = G[u][i].first, w = G[u][i].second;<br>            <span class="hljs-keyword">if</span> (!visited[v] &amp;&amp; dis[u] + w &lt; dis[v]) &#123;<br>                dis[v] = dis[u] + w;<br>                pq.push(<span class="hljs-built_in">make_pair</span>(dis[v], v));<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 添加到路径中</span><br>    allDis[start] = dis;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n1, n2, w; <span class="hljs-comment">// n1,n2:node结点,w:权重</span><br>    <span class="hljs-built_in">cin</span> &gt;&gt; nv &gt;&gt; ne;<br>    allDis.resize(nv + <span class="hljs-number">1</span>);<br>    G.resize(nv + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ne; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; n1 &gt;&gt; n2 &gt;&gt; w;<br>        G[n1].push_back(<span class="hljs-built_in">make_pair</span>(n2, w));<br>        G[n2].push_back(<span class="hljs-built_in">make_pair</span>(n1, w));<br>    &#125;<br>    <span class="hljs-comment">// 求从每个点开始到其他点的最短路径</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= nv; i++) &#123;<br>        Dijkstra(i);<br>    &#125;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; k;<br>    <span class="hljs-keyword">int</span> source, node, preDis, isOk;<br>    <span class="hljs-keyword">while</span> (k--) &#123;<br>        isOk = <span class="hljs-number">1</span>;<br>        preDis = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; source;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nv; i++) &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; node;<br>            <span class="hljs-comment">// 如果前面那个距离比后面那个距离大，证明不是Dijkstra序列</span><br>            <span class="hljs-keyword">if</span> (preDis &gt; allDis[source][node]) isOk = <span class="hljs-number">0</span>;<br>            preDis = allDis[source][node];<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, isOk ? <span class="hljs-string">&quot;Yes&quot;</span> : <span class="hljs-string">&quot;No&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://segmentfault.com/a/1190000038365624">PAT（甲级）2019年秋季考试 7-1 Forever</a></li><li><a href="https://segmentfault.com/a/1190000038365930">7-2 Merging Linked Lists (25分)</a></li><li><a href="https://segmentfault.com/a/1190000038366115">7-3 Postfix Expression (25分)</a></li><li><a href="https://segmentfault.com/a/1190000038366311">7-4 Dijkstra Sequence (30分)</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2019年春季PAT考试</title>
    <link href="/2021/02/27/2019%E5%B9%B4%E6%98%A5%E5%AD%A3PAT%E8%80%83%E8%AF%95/"/>
    <url>/2021/02/27/2019%E5%B9%B4%E6%98%A5%E5%AD%A3PAT%E8%80%83%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="2019年春季PAT考试"><a href="#2019年春季PAT考试" class="headerlink" title="2019年春季PAT考试"></a>2019年春季PAT考试</h1><h2 id="7-1-Sexy-Primes-20分"><a href="#7-1-Sexy-Primes-20分" class="headerlink" title="7-1 Sexy Primes (20分)"></a>7-1 Sexy Primes (20分)</h2><p>Sexy primes are pairs of primes of the form (p, p+6), so-named since “sex” is the Latin word for “six”. (Quoted from <a href="http://mathworld.wolfram.com/SexyPrimes.html">http://mathworld.wolfram.com/SexyPrimes.html</a>)</p><blockquote><p>性感素数是一对（p,p+6）形式的素数，为什么这样叫呢？因为在拉丁语中six和sex一样</p></blockquote><p>Now given an integer, you are supposed to tell if it is a sexy prime.</p><blockquote><p>现在给你一个整数，你要判断是否它是一个性感素数。</p></blockquote><p><strong>Input Specification:</strong></p><p>Each input file contains one test case. Each case gives a positive integer N (≤10^8).</p><p><strong>Output Specification:</strong></p><p>For each case, print in a line Yes if N is a sexy prime, then print in the next line the other sexy prime paired with N (if the answer is not unique, output the smaller number).</p><blockquote><p>如果是一个性感素数，打印<code>YES</code>，然后在下一行打印出另一个和N配对的素数(如果答案不唯一，就打印出最小的那个答案)。</p></blockquote><p>Or if N is not a sexy prime, print No instead, then print in the next line the smallest sexy prime which is larger than N.</p><blockquote><p>或者如果N不是性感素数，就打印No，然后打印出最小的性感素数，这个素数需要大于N。</p></blockquote><p><strong>Sample Input 1:</strong></p><blockquote><p>47</p></blockquote><p><strong>Sample Output 1:</strong></p><blockquote><p>Yes</p><p>41</p></blockquote><p><strong>Sample Input 2:</strong></p><blockquote><p>21</p></blockquote><p><strong>Sample Output 2:</strong></p><blockquote><p>No</p><p>23</p></blockquote><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>本题考查 <strong>素数</strong>。</p><p>设置三个参数<code>b1, b2, b3</code>分别表示<code>n - 6, n + 6, n</code>是否是素数，若满足</p><p><code>b3 &amp;&amp; (b1 || b2) == true</code> 就证明该数字是性感素数，那么优先打印最小的那个素数（n-6或n+6）。如果不为真，那么就继续寻找下一个最小的的素数,<code>n++</code>,再回到刚刚的性感素数判断，直到为true，就打印出<code>n</code></p><p>代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPrime</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// not forget &lt;= .</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= (<span class="hljs-keyword">int</span>)<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">1.0</span> * n); i++) &#123;<br>        <span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSexyPrime</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> isPrime(n) &amp;&amp; (isPrime(n - <span class="hljs-number">6</span>) || isPrime(n + <span class="hljs-number">6</span>));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <span class="hljs-keyword">if</span> (isSexyPrime(n)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Yes\n%d\n&quot;</span>, isPrime(n - <span class="hljs-number">6</span>) ? n - <span class="hljs-number">6</span> : n + <span class="hljs-number">6</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">while</span> (!isSexyPrime(++n));<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No\n%d&quot;</span>, n);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-2-Anniversary-25分"><a href="#7-2-Anniversary-25分" class="headerlink" title="7-2 Anniversary (25分)"></a>7-2 Anniversary (25分)</h2><p>Zhejiang University is about to celebrate her 122th anniversary in 2019.</p><blockquote><p>浙江大学打算在2019年庆祝她的第122个周年庆。</p></blockquote><p>To prepare for the celebration, the alumni association （校友会） has gathered the ID’s of all her alumni.</p><blockquote><p>为了准备这个庆典，校友会已经获取到她的所有校友的ID。</p></blockquote><p>Now your job is to write a program to count the number of alumni among all the people who come to the celebration.</p><blockquote><p>你的工作就是写一个程序统计来参加庆典的所有人中，校友的数量。</p></blockquote><p><strong>Input Specification:</strong></p><p>Each input file contains one test case. For each case, the first part is about the information of all the alumni. Given in the first line is a positive integer N (≤10^5).Then N lines follow, each contains an ID number of an alumnus. An ID number is a string of 18 digits or the letter X. It is guaranteed that all the ID’s are distinct.</p><p>The next part gives the information of all the people who come to the celebration. Again given in the first line is a positive integer M(≤10^5). Then M lines follow, each contains an ID number of a guest. It is guaranteed that all the ID’s are distinct.</p><p><strong>Output Specification:</strong></p><p>First print in a line the number of alumni among all the people who come to the celebration. Then in the second line, print the ID of the oldest alumnus – notice that the 7th - 14th digits of the ID gives one’s birth date. If no alumnus comes, output the ID of the oldest guest instead. It is guaranteed that such an alumnus or guest is unique.</p><p><strong>Sample Input:</strong></p><blockquote><p>5</p><p>372928196906118710</p><p>610481197806202213</p><p>440684198612150417</p><p>13072819571002001X</p><p>150702193604190912</p><p>6</p><p>530125197901260019</p><p>150702193604190912</p><p>220221196701020034</p><p>610481197806202213</p><p>440684198612150417</p><p>370205198709275042</p></blockquote><p><strong>Sample Output:</strong></p><blockquote><p>3</p><p>150702193604190912</p></blockquote><p>代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_set&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 将出生年月日设置为最大的一天</span><br>    <span class="hljs-built_in">string</span> oldAlumnu = <span class="hljs-string">&quot;999999999999999999&quot;</span>, oldGuest = <span class="hljs-string">&quot;999999999999999999&quot;</span>, s;<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>, n, m;<br>    <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-built_in">string</span>&gt; alumni;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; s;<br>        alumni.insert(s);<br>    &#125;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; s;<br>        <span class="hljs-keyword">if</span> (alumni.count(s)) &#123; <span class="hljs-comment">// 如果是校友</span><br>            cnt++;<br>            <span class="hljs-keyword">if</span> (oldAlumnu.substr(<span class="hljs-number">6</span>, <span class="hljs-number">8</span>) &gt; s.substr(<span class="hljs-number">6</span>, <span class="hljs-number">8</span>)) oldAlumnu = s;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (oldGuest.substr(<span class="hljs-number">6</span>, <span class="hljs-number">8</span>) &gt; s.substr(<span class="hljs-number">6</span>, <span class="hljs-number">8</span>)) oldGuest = s;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (cnt) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n%s\n&quot;</span>, cnt, oldAlumnu.c_str());<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0\n%s\n&quot;</span>, oldGuest.c_str());<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-3-Telefraud-Detection-25分"><a href="#7-3-Telefraud-Detection-25分" class="headerlink" title="7-3 Telefraud Detection (25分)"></a>7-3 Telefraud Detection (25分)</h2><p>Telefraud（电信诈骗） remains a common and persistent problem in our society.</p><blockquote><p>在我们的社会中，电信诈骗仍然是一个常见和持续存在的问题。</p></blockquote><p>In some cases, unsuspecting victims lose their entire life savings.</p><blockquote><p>在某些情况下，毫无戒心的受害者会失去他们一生的积蓄。</p></blockquote><p>To stop this crime, you are supposed to write a program to detect those suspects from a huge amount of phone call records.</p><blockquote><p>为了制止这种犯罪，你要写一个程序去从大量的电话记录中侦测这些嫌疑犯。</p></blockquote><p>A person must be detected as a suspect if he/she makes more than K short phone calls to different people everyday, but no more than 20% of these people would call back. And more, if two suspects are calling each other, we say they might belong to the same gang.</p><blockquote><p>一个人被认定为嫌疑犯的条件。如果他/她每天给不同的人打了超过K个较短的电话（时间不超过5分钟的通话被认为是较短的通话），但是在所有打电话人数中，只有不超过20%的人回拨了。而且，如果两个嫌疑犯互通电话，我们可以认为他们也许属于同一个团伙。</p></blockquote><p>A makes a short phone call to B means that the total duration of the calls from A to B is no more than 5 minutes.</p><blockquote><p>A给B打了一个最短的通话是指：A和B的<strong>总通话时常不超过5分钟</strong>。</p></blockquote><p><strong>Input Specification:</strong></p><p>Each input file contains one test case. For each case, the first line gives 3 positive integers K (≤500K, the threshold（阈值） of the amount of short phone calls), N (≤10^3, the number of different phone numbers), and M (≤10^5,the number of phone call records). Then M lines of one day’s records are given, each in the format:</p><blockquote><p>caller receiver duration</p></blockquote><p>where caller and receiver are numbered from 1 to N, and duration is no more than 1440 minutes in a day.</p><p><strong>Output Specification:</strong></p><p>Print in each line all the detected suspects in a gang, in ascending order of their numbers. The gangs are printed in ascending order of their first members. The numbers in a line must be separated by exactly 1 space, and there must be no extra space at the beginning or the end of the line.</p><p>If no one is detected, output None instead.</p><p><strong>Sample Input 1:</strong></p><blockquote><p>5 15 31</p><p>1 4 2</p><p>1 5 2</p><p>1 5 4</p><p>1 7 5</p><p>1 8 3</p><p>1 9 1</p><p>1 6 5</p><p>1 15 2</p><p>1 15 5</p><p>3 2 2</p><p>3 5 15</p><p>3 13 1</p><p>3 12 1</p><p>3 14 1</p><p>3 10 2</p><p>3 11 5</p><p>5 2 1</p><p>5 3 10</p><p>5 1 1</p><p>5 7 2</p><p>5 6 1</p><p>5 13 4</p><p>5 15 1</p><p>11 10 5</p><p>12 14 1</p><p>6 1 1</p><p>6 9 2</p><p>6 10 5</p><p>6 11 2</p><p>6 12 1</p><p>6 13 1</p></blockquote><p><strong>Sample Output 1:</strong></p><blockquote><p>3 5</p><p>6</p></blockquote><p>Note: In sample 1, although <code>1</code> had 9 records, but there were 7 distinct receivers, among which <code>5</code> and <code>15</code> both had conversations lasted more than 5 minutes in total. Hence <code>1</code> had made 5 short phone calls and didn’t exceed the threshold 5, and therefore is not a suspect.</p><p><strong>Sample Input 2:</strong></p><blockquote><p>5 7 8</p><p>1 2 1</p><p>1 3 1</p><p>1 4 1</p><p>1 5 1</p><p>1 6 1</p><p>1 7 1</p><p>2 1 1</p><p>3 1 1</p></blockquote><p><strong>Sample Output 2:</strong></p><blockquote><p>None</p></blockquote><p>代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">1001</span>;<br><span class="hljs-keyword">int</span> k, n, m;<br><span class="hljs-keyword">int</span> records[MAX][MAX] = &#123;<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// 记录i-&gt;j的通话时间</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; suspects, visited;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; gang)</span> </span>&#123;<br>    visited[s] = <span class="hljs-number">1</span>;<br>    gang.push_back(suspects[s]);<br>    <span class="hljs-keyword">int</span> call = suspects[s];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; suspects.size(); i++) &#123;<br>        <span class="hljs-keyword">int</span> rev = suspects[i];<br>        <span class="hljs-comment">// 如果两个人嫌疑人有过通话，就添加到一个犯罪团伙中</span><br>        <span class="hljs-keyword">if</span> (!visited[i] &amp;&amp; records[call][rev] != <span class="hljs-number">0</span> &amp;&amp; records[rev][call] != <span class="hljs-number">0</span>) &#123;<br>            dfs(i, gang);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; k &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">int</span> call, rev, dur;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; call &gt;&gt; rev &gt;&gt; dur;<br>        records[call][rev] += dur; <span class="hljs-comment">// 统计通话时常</span><br>    &#125;<br>    <span class="hljs-keyword">int</span> callNum, revNum; <span class="hljs-comment">// 打电话数量，回电话数量</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        callNum = revNum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (records[i][j] != <span class="hljs-number">0</span> &amp;&amp; records[i][j] &lt;= <span class="hljs-number">5</span>) &#123; <span class="hljs-comment">// 存在通话&amp;&amp;通话不超过5分钟的人</span><br>                callNum++;<br>                <span class="hljs-comment">// 统计回电话的人数</span><br>                <span class="hljs-keyword">if</span> (records[j][i] != <span class="hljs-number">0</span>) revNum++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 判断这个人是否是嫌疑人</span><br><span class="hljs-comment">// 超过k个最短电话&amp;&amp;回电话的人数不到20%</span><br>        <span class="hljs-keyword">if</span> (callNum &gt; k &amp;&amp; callNum * <span class="hljs-number">0.2</span> &gt;= revNum) suspects.push_back(i);<br>    &#125;<br>    <span class="hljs-comment">// 找是否属于同一个犯罪团伙，统一团伙属于同一个连通图</span><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; ans;<br>    visited.resize(suspects.size(), <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; suspects.size(); i++) &#123;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; gang;<br>        <span class="hljs-keyword">if</span> (!visited[i]) &#123;<br>            dfs(i, gang);<br>            ans.push_back(gang);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ans.size(); i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; ans[i].size(); j++) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ans[i][j]);<br>            <span class="hljs-keyword">if</span> (j &lt; ans[i].size() - <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (ans.size() == <span class="hljs-number">0</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;None\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-4-Structure-of-a-Binary-Tree-30分"><a href="#7-4-Structure-of-a-Binary-Tree-30分" class="headerlink" title="7-4 Structure of a Binary Tree (30分)"></a>7-4 Structure of a Binary Tree (30分)</h2><p>Suppose that all the keys in a binary tree are distinct positive integers. Given the postorder and inorder traversal sequences, a binary tree can be uniquely determined.</p><p>Now given a sequence of statements about the structure of the resulting tree, you are supposed to tell if they are correct or not. A statment is one of the following:</p><ul><li>A is the root</li><li>A and B are siblings</li><li>A is the parent of B</li><li>A is the left child of B</li><li>A is the right child of B</li><li>A and B are on the same level</li><li>It is a full tree</li></ul><p>Note:</p><p>Two nodes are on the same level, means that they have the same depth.</p><p>A <strong>full binary tree</strong> is a tree in which every node other than the leaves has two children.</p><p><strong>Input Specification:</strong></p><p>Each input file contains one test case. For each case, the first line gives a positive integer N (≤30)N(≤30), the total number of nodes in the binary tree. The second line gives the postorder sequence and the third line gives the inorder sequence. All the numbers in a line are no more than 10^31 and are separated by a space.</p><p>Then another positive integer M (≤30) is given, followed by M lines of statements. It is guaranteed that both A and B in the statements are in the tree.</p><p><strong>Output Specification:</strong></p><p>For each statement, print in a line Yes if it is correct, or No if not.</p><p><strong>Sample Input:</strong></p><blockquote><p>9</p><p>16 7 11 32 28 2 23 8 15</p><p>16 23 7 32 11 2 28 15 8</p><p>7</p><p>15 is the root</p><p>8 and 2 are siblings</p><p>32 is the parent of 11</p><p>23 is the left child of 16</p><p>28 is the right child of 2</p><p>7 and 11 are on the same level</p><p>It is a full tree</p></blockquote><p><strong>Sample Output:</strong></p><blockquote><p>Yes</p><p>No</p><p>Yes</p><p>No</p><p>Yes</p><p>Yes</p><p>Yes</p></blockquote><p>代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>&#123;</span><br>    <span class="hljs-keyword">int</span> val, depth;<br>    TreeNode *left, *right, *parent, *siblings;<br>&#125;*root;<br><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; postorder, inorder;<br><span class="hljs-keyword">bool</span> isFullBinaryTree = <span class="hljs-literal">true</span>;<br><br><span class="hljs-function">TreeNode* <span class="hljs-title">create</span><span class="hljs-params">(<span class="hljs-keyword">int</span> inl, <span class="hljs-keyword">int</span> inr, <span class="hljs-keyword">int</span> postl, <span class="hljs-keyword">int</span> postr, TreeNode* parent, <span class="hljs-keyword">int</span> depth)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (postl &gt; postr) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    TreeNode* root = <span class="hljs-keyword">new</span> TreeNode;<br>    root-&gt;val = postorder[postr];<br>    root-&gt;depth = depth;<br>    <span class="hljs-keyword">if</span> (parent != <span class="hljs-literal">NULL</span>) root-&gt;parent = parent;<br>    <span class="hljs-keyword">int</span> mid;<br>    <span class="hljs-keyword">for</span> (mid = inl; mid &lt;= inr; mid++) <span class="hljs-keyword">if</span> (inorder[mid] == postorder[postr]) <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">int</span> num = mid - inl;<br>    root-&gt;left = create(inl, mid - <span class="hljs-number">1</span>, postl, postl + num - <span class="hljs-number">1</span>, root, depth + <span class="hljs-number">1</span>);<br>    root-&gt;right = create(mid + <span class="hljs-number">1</span>, inr, postl + num, postr - <span class="hljs-number">1</span>, root, depth + <span class="hljs-number">1</span>);<br><span class="hljs-comment">// 判断是否是full tree，若左右子结点只存在一个，那么就不是full tree</span><br>    <span class="hljs-keyword">if</span> ((root-&gt;left &amp;&amp; !root-&gt;right) || (!root-&gt;left &amp;&amp; root-&gt;right)) isFullBinaryTree = <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 左右子树互相建立兄妹结点联系</span><br>    <span class="hljs-keyword">if</span> (root-&gt;left &amp;&amp; root-&gt;right) &#123;<br>        root-&gt;left-&gt;siblings = root-&gt;right;<br>        root-&gt;right-&gt;siblings = root-&gt;left;<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getA</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (s[idx] != <span class="hljs-string">&#x27; &#x27;</span>) idx++;<br>    <span class="hljs-keyword">return</span> stoi(s.substr(<span class="hljs-number">0</span>, idx));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getLastB</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> idx = s.size() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (s[idx] != <span class="hljs-string">&#x27; &#x27;</span>) idx--;<br>    <span class="hljs-keyword">return</span> stoi(s.substr(idx + <span class="hljs-number">1</span>));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getMidB</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = s.find(<span class="hljs-string">&quot;and&quot;</span>) + <span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">int</span> right = left;<br>    <span class="hljs-keyword">while</span> (s[right] != <span class="hljs-string">&#x27; &#x27;</span>) right++;<br>    <span class="hljs-keyword">return</span> stoi(s.substr(left, right - left));<br>&#125;<br><br><span class="hljs-comment">// 从根结点开始获取val值为n的结点</span><br><span class="hljs-function">TreeNode* <span class="hljs-title">getNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-built_in">stack</span>&lt;TreeNode*&gt; st;<br>    st.push(root);<br>    TreeNode* node;<br>    <span class="hljs-keyword">while</span> (!st.empty()) &#123;<br>        node = st.top();<br>        <span class="hljs-keyword">if</span> (node-&gt;val == n) <span class="hljs-keyword">return</span> node;<br>        st.pop();<br>        <span class="hljs-keyword">if</span> (node-&gt;right) st.push(node-&gt;right);<br>        <span class="hljs-keyword">if</span> (node-&gt;left) st.push(node-&gt;left);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isParent</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>    TreeNode* node = getNode(b);<br>    <span class="hljs-keyword">return</span> node-&gt;parent-&gt;val == a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSiblings</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>    TreeNode* node = getNode(b);<br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">NULL</span> || node-&gt;siblings-&gt;val != a) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSameDepth</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> getNode(a)-&gt;depth == getNode(b)-&gt;depth;<br>&#125;<br><br><span class="hljs-comment">// 从给定的结点作为根结点，返回其子树中val为n的结点</span><br><span class="hljs-function">TreeNode* <span class="hljs-title">getNode2</span><span class="hljs-params">(TreeNode* substree, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (substree == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-built_in">stack</span>&lt;TreeNode*&gt; st;<br>    st.push(substree);<br>    TreeNode* node;<br>    <span class="hljs-keyword">while</span> (!st.empty()) &#123;<br>        node = st.top();<br>        <span class="hljs-keyword">if</span> (node-&gt;val == n) <span class="hljs-keyword">return</span> node;<br>        st.pop();<br>        <span class="hljs-keyword">if</span> (node-&gt;right) st.push(node-&gt;right);<br>        <span class="hljs-keyword">if</span> (node-&gt;left) st.push(node-&gt;left);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isLeftTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>    TreeNode* node = getNode(b);<br>    <span class="hljs-keyword">return</span> getNode2(node-&gt;left, a) != <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isRightTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>    TreeNode* node = getNode(b);<br>    <span class="hljs-keyword">return</span> getNode2(node-&gt;right, a) != <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    postorder.resize(n);<br>    inorder.resize(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) <span class="hljs-built_in">cin</span> &gt;&gt; postorder[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) <span class="hljs-built_in">cin</span> &gt;&gt; inorder[i];<br>    root = create(<span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">int</span> m;<br>    <span class="hljs-built_in">string</span> s;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; m;<br>    getchar();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        getline(<span class="hljs-built_in">cin</span>, s);<br>        <span class="hljs-keyword">if</span> (s.find(<span class="hljs-string">&quot;root&quot;</span>) != s.npos) &#123; <span class="hljs-comment">// 找到根结点操作</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, getA(s) == postorder[n - <span class="hljs-number">1</span>] ? <span class="hljs-string">&quot;Yes&quot;</span> : <span class="hljs-string">&quot;No&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.find(<span class="hljs-string">&quot;siblings&quot;</span>) != s.npos) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, isSiblings(getA(s), getMidB(s)) ? <span class="hljs-string">&quot;Yes&quot;</span> : <span class="hljs-string">&quot;No&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.find(<span class="hljs-string">&quot;parent&quot;</span>) != s.npos) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, isParent(getA(s), getLastB(s)) ? <span class="hljs-string">&quot;Yes&quot;</span> : <span class="hljs-string">&quot;No&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.find(<span class="hljs-string">&quot;left&quot;</span>) != s.npos) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, isLeftTree(getA(s), getLastB(s)) ? <span class="hljs-string">&quot;Yes&quot;</span> : <span class="hljs-string">&quot;No&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.find(<span class="hljs-string">&quot;right&quot;</span>) != s.npos) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, isRightTree(getA(s), getLastB(s)) ? <span class="hljs-string">&quot;Yes&quot;</span> : <span class="hljs-string">&quot;No&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.find(<span class="hljs-string">&quot;level&quot;</span>) != s.npos) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, isSameDepth(getA(s), getMidB(s)) ? <span class="hljs-string">&quot;Yes&quot;</span> : <span class="hljs-string">&quot;No&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.find(<span class="hljs-string">&quot;full&quot;</span>) != s.npos) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, isFullBinaryTree ? <span class="hljs-string">&quot;Yes&quot;</span> : <span class="hljs-string">&quot;No&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://segmentfault.com/a/1190000038350501">7-1 Sexy Primes (20分)</a></li><li><a href="https://segmentfault.com/a/1190000038350861">7-2 Anniversary (25分)</a></li><li><a href="https://segmentfault.com/a/1190000038352553">7-3 Telefraud Detection (25分)</a></li><li><a href="https://segmentfault.com/a/1190000038352797">7-4 Structure of a Binary Tree (30分)</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1052. 爱生气的书店老板</title>
    <link href="/2021/02/23/1052-%E7%88%B1%E7%94%9F%E6%B0%94%E7%9A%84%E4%B9%A6%E5%BA%97%E8%80%81%E6%9D%BF/"/>
    <url>/2021/02/23/1052-%E7%88%B1%E7%94%9F%E6%B0%94%E7%9A%84%E4%B9%A6%E5%BA%97%E8%80%81%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="1052-爱生气的书店老板"><a href="#1052-爱生气的书店老板" class="headerlink" title="1052. 爱生气的书店老板"></a><a href="https://leetcode-cn.com/problems/grumpy-bookstore-owner/">1052. 爱生气的书店老板</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/38mmyS.png" alt="38mmyS"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题可以使用 <strong>滑动窗口</strong>和<strong>暴力法</strong>来实现。</p><blockquote><p>暴力会超时，所以使用滑动窗口，暴力法放在最后面</p></blockquote><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>先记录所有满意的客户，再设置一个大小为X的滑动窗口，依次滑动该窗口，找到里面因为老板愤怒而不满意的用户，将这类用户成为<em>回心转意的用户</em>，使用<code>back</code>变量表示，该类用户数量最多的窗口即是使用X的最佳时间。所以最后将该类用户和之前就满意的用户累加起来就是结果了。</p><p>代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSatisfied</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; customers, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; grumpy, <span class="hljs-keyword">int</span> X)</span> </span>&#123;<br>        <span class="hljs-comment">// 暴力法，依次遍历，使用技能时间从0-0+x, 1-1+x, 2-2+x分钟，然后更新答案</span><br>        <span class="hljs-keyword">int</span> n = customers.size();<br>        <span class="hljs-comment">// 1+1+1+1+7+5 = 16</span><br>        <span class="hljs-keyword">int</span> back = <span class="hljs-number">-1</span>; <span class="hljs-comment">// 回心转意的人数</span><br>        <span class="hljs-keyword">int</span> left, right;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 满意的顾客数量</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) <span class="hljs-keyword">if</span> (grumpy[i] == <span class="hljs-number">0</span>) sum += customers[i];<br>        <span class="hljs-comment">// 求在滑动窗口内的挽回的生气人数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i + X &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">int</span> temp = <span class="hljs-number">0</span>;<br>            left = i;<br>            <span class="hljs-keyword">while</span> (left &lt; i + X) &#123;<br>                <span class="hljs-keyword">if</span> (grumpy[left]) temp += customers[left];<br>                left++;<br>            &#125;<br>            back = max(back, temp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> back + sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h3><p>依次从0开始，计算0-0+x，1-1+x… n-n+x 使用X技能的时候顾客数量，最后取最大值。</p><p>代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSatisfied</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; customers, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; grumpy, <span class="hljs-keyword">int</span> X)</span> </span>&#123;<br>        <span class="hljs-comment">// 暴力法，依次遍历，使用技能时间从0-0+x, 1-1+x, 2-2+x分钟，然后更新答案</span><br>        <span class="hljs-keyword">int</span> n = customers.size();<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">int</span> left, right;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i + X &lt;= n; i++) &#123;<br>            <span class="hljs-comment">// 计算i-i+x使用了技能的时候最多人数</span><br>            <span class="hljs-keyword">int</span> temp = <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// 先计算到i的人数</span><br>            left = <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// 计算到达i的这部分满意的人数</span><br>            <span class="hljs-keyword">while</span> (left &lt; i) &#123;<br>                <span class="hljs-keyword">if</span> (grumpy[left] == <span class="hljs-number">0</span>) temp += customers[left];<br>                left++;<br>            &#125;<br>            <span class="hljs-comment">// 使用技能的人数</span><br>            <span class="hljs-keyword">while</span> (left &lt; i + X) &#123;<br>                temp += customers[left++];<br>            &#125;<br>            <span class="hljs-comment">// 最后达到目的地时候</span><br>            <span class="hljs-keyword">while</span> (left &lt; n) &#123;<br>                <span class="hljs-keyword">if</span> (grumpy[left] == <span class="hljs-number">0</span>) temp += customers[left];<br>                left++;<br>            &#125;<br>            ans = max(ans, temp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Professional Ability Test (30分)</title>
    <link href="/2021/02/22/Professional-Ability-Test-30%E5%88%86/"/>
    <url>/2021/02/22/Professional-Ability-Test-30%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Professional-Ability-Test-30分"><a href="#Professional-Ability-Test-30分" class="headerlink" title="Professional Ability Test (30分)"></a>Professional Ability Test (30分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/99ea0421cbe345a9b3e12ead6f7cc4b5.png" alt="99ea0421cbe345a9b3e12ead6f7cc4b5"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>题目大意</p><p>PAT考试是一系列科目考试。过B之前必须过A（A的分数不能低于S）。通过A考试，可以得到D元代金券用来参加B考试。</p><blockquote><p>后面这部分没看懂。</p></blockquote><p>输入</p><p>正整数N（考试数量），M（前置要求关系？？）。接下来是M行，每行描述如下</p><blockquote><p>T1 T2 S D</p></blockquote><p><code>T1, T2</code>是考试的下标（下标范围0-N-1）。<code>S</code>是通过<code>T1</code>的最低分数，<code>D</code>是代金<br>券。</p><p>接下来是个正整数K，K个考试查询。</p><p>输出</p><blockquote><p>找到分数最小的参加考试，否则找到代金券最少的</p></blockquote><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>在网上看了别人的解析后，发现本题就是考查 <strong>是否存在环</strong>和<strong>求从入度为0开始的结点到各个结点的最短路径</strong></p><p>是否存在环使用 <strong>拓扑排序</strong> 判断。</p><p>拓扑排序判断环代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> n, m;<br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">inDegree</span><span class="hljs-params">(n)</span></span>;<br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">G</span><span class="hljs-params">(n)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isTopoSort</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br><span class="hljs-keyword">if</span> (inDegree[i] == <span class="hljs-number">0</span>) q.push(i);<br>&#125;<br><br><span class="hljs-keyword">while</span> (!q.empty()) &#123;<br><span class="hljs-keyword">int</span> node = q.front();<br>q.pop();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; G[node].size(); i++) &#123;<br><span class="hljs-keyword">if</span>(--inDegree[G[node][i]] == <span class="hljs-number">0</span>) q.push(G[node][i]);<br>&#125;<br>num++; <span class="hljs-comment">// 统计加入拓扑排序中的点</span><br>&#125;<br><span class="hljs-comment">// 如果所有的点加入了拓扑排序，证明没有环</span><br><span class="hljs-keyword">if</span> (num == n) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来是寻找最短路径，从入度为0的结点出发。从下面的草稿中可以看出来，起点（入度为0）有两个，分别是0，3. 所以我们需要分别从0和3开始求最短路径。</p><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/xBawpi.png" alt="xBawpi"></p><p>分别求出各个入口的最短路径（在拓扑排序的时候可以将起点保存在<code>enterPoint</code>）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 进行最短路径求解</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; enterPoint.size(); i++)<br>&#123;<br>Dijkstra(enterPoint[i]);<br>&#125;<br></code></pre></td></tr></table></figure><p>求最短路径使用<code>Dijkstra</code></p><blockquote><p>可以使用<code>Dijkstra</code>或者<code>回溯</code>来求最短路径。这里使用<code>Dijkstra</code>来计算最短路径。首先是满足<code>minimum total S</code>,然后再满足<code>maximum total vouchers</code>。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// scores 存储多条最小的分数</span><br><span class="hljs-comment">// vouchers 存储多条最大的奖券</span><br><span class="hljs-comment">// path 存储多条满足条件的路径</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; scores, vouchers, path;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;int&gt; temps(n, MAX), tempv(n, -1), tempp(n);<br>    fill(visited.begin(), visited.end(), <span class="hljs-literal">false</span>);<br>    temps[start] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 自己到自己的分数是0</span><br>    tempv[start] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 自己到自己的奖券是0</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        tempp[i] = i;<br>    <span class="hljs-built_in">priority_queue</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt;, greater&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt;&gt; pq;<br>    pq.push(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">0</span>, start));<br>    <span class="hljs-keyword">while</span> (!pq.empty())<br>    &#123;<br>        <span class="hljs-keyword">int</span> u = pq.top().second;<br>        pq.pop();<br>        <span class="hljs-keyword">if</span> (visited[u])<br>            <span class="hljs-keyword">continue</span>;<br>        visited[u] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; Score[u].size(); i++)<br>        &#123;<br>            <span class="hljs-keyword">int</span> v = Score[u][i].first;<br>            <span class="hljs-keyword">if</span> (!visited[v])<br>            &#123;<br>                <span class="hljs-keyword">if</span> (temps[u] + Score[u][i].second &lt; temps[v])<br>                &#123;<br>                    temps[v] = temps[u] + Score[u][i].second;<br>                    tempv[v] = tempv[u] + Voucher[u][i].second;<br>                    tempp[v] = u;<br>                    pq.push(<span class="hljs-built_in">make_pair</span>(temps[v], v));<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (temps[u] + Score[u][i].second == temps[v] &amp;&amp; tempv[v] &lt; tempv[u] + Voucher[u][i].second)<br>                &#123;<br>                    tempv[v] = tempv[u] + Voucher[u][i].second;<br>                    tempp[v] = u;<br>                    pq.push(<span class="hljs-built_in">make_pair</span>(temps[v], v));<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">// 添加到集合中</span><br>    scores.push_back(temps);<br>    vouchers.push_back(tempv);<br>    path.push_back(tempp);<br>&#125;<br></code></pre></td></tr></table></figure><p>最后在根据题目意思，比较<code>s,d</code>。找到满足条件的路径在哪里，使用DFS进行输出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 找到最佳路径所在的下标</span><br><span class="hljs-keyword">int</span> minS = MAX;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; enterPoint.size(); i++)<br>&#123;<br><span class="hljs-keyword">if</span> (scores[i][t] &lt; minS)<br>&#123;<br>minS = scores[i][t];<br>ansIdx = i;<br>&#125;<br>&#125;<br><span class="hljs-keyword">int</span> maxV = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; enterPoint.size(); i++)<br>&#123;<br><span class="hljs-keyword">if</span> (scores[i][t] == minS &amp;&amp; vouchers[i][t] &gt; maxV)<br>&#123;<br>maxV = vouchers[i][t];<br>ansIdx = i;<br>&#125;<br>&#125;<br>dfs(t);<br></code></pre></td></tr></table></figure><p>使用DFS后续输出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 遍历输出满足条件的路径</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (p == enterPoint[ansIdx])<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d-&gt;&quot;</span>, p);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    dfs(path[ansIdx][p]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, p);<br>    <span class="hljs-keyword">if</span> (p != t) <span class="hljs-comment">// 最后一个点不用打印 -&gt;</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-&gt;&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">987654321</span>;<br><br><span class="hljs-keyword">int</span> n, m, q, t;<br><span class="hljs-keyword">int</span> t1, t2, s, d;<br><span class="hljs-keyword">int</span> ansIdx = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt;&gt; Score, Voucher; <span class="hljs-comment">// s图和V图</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; scores, vouchers, path;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt; visited;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; inDegree, enterPoint;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Score.resize(n);<br>    Voucher.resize(n);<br>    visited.resize(n);<br>    inDegree.resize(n, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isTopoSort</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>; <span class="hljs-comment">// 进入拓扑排序的数量</span><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; tempInDegree = inDegree;<br>    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (tempInDegree[i] == <span class="hljs-number">0</span>)<br>        &#123;<br>            enterPoint.push_back(i);<br>            q.push(i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (!q.empty())<br>    &#123;<br>        <span class="hljs-keyword">int</span> node = q.front();<br>        q.pop();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; Score[node].size(); i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (--tempInDegree[Score[node][i].first] == <span class="hljs-number">0</span>)<br>                q.push(Score[node][i].first);<br>        &#125;<br>        num++;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (num == n)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;int&gt; temps(n, MAX), tempv(n, -1), tempp(n);<br>    <span class="hljs-comment">// 初始化所有参数</span><br>    fill(visited.begin(), visited.end(), <span class="hljs-literal">false</span>);<br>    temps[start] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 自己到自己的分数是0</span><br>    tempv[start] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 自己到自己的奖券是0</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        tempp[i] = i;<br>    <span class="hljs-built_in">priority_queue</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt;, greater&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt;&gt; pq;<br>    pq.push(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">0</span>, start));<br>    <span class="hljs-keyword">while</span> (!pq.empty())<br>    &#123;<br>        <span class="hljs-keyword">int</span> u = pq.top().second;<br>        pq.pop();<br>        <span class="hljs-keyword">if</span> (visited[u])<br>            <span class="hljs-keyword">continue</span>;<br>        visited[u] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; Score[u].size(); i++)<br>        &#123;<br>            <span class="hljs-keyword">int</span> v = Score[u][i].first;<br>            <span class="hljs-keyword">if</span> (!visited[v])<br>            &#123;<br>                <span class="hljs-keyword">if</span> (temps[u] + Score[u][i].second &lt; temps[v])<br>                &#123;<br>                    temps[v] = temps[u] + Score[u][i].second;<br>                    tempv[v] = tempv[u] + Voucher[u][i].second;<br>                    tempp[v] = u;<br>                    pq.push(<span class="hljs-built_in">make_pair</span>(temps[v], v));<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (temps[u] + Score[u][i].second == temps[v] &amp;&amp; tempv[v] &lt; tempv[u] + Voucher[u][i].second)<br>                &#123;<br>                    tempv[v] = tempv[u] + Voucher[u][i].second;<br>                    tempp[v] = u;<br>                    pq.push(<span class="hljs-built_in">make_pair</span>(temps[v], v));<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    scores.push_back(temps);<br>    vouchers.push_back(tempv);<br>    path.push_back(tempp);<br>&#125;<br><br><span class="hljs-comment">// 遍历输出满足条件的路径</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (p == enterPoint[ansIdx])<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d-&gt;&quot;</span>, p);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    dfs(path[ansIdx][p]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, p);<br>    <span class="hljs-keyword">if</span> (p != t) <span class="hljs-comment">// 最后一个点不用打印 -&gt;</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-&gt;&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br>    init();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>    &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; t1 &gt;&gt; t2 &gt;&gt; s &gt;&gt; d;<br>        inDegree[t2]++; <span class="hljs-comment">// 入度+1</span><br>        Score[t1].push_back(<span class="hljs-built_in">make_pair</span>(t2, s));<br>        Voucher[t1].push_back(<span class="hljs-built_in">make_pair</span>(t2, d));<br>    &#125;<br>    <span class="hljs-keyword">bool</span> isTopo = isTopoSort();<br>    <span class="hljs-keyword">if</span> (isTopo)<br>    &#123;<br>        <span class="hljs-comment">// 进行最短路径求解</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; enterPoint.size(); i++)<br>        &#123;<br>            Dijkstra(enterPoint[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s</span><br><span class="hljs-string">&quot;</span>, isTopo ? <span class="hljs-string">&quot;Okay.&quot;</span> : <span class="hljs-string">&quot;Impossible.&quot;</span>);<br>    <span class="hljs-built_in">cin</span> &gt;&gt; q;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; q; i++)<br>    &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; t;<br>        <span class="hljs-keyword">if</span> (isTopo)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (inDegree[t] == <span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;You may take test %d directly.</span><br><span class="hljs-string">&quot;</span>, t);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-comment">// 找到最佳路径所在的下标</span><br>                <span class="hljs-keyword">int</span> minS = MAX;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; enterPoint.size(); i++)<br>                &#123;<br>                    <span class="hljs-keyword">if</span> (scores[i][t] &lt; minS)<br>                    &#123;<br>                        minS = scores[i][t];<br>                        ansIdx = i;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">int</span> maxV = <span class="hljs-number">-1</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; enterPoint.size(); i++)<br>                &#123;<br>                    <span class="hljs-keyword">if</span> (scores[i][t] == minS &amp;&amp; vouchers[i][t] &gt; maxV)<br>                    &#123;<br>                        maxV = vouchers[i][t];<br>                        ansIdx = i;<br>                    &#125;<br>                &#125;<br>                dfs(t);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;</span><br><span class="hljs-string">&quot;</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (inDegree[t] == <span class="hljs-number">0</span>)<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;You may take test %d directly.</span><br><span class="hljs-string">&quot;</span>, t);<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error.</span><br><span class="hljs-string">&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>这道题花了2个多小时才写出来。思路其实不难，就是题目没看懂😭。</p>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>Dijkstra</tag>
      
      <tag>最短路径</tag>
      
      <tag>拓扑排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>How Many Ways to Buy a Piece of Land (25)</title>
    <link href="/2021/02/22/How-Many-Ways-to-Buy-a-Piece-of-Land-25/"/>
    <url>/2021/02/22/How-Many-Ways-to-Buy-a-Piece-of-Land-25/</url>
    
    <content type="html"><![CDATA[<h1 id="How-Many-Ways-to-Buy-a-Piece-of-Land-25"><a href="#How-Many-Ways-to-Buy-a-Piece-of-Land-25" class="headerlink" title="How Many Ways to Buy a Piece of Land (25)"></a>How Many Ways to Buy a Piece of Land (25)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/M2EwJZ.png" alt="M2EwJZ"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>题目大意</p><p>买土地，土地连成一排，除了首尾，每块土地都连接着。你的任务是告诉顾客（有限的金钱），他有多少种购买方法。</p><p>输入</p><p>正整数N：土地数量（编号1-N）<br>正整数M：顾客拥有的钱的数量</p><p>接下来一行，N个正整数，表示第i块土地的价值。</p><blockquote><p>5 85</p><p>38 42 15 24 9</p></blockquote><p>输出</p><p>输出最后不同的方法总方案</p><blockquote><p>11</p></blockquote><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>本题考查 <strong>二分法</strong></p><p>这道题和<strong>shopping in mars</strong>很相似，也可以说几乎一样。只是那道题是等于或接近于总金额。而这道题需要将i,j范围内的值累加即可。</p><p>使用前缀和存储数据，然后使用循环每个值，找到它的右侧第一个大于<code>preSum[i] + m</code>的下标，两个值的范围即是一个解，最后累加所有的结果即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">upper_bound</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high, <span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> mid;<br>    <span class="hljs-keyword">while</span> (low &lt; high) &#123;<br>        mid = (low + high) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &gt; x) high = mid;<br>        <span class="hljs-keyword">else</span> low = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> low;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, m, val;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">preSum</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; val;<br>        preSum[i + <span class="hljs-number">1</span>] = preSum[i] + val;<br>    &#125;<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">int</span> j = upper_bound(preSum, i, n + <span class="hljs-number">1</span>, preSum[i - <span class="hljs-number">1</span>] + m)<br>        ans += j - i;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>二分法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Left-View of Binary Tree (25分)</title>
    <link href="/2021/02/21/Left-View-of-Binary-Tree-25%E5%88%86/"/>
    <url>/2021/02/21/Left-View-of-Binary-Tree-25%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Left-View-of-Binary-Tree-25分"><a href="#Left-View-of-Binary-Tree-25分" class="headerlink" title="Left-View of Binary Tree (25分)"></a>Left-View of Binary Tree (25分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/AYlv6N.png" alt="AYlv6N"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题考查 <strong>根据中序和先序遍历建树</strong>和<strong>树的层次遍历</strong></p><p>给出中序和先序遍历，创建好树后，再根据层次遍历打印出每层第一个点即可。</p><p>输入</p><blockquote><p>8</p><p>2 3 1 5 4 7 8 6</p><p>1 2 3 6 7 4 5 8</p></blockquote><p>输出</p><blockquote><p>1 2 3 4 5</p></blockquote><p>根据中序和先序遍历建树</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>&#123;</span><br><span class="hljs-keyword">int</span> val;<br>TreeNode *left, *right;<br>&#125;;<br><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; inorder, preorder;<br><br><span class="hljs-function">TreeNode* <span class="hljs-title">create</span><span class="hljs-params">(<span class="hljs-keyword">int</span> preL, <span class="hljs-keyword">int</span> preR, <span class="hljs-keyword">int</span> inL, <span class="hljs-keyword">int</span> inR)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (preL &gt; preR) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>TreeNode* root = <span class="hljs-keyword">new</span> TreeNode;<br>root-&gt;val = preorder[preL]; <span class="hljs-comment">// 找到根结点</span><br><span class="hljs-keyword">int</span> mid = <span class="hljs-number">0</span>; <span class="hljs-comment">// 找到在中序遍历中的位置</span><br><span class="hljs-keyword">for</span> (mid = inL; mid &lt;= inR; mid++) &#123;<br><span class="hljs-keyword">if</span> (inorder[mid] == preorder[preL]) <span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">int</span> offset = mid - inL;<br>root-&gt;left = create(preL + <span class="hljs-number">1</span>, preL + offset, inL, mid - <span class="hljs-number">1</span>);<br>root-&gt;right = create(preL + offset + <span class="hljs-number">1</span>, preR, mid + <span class="hljs-number">1</span>, inR);<br><span class="hljs-keyword">return</span> root;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>接下来是层次遍历该二叉树</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans;<br><span class="hljs-built_in">queue</span>&lt;TreeNode*&gt; q;<br>q.push(root);<br>TreeNode* node;<br><span class="hljs-keyword">while</span> (!q.empty()) &#123;<br><span class="hljs-keyword">int</span> size = q.size();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>node = q.front();<br><span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) ans.push_back(node-&gt;val);<br>q.pop();<br><span class="hljs-keyword">if</span> (node-&gt;left) q.push(node-&gt;left);<br><span class="hljs-keyword">if</span> (node-&gt;right) q.push(node-&gt;right);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ans.size(); i++) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ans[i]);<br><span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt; ans.size()) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>&#123;</span><br><span class="hljs-keyword">int</span> val;<br>TreeNode *left, *right;<br>&#125;;<br><br><span class="hljs-keyword">int</span> n;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; inorder, preorder;<br><br><span class="hljs-function">TreeNode* <span class="hljs-title">create</span><span class="hljs-params">(<span class="hljs-keyword">int</span> preL, <span class="hljs-keyword">int</span> preR, <span class="hljs-keyword">int</span> inL, <span class="hljs-keyword">int</span> inR)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (preL &gt; preR) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>TreeNode* root = <span class="hljs-keyword">new</span> TreeNode;<br>root-&gt;val = preorder[preL]; <span class="hljs-comment">// 找到根结点</span><br><span class="hljs-keyword">int</span> mid = <span class="hljs-number">0</span>; <span class="hljs-comment">// 找到在中序遍历中的位置</span><br><span class="hljs-keyword">for</span> (mid = inL; mid &lt;= inR; mid++) &#123;<br><span class="hljs-keyword">if</span> (inorder[mid] == preorder[preL]) <span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">int</span> offset = mid - inL; <span class="hljs-comment">// 2</span><br>root-&gt;left = create(preL + <span class="hljs-number">1</span>, preL + offset, inL, mid - <span class="hljs-number">1</span>);<br>root-&gt;right = create(preL + offset + <span class="hljs-number">1</span>, preR, mid + <span class="hljs-number">1</span>, inR);<br><span class="hljs-keyword">return</span> root;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans;<br><span class="hljs-built_in">queue</span>&lt;TreeNode*&gt; q;<br>q.push(root);<br>TreeNode* node;<br><span class="hljs-keyword">while</span> (!q.empty()) &#123;<br><span class="hljs-keyword">int</span> size = q.size();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>node = q.front();<br><span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) ans.push_back(node-&gt;val);<br>q.pop();<br><span class="hljs-keyword">if</span> (node-&gt;left) q.push(node-&gt;left);<br><span class="hljs-keyword">if</span> (node-&gt;right) q.push(node-&gt;right);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ans.size(); i++) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ans[i]);<br><span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt; ans.size()) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    inorder.resize(n);<br>    preorder.resize(n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<span class="hljs-built_in">cin</span> &gt;&gt; inorder[i];&#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<span class="hljs-built_in">cin</span> &gt;&gt; preorder[i];&#125;<br><br>    TreeNode *root = create(<span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    bfs(root);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>bfs</tag>
      
      <tag>中序遍历</tag>
      
      <tag>先序遍历</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1048 Find Coins (25 分)</title>
    <link href="/2021/02/21/1048-Find-Coins-25-%E5%88%86/"/>
    <url>/2021/02/21/1048-Find-Coins-25-%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1048-Find-Coins-25-分"><a href="#1048-Find-Coins-25-分" class="headerlink" title="1048 Find Coins (25 分)"></a>1048 Find Coins (25 分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/kDzhbH.png" alt="kDzhbH"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题考查 <strong>双指针</strong>和<strong>二分法</strong></p><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p>先将数组排序，再设置<code>i,j</code>分别指向首尾。当<code>nums[i] + nums[j] &gt; m</code>的时候，证明<code>nums[j]</code>过大，<code>j</code>应当左移，当<code>nums[i] + nums[j] &lt; m</code>的时候，证明<code>nums[i]</code>过小，<code>i</code>右移。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">// 找到第一个大于等于x的值</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lower_bound</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high, <span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> mid;<br>    <span class="hljs-keyword">while</span> (low &lt; high) &#123;<br>        mid = (low + high) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &gt;= x) high = mid;<br>        <span class="hljs-keyword">else</span> low = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> low;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, m;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">nums</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) <span class="hljs-built_in">cin</span> &gt;&gt; nums[i];<br>    sort(nums.begin(), nums.end());<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = n - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] + nums[j] == m) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, nums[i], nums[j]);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] + nums[j] &gt; m) j--;<br>        <span class="hljs-keyword">else</span> i++;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No Solution\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><p>也是先将数组排序，然后进行一次遍历，每次找到<code>i</code>和<code>i</code>的左侧大于等于<code>m - nums[i]</code>的<code>j</code>值。若满足则输出，否则寻找下一个<code>i</code>对应的<code>j</code>。</p><p>找到第一个大于等于<code>x</code>值的代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 找到第一个大于等于x的值</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lower_bound</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high, <span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> mid;<br>    <span class="hljs-keyword">while</span> (low &lt; high) &#123;<br>        mid = (low + high) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &gt;= x) high = mid;<br>        <span class="hljs-keyword">else</span> low = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> low;<br>&#125;<br></code></pre></td></tr></table></figure><p>本题注意：如果只有一枚硬币，是无法满足条件中必须支付两枚硬币的条件，因此需要输出<code>No Solution</code></p><p>最终代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">// 找到第一个大于等于x的值</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lower_bound</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high, <span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> mid;<br>    <span class="hljs-keyword">while</span> (low &lt; high) &#123;<br>        mid = (low + high) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &gt;= x) high = mid;<br>        <span class="hljs-keyword">else</span> low = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> low;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, m;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">nums</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) <span class="hljs-built_in">cin</span> &gt;&gt; nums[i];<br>    sort(nums.begin(), nums.end());<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 考虑为1的情况</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No Solution\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">int</span> j = lower_bound(nums, i + <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>, m - nums[i]);<br>        <span class="hljs-keyword">if</span> (nums[i] + nums[j] == m) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, nums[i], nums[j]);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No Solution\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>双指针</tag>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分法查找模板</title>
    <link href="/2021/02/21/%E4%BA%8C%E5%88%86%E6%B3%95%E6%9F%A5%E6%89%BE%E6%A8%A1%E6%9D%BF/"/>
    <url>/2021/02/21/%E4%BA%8C%E5%88%86%E6%B3%95%E6%9F%A5%E6%89%BE%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="二分法查找模板"><a href="#二分法查找模板" class="headerlink" title="二分法查找模板"></a>二分法查找模板</h1><p>二分查找的几种写法，如下图所示（图来源自<a href="https://www.zhihu.com/question/36132386">二分查找有几种写法？它们的区别是什么？</a>）</p><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/bAVsUI.jpg" alt="bAVsUI"></p><p>主要分成5种</p><ol><li><p>正好等于给出的<code>value</code>的位置</p></li><li><p>第一个大于等于<code>value</code>的值的位置，即<code>value</code>的下界(红色箭头表示)</p></li><li><p>第一个大于<code>value</code>的值的位置（蓝色箭头表示）</p></li><li><p>最后一个等于<code>value</code>的值的位置，即<code>value</code>的上界（第二黑色箭头表示）</p></li><li><p>第一个小于<code>value</code>的值的位置（第一个黑色箭头表示）</p></li></ol><p>接下来分别对5种进行介绍</p><h2 id="正好等于value值的位置"><a href="#正好等于value值的位置" class="headerlink" title="正好等于value值的位置"></a>正好等于<code>value</code>值的位置</h2><p>这一类是最常见，也是最简单的二分查找。</p><p>该查找需要注意下面几点：</p><ol><li>查找区间在 **[left, right]**，下面例子中的区间是<code>[0, n-1]</code></li><li>循环停止条件是<code>left &lt;= right</code></li></ol><p>代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = nums.size() - <span class="hljs-number">1</span>, mid;<br>  <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>    mid = left + ((right - left) &gt;&gt; <span class="hljs-number">1</span>); <span class="hljs-comment">// 防止溢出</span><br>    <span class="hljs-keyword">if</span> (nums[mid] == value) <span class="hljs-keyword">return</span> mid;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; value) right = mid - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> left = mid + <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第一个大于等于value的值的位置"><a href="#第一个大于等于value的值的位置" class="headerlink" title="第一个大于等于value的值的位置"></a>第一个大于等于<code>value</code>的值的位置</h2><p>这里其实就是实现C++的<code>lower_bound</code>的方法。因为<code>lower_bound</code>是一个<strong>左闭右开</strong>的区间，看了很多人的写法，发现各种写法都有，最后个人认为使用<strong>左闭右开</strong>的方法是最简单的。</p><p>为什么要<strong>左闭右开</strong>呢？因为要找第一个大于或等于<code>value</code>的值的位置，假如一个数组的区间是<code>[0, n-1]</code>，如果这个值不在数组所在的区间内，那么一定是在数组的区间的最后一个位置+1，即<code>n</code>这个位置。二分查找种，<code>left,right</code>表示的就是可能的返回值，所以采用<code>[0,n)</code>(证明能取到<code>n</code>)这种方法，就比较简单，不需要判断是否越界。</p><p>该写法需要注意</p><ol><li>搜索区间是 <strong>左闭右开</strong>，下面例子中是<code>[0, n)</code></li><li>循环终止的条件是 <code>left &lt; right</code>， 和上面的[正好等于<code>value</code>值的位置](## 第一个大于等于<code>value</code>的值的位置)</li></ol><p>代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lower_bound</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = nums.size(), mid;<br>  <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>    mid = left + ((right - left) &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (nums[mid] &gt;= value) right = mid; <span class="hljs-comment">// 第一个大于value的值的位置可能在左侧区间</span><br>    <span class="hljs-keyword">else</span> left = mid + <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> left;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第一个大于value的值的位置"><a href="#第一个大于value的值的位置" class="headerlink" title="第一个大于value的值的位置"></a>第一个大于<code>value</code>的值的位置</h2><p>这里是实现C++中的<code>upper_bound</code>方法，也是采用<strong>左闭右开</strong>区间。</p><p>代码和上面基本类似，只需要将<code>if (nums[mid] &gt;= value)</code>改成<code>if (nums[mid] &gt; value)</code></p><p>代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">upper_bound</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = nums.size(), mid;<br>  <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>    mid = left + ((right - left) &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (nums[mid] &gt; value) right = mid; <span class="hljs-comment">// 第一个大于value的值的位置可能在左侧区间</span><br>    <span class="hljs-keyword">else</span> left = mid + <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> left;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="最后一个等于value的值的位置"><a href="#最后一个等于value的值的位置" class="headerlink" title="最后一个等于value的值的位置"></a>最后一个等于<code>value</code>的值的位置</h2><p>在C++中，只提供了<code>lower_bound, upper_bound</code>。为什么没有提供求最后一个等于<code>value</code>值的位置呢？其实只需要使用<code>upper_bound</code>找到第一个大于<code>value</code>的位置，再<code>-1</code>就找到了最后一个等于<code>value</code>值的位置了。</p><p>代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findLastPos</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> upper_bound(nums, value) - <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">upper_bound</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = nums.size(), mid;<br>  <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>    mid = left + ((right - left) &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (nums[mid] &gt; value) right = mid; <span class="hljs-comment">// 第一个大于value的值的位置可能在左侧区间</span><br>    <span class="hljs-keyword">else</span> left = mid + <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> left;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第一个小于value的值的位置"><a href="#第一个小于value的值的位置" class="headerlink" title="第一个小于value的值的位置"></a>第一个小于<code>value</code>的值的位置</h2><p>思路也是和<a href="##%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E7%AD%89%E4%BA%8E%60value%60%E7%9A%84%E5%80%BC%E7%9A%84%E4%BD%8D%E7%BD%AE">最后一个等于<code>value</code>的值的位置</a>一样，使用<code>lower_bound</code>获得第一个大于等于<code>value</code>值的位置，然后<code>-1</code>。</p><p>代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findFirstPos</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> lower_bound(nums, value) - <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">upper_bound</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = nums.size(), mid;<br>  <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>    mid = left + ((right - left) &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (nums[mid] &gt; value) right = mid; <span class="hljs-comment">// 第一个大于value的值的位置可能在左侧区间</span><br>    <span class="hljs-keyword">else</span> left = mid + <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> left;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1438. 绝对差不超过限制的最长连续子数组</title>
    <link href="/2021/02/21/1438-%E7%BB%9D%E5%AF%B9%E5%B7%AE%E4%B8%8D%E8%B6%85%E8%BF%87%E9%99%90%E5%88%B6%E7%9A%84%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <url>/2021/02/21/1438-%E7%BB%9D%E5%AF%B9%E5%B7%AE%E4%B8%8D%E8%B6%85%E8%BF%87%E9%99%90%E5%88%B6%E7%9A%84%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="1438-绝对差不超过限制的最长连续子数组"><a href="#1438-绝对差不超过限制的最长连续子数组" class="headerlink" title="1438. 绝对差不超过限制的最长连续子数组"></a><a href="https://leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/">1438. 绝对差不超过限制的最长连续子数组</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/GcE882.png" alt="GcE882"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题考查 <strong>滑动窗口</strong>。</p><p>其实本题需要一直维护窗口内的最大值和最小值。因此可以设置两个参数表示窗口内的最大值和最小值，并且每次移动都更新这两个值。</p><p>使用<code>left, right</code>表示窗口的范围，<code>maxVal, minVal</code>表示窗口内的最大值和最小值</p><ul><li>若最大值和最小值的差值小于等于<code>limit</code>，<code>right++</code>,同时更新最大最小值。</li><li>若最大值和最小值的差大于<code>limit</code>, <code>left++</code>,同时<code>right</code>重新从<code>left</code>出发，最大值和最小值更新成<code>nums[left]</code></li></ul><h3 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestSubarray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> limit)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>, n = nums.size();<br>        <span class="hljs-keyword">int</span> maxVal = nums[left], minVal = nums[right];<br>        <span class="hljs-keyword">while</span> (left &lt; n &amp;&amp; right &lt; n) &#123;<br>            <span class="hljs-keyword">while</span> (right &lt; n &amp;&amp; maxVal - minVal &lt;= limit) &#123;<br>                right++; <span class="hljs-comment">// 更新最大值和最小值</span><br>                <span class="hljs-keyword">if</span> (right &lt; n &amp;&amp; maxVal &lt; nums[right]) &#123;<br>                    maxVal = nums[right];<br>                &#125;<br>                <span class="hljs-keyword">if</span> (right &lt; n &amp;&amp; minVal &gt; nums[right]) &#123;<br>                    minVal = nums[right];<br>                &#125;<br>            &#125;<br>            ans = max(ans, right - left);<br>right = ++left; <span class="hljs-comment">// 重新出发</span><br>            maxVal = minVal = nums[left];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>但是上面这种方法会出现超时，看到官方题解后，发现需要使用<code>multiset</code>数据结构来维护窗口内的最大值和最小值。具体方法如下</p><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestSubarray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> limit)</span> </span>&#123;<br>        <span class="hljs-built_in">multiset</span>&lt;<span class="hljs-keyword">int</span>&gt; s;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>, n = nums.size();<br>        <span class="hljs-keyword">while</span> (left &lt; n &amp;&amp; right &lt; n) &#123;<br>            s.insert(nums[right]);<br>            <span class="hljs-keyword">while</span> (*s.rbegin() - *s.begin() &gt; limit) &#123;<br>                s.erase(s.find(nums[left++])); <span class="hljs-comment">// 删除最左边的窗口值</span><br>            &#125;<br>            ans = max(ans, right - left + <span class="hljs-number">1</span>);<br>            right++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>12. 八皇后</title>
    <link href="/2021/02/20/12-%E5%85%AB%E7%9A%87%E5%90%8E/"/>
    <url>/2021/02/20/12-%E5%85%AB%E7%9A%87%E5%90%8E/</url>
    
    <content type="html"><![CDATA[<h1 id="12-八皇后"><a href="#12-八皇后" class="headerlink" title="12. 八皇后"></a><a href="https://leetcode-cn.com/problems/eight-queens-lcci/">12. 八皇后</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/BvJRMu.png" alt="BvJRMu"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题考查 <strong>回溯</strong> 找到所有的可能。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt; ans;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt; <span class="hljs-title">solveNQueens</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">path</span><span class="hljs-params">(n, <span class="hljs-built_in">string</span>(n, <span class="hljs-string">&#x27;.&#x27;</span>))</span></span>;<br>        backtrack(n, <span class="hljs-number">0</span>, path);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isLegal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col, <span class="hljs-keyword">int</span> n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; path)</span> </span>&#123;<br>        <span class="hljs-comment">// 判断列是否有一样的</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++) &#123;<br>            <span class="hljs-keyword">if</span> (path[i][col] == <span class="hljs-string">&#x27;Q&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 判断右上角</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = row - <span class="hljs-number">1</span>, j = col - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>; i--, j--) &#123;<br>            <span class="hljs-keyword">if</span> (path[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 判断左上角</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = row - <span class="hljs-number">1</span>, j = col + <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;<br>            <span class="hljs-keyword">if</span> (path[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> row, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; path)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n == row) &#123;<br>            ans.push_back(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>; col &lt; n; col++) &#123;<br>            <span class="hljs-keyword">if</span> (isLegal(row, col, n, path)) &#123;<br>                path[row][col] = <span class="hljs-string">&#x27;Q&#x27;</span>;<br>                backtrack(n, row + <span class="hljs-number">1</span>, path);<br>                path[row][col] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>回溯算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1060 Are They Equal (25 分)</title>
    <link href="/2021/02/17/1060-Are-They-Equal-25-%E5%88%86/"/>
    <url>/2021/02/17/1060-Are-They-Equal-25-%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1060-Are-They-Equal-25-分"><a href="#1060-Are-They-Equal-25-分" class="headerlink" title="1060 Are They Equal (25 分)"></a>1060 Are They Equal (25 分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/g4Rv0Q.png" alt="g4Rv0Q"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题考查 <strong>科学计数法</strong></p><p>将字符串的小数点和最开始的0去除掉，再计算它的指数。这样比较最简单。现在将给定的字符分成两种类型。</p><ol><li>$0.a_{1}a_{2}…a_{n}$</li><li>$b_{1}b_{2}…b{n}.a_{1}a_{2}…a_{m}$</li></ol><p>针对第一种，去除最前面的0，有的用例有前面有很多0（$0000.0123$）。去除小数点前面的多余的0后，指数部分等于从小数点开始到第一个非0数字的距离的反数，比如$0.0123$的指数等于$-1$</p><p>第二种情况，同样也是把前面多余的0去除掉，指数部分等于第一个非零的数字到小数点或最后一个数字的距离。例如$00123.234$中指数等于$3$。</p><p>注意，最后如果精度（长度）不够，还需要补充0.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deal</span><span class="hljs-params">(<span class="hljs-built_in">string</span> &amp;s, <span class="hljs-keyword">int</span> &amp;e, <span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 1. 除去所有的0，和小数点。</span><br>    <span class="hljs-comment">// 先去掉前面的0</span><br>    <span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (s.length() &gt; <span class="hljs-number">0</span> &amp;&amp; s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;0&#x27;</span>)<br>        s.erase(s.begin());<br>    <span class="hljs-comment">// 去除掉0后，看是否是小数点或者是整数</span><br>    <span class="hljs-keyword">if</span> (s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;.&#x27;</span>)<br>    &#123; <span class="hljs-comment">// 如果是小数点，证明是个小于1的数字，去除后面的0</span><br>        s.erase(s.begin());<br>        <span class="hljs-keyword">while</span> (s.length() &gt; <span class="hljs-number">0</span> &amp;&amp; s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;0&#x27;</span>)<br>        &#123;<br>            s.erase(s.begin());<br>            e--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123; <span class="hljs-comment">// 大于1的数字，计算到小数点或到最后一个数（不存在小数的话）的个数</span><br>        <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (k &lt; s.length() &amp;&amp; s[k] != <span class="hljs-string">&#x27;.&#x27;</span>)<br>        &#123;<br>            k++;<br>            e++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (k &lt; s.length())<br>        &#123; <span class="hljs-comment">// 证明存在小数点，删除小数点</span><br>            s.erase(s.begin() + k);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (s.length() == <span class="hljs-number">0</span>)<br>        e = <span class="hljs-number">0</span>; <span class="hljs-comment">// 如果这个数为0的话，e=0</span><br>    <span class="hljs-keyword">if</span> (s.length() &gt; n)<br>        s.erase(s.begin() + n, s.end());<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.length() &lt; n)<br>    &#123; <span class="hljs-comment">// 不够就补充0</span><br>        <span class="hljs-keyword">int</span> k = n - s.length();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++)<br>            s += <span class="hljs-string">&#x27;0&#x27;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n, e1 = <span class="hljs-number">0</span>, e2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">string</span> s1, s2;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; s1 &gt;&gt; s2;<br>    deal(s1, e1, n);<br>    deal(s2, e2, n);<br>    <span class="hljs-keyword">if</span> (s1 == s2 &amp;&amp; e1 == e2)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;YES 0.%s*10^%d\n&quot;</span>, s1.c_str(), e1);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NO 0.%s*10^%d 0.%s*10^%d\n&quot;</span>, s1.c_str(), e1, s2.c_str(), e2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1088 Rational Arithmetic (20 分)</title>
    <link href="/2021/02/17/1088-Rational-Arithmetic-20-%E5%88%86/"/>
    <url>/2021/02/17/1088-Rational-Arithmetic-20-%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1088-Rational-Arithmetic-20-分"><a href="#1088-Rational-Arithmetic-20-分" class="headerlink" title="1088 Rational Arithmetic (20 分)"></a>1088 Rational Arithmetic (20 分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/DMhdGn.png" alt="DMhdGn"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题考查 <strong>分数四则运算、化简和输出正确格式</strong></p><p>分数四则运算可以参考 <a href="https://emhui.fun/2021/02/17/%E5%88%86%E6%95%B0%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97/">分数四则运算</a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">// 求最大公约数</span><br><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> m, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> n == <span class="hljs-number">0</span> ? m : gcd(n, m % n);<br>&#125;<br><br><span class="hljs-comment">// 分数化简</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reduction</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> &amp;m, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> &amp;n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>) &#123;<br>        m = -m;<br>        n = -n;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>) &#123;<br>        n = <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> d = gcd(<span class="hljs-built_in">abs</span>(m), <span class="hljs-built_in">abs</span>(n));<br>        m /= d;<br>        n /= d;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 打印正确格式</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">showFormat</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> m, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Inf&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    reduction(m, n); <span class="hljs-comment">// 化简</span><br>    <span class="hljs-keyword">if</span> (m &lt; <span class="hljs-number">0</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(&quot;</span>);<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, m); <span class="hljs-comment">// 整数</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(m) &gt; n) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld %lld/%lld&quot;</span>, m / n, <span class="hljs-built_in">abs</span>(m) % n, n); <span class="hljs-comment">// 假分数</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld/%lld&quot;</span>, m, n); <span class="hljs-comment">// 真分数</span><br>    <span class="hljs-keyword">if</span> (m &lt; <span class="hljs-number">0</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;)&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a, b, c, d;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld/%lld %lld/%lld&quot;</span>, &amp;a, &amp;b, &amp;c, &amp;d);<br>    showFormat(a, b); <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; + &quot;</span>); showFormat(c, d); <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; = &quot;</span>); showFormat(a * d + b * c, b * d); <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    showFormat(a, b); <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; - &quot;</span>); showFormat(c, d); <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; = &quot;</span>); showFormat(a * d - b * c, b * d); <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    showFormat(a, b); <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; * &quot;</span>); showFormat(c, d); <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; = &quot;</span>); showFormat(a * c, b * d); <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    showFormat(a, b); <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; / &quot;</span>); showFormat(c, d); <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; = &quot;</span>); showFormat(a * d, b * c); <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相似题目"><a href="#相似题目" class="headerlink" title="相似题目"></a>相似题目</h2><ul><li><a href="https://emhui.fun/2021/02/07/1081-Rational-Sum-20-%E5%88%86/">1081 Rational Sum (20 分)</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分数四则运算</title>
    <link href="/2021/02/17/%E5%88%86%E6%95%B0%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97/"/>
    <url>/2021/02/17/%E5%88%86%E6%95%B0%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h1 id="分数四则运算"><a href="#分数四则运算" class="headerlink" title="分数四则运算"></a>分数四则运算</h1><h2 id="分数的表示"><a href="#分数的表示" class="headerlink" title="分数的表示"></a>分数的表示</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Fraction</span>&#123;</span><br><span class="hljs-keyword">int</span> up, down; <span class="hljs-comment">// 分子分母</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>三条规则</p><ol><li>若分数为负，则需要保持<code>up</code>为负，<code>down</code>为正。</li><li>若分数为0，则保持<code>up=0, down = 1;</code>。</li><li>分子分母需要化成最简单的算式，无法约分。</li></ol><h2 id="分数的化简"><a href="#分数的化简" class="headerlink" title="分数的化简"></a>分数的化简</h2><blockquote><p>注意：公约数应该用正整数进行计算。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// m,n 为正整数</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><span class="hljs-keyword">return</span> n == <span class="hljs-number">0</span> ? m : gcd(n, m % n);<br>&#125;<br><span class="hljs-function">Fraction <span class="hljs-title">reduction</span><span class="hljs-params">(Fraction result)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (result.down &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 如果分母为负，则需要调整至分母为正。将分子分母进行反转</span><br>result.up = -result.up;<br>result.down = -result.down;<br>&#125;<br><span class="hljs-keyword">if</span> (result.up == <span class="hljs-number">0</span>) &#123;<br>result.down = <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">int</span> d = gcd(<span class="hljs-built_in">abs</span>(result.up), <span class="hljs-built_in">abs</span>(result.down));<br>result.up /= d;<br>result.down /= d;<br>&#125;<br><span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="分数四则运算-1"><a href="#分数四则运算-1" class="headerlink" title="分数四则运算"></a>分数四则运算</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Fraction <span class="hljs-title">add</span><span class="hljs-params">(Fraction f1, Fraction f2)</span> </span>&#123;<br>Fraction result;<br>result.up = f1.up * f2.down + f2.up * f1.down;<br>result.down = f1.down * f2.down;<br><span class="hljs-keyword">return</span> reduction(result);<br>&#125;<br><br><span class="hljs-comment">// a/b - c/d = ad - bc / bd;</span><br><span class="hljs-function">Fraction <span class="hljs-title">minu</span><span class="hljs-params">(Fraction f1, Fraction f2)</span> </span>&#123;<br>Fraction result;<br>result.up = f1.up * f2.down - f2.up * f1.down;<br>result.down = f1.down * f2.down;<br><span class="hljs-keyword">return</span> reduction(result);<br>&#125;<br><br><span class="hljs-function">Fraction <span class="hljs-title">multi</span><span class="hljs-params">(Fraction f1, Fraction f2)</span> </span>&#123;<br>Fraction result;<br>result.up = f1.up * f2.up;<br>result.down = f1.down * f2.down;<br><span class="hljs-keyword">return</span> reduction(result);<br>&#125;<br><br><span class="hljs-comment">// (a / b) / (c / d) = (a / b) * (d / c) = ad / bc</span><br><span class="hljs-function">Fraction <span class="hljs-title">divide</span><span class="hljs-params">(Fraction f1, Fraction f2)</span> </span>&#123;<br>Fraction result;<br>result.up = f1.up * f2.down;<br>result.down = f1.down * f2.up;<br><span class="hljs-keyword">return</span> reduction(result);<br>&#125;<br></code></pre></td></tr></table></figure><p>注意在做除法的时候，需要先判断除数是否为0，若为0就不需要进行计算。</p><h2 id="分数的输出"><a href="#分数的输出" class="headerlink" title="分数的输出"></a>分数的输出</h2><p>分数一般有下面三种形式</p><ul><li>整数：分母为1。</li><li>假分数：分子大于分母。（只比较二者绝对值）</li><li>真分数：除了上面两种情况，就是真分数。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">showResult</span><span class="hljs-params">(Fraction result)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (result.down == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Inf\n&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>result = reduction(result);<br><span class="hljs-keyword">if</span> (result.down == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 整数</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, result.up);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(result.up) &gt; result.down) &#123; <span class="hljs-comment">// 假分数</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld %lld/%lld\n&quot;</span>, result.up / result.down, <span class="hljs-built_in">abs</span>(result.up) % result.down, result.down);<br>&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 真分数</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld/%lld\n&quot;</span>, result.up, result.down);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>尽量使用<code>long long</code>型</p>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进制转换</title>
    <link href="/2021/02/16/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
    <url>/2021/02/16/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h1><p><strong>将P进制的x转成Q进制</strong>需要两步</p><ol><li>先将<strong>P进制</strong>转成<strong>十进制</strong>。</li><li>再将<strong>十进制</strong>转成<strong>Q进制</strong>。</li></ol><h2 id="1-P进制转十进制"><a href="#1-P进制转十进制" class="headerlink" title="1. P进制转十进制"></a>1. P进制转十进制</h2><p>十进制数字表达方式</p><p>$$y = d_1<em>10^{n-1} + d_2</em>10^{n-2}+d_3*10^{n-3}+…+d_{n-1}*10 + d_n$$</p><p>P进制使用十进制表示的方式</p><p>$$y = a_1<em>P^{n-1} + a_2</em>P^{n-2}+a_3*P^{n-3}+…+a_{n-1}*P + a_n$$</p><p>示例：</p><p>将二进制$1101$转成十进制的数字。先将二进制按照十进制表示</p><p>$$<br>y = 1 * 2^3 + 1 * 2 ^ 2 + 0 * 2 + 1 = 8 + 4 + 1 = 13<br>$$</p><p>将8进制$1101$转成十进制的数字。先将二进制按照十进制表示</p><p>$$<br>y = 1 * 8^3 + 1 * 8 ^ 2 + 0 * 8 + 1 = 512 + 64 + 1 = 577<br>$$</p><p>根据上面的例子，可以写出下面代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">convertDecimal</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-keyword">int</span> P)</span> </span>&#123;<br><span class="hljs-comment">// string s; // 输入的数字</span><br><span class="hljs-comment">// int P; // P进制</span><br><span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>; <span class="hljs-comment">// 表示当前进制</span><br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> sum = <span class="hljs-number">0</span>, temp;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = s.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>temp = isDigit(s[i]) ? <span class="hljs-number">0</span> + s[i] : <span class="hljs-number">0</span> + s[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>sum += temp * <span class="hljs-built_in">pow</span>(P, idx++);<br>&#125;<br><span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="10进制转Q进制"><a href="#10进制转Q进制" class="headerlink" title="10进制转Q进制"></a>10进制转Q进制</h2><p>10进制转其他进制使用的是<strong>除基取余法</strong>。原理很简单，这里直接写代码</p><blockquote><p>伪代码，部分地方不准确。可以直接看示例</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 转成Q进制</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">convertQ</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> Q)</span> </span>&#123;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans;<br><span class="hljs-keyword">do</span> &#123;<br>ans.push_back(n % Q);<br>n /= Q;<br>&#125; <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>示例：将十进制$11$转成二进制</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 11 / 2 = 5 ... 1;</span><br><span class="hljs-comment">// 5 / 2 = 2 ... 1;</span><br><span class="hljs-comment">// 2 / 2 = 1 ... 0;</span><br><span class="hljs-comment">// 1 / 2 = 0 ... 1;</span><br><span class="hljs-comment">// 0;</span><br><br><span class="hljs-comment">// 最终结果是 1011</span><br><br><span class="hljs-keyword">int</span> z[<span class="hljs-number">100</span>];<br><span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> n = <span class="hljs-number">11</span>;<br><br><span class="hljs-keyword">do</span> &#123;<br>z[idx++] = n % <span class="hljs-number">2</span>;<br>n /= <span class="hljs-number">2</span>;<br>&#125; <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// z = [1, 1, 0, 1, ....];</span><br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><ul><li><a href="https://emhui.fun/2021/02/16/1010-Radix-25-%E5%88%86/">1010 Radix (25 分)</a></li><li><a href="https://emhui.fun/2021/02/16/1022-D%E8%BF%9B%E5%88%B6%E7%9A%84A-B-20%E5%88%86/">1022 D进制的A+B (20分)</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>进制转换</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1022 D进制的A+B (20分)</title>
    <link href="/2021/02/16/1022-D%E8%BF%9B%E5%88%B6%E7%9A%84A-B-20%E5%88%86/"/>
    <url>/2021/02/16/1022-D%E8%BF%9B%E5%88%B6%E7%9A%84A-B-20%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1022-D进制的A-B-20分"><a href="#1022-D进制的A-B-20分" class="headerlink" title="1022 D进制的A+B (20分)"></a>1022 D进制的A+B (20分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/aMrwcs.png" alt="aMrwcs"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> a, b, d;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; d;<br>    <span class="hljs-keyword">int</span> sum = a + b;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans;<br>    <span class="hljs-keyword">do</span> &#123;<br>        ans.push_back(sum % d);<br>        sum /= d;<br>    &#125; <span class="hljs-keyword">while</span> (sum);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = ans.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ans[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> a, b, d;<br>    <span class="hljs-keyword">int</span> ans[<span class="hljs-number">32</span>];<br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;d);<br>    <span class="hljs-keyword">int</span> sum = a + b;<br>    <span class="hljs-keyword">do</span>&#123;<br>        ans[count++] = sum % d;<br>        sum /= d;<br>    &#125;<span class="hljs-keyword">while</span>(sum != <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = count - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ans[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>进制转换</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1010 Radix (25 分)</title>
    <link href="/2021/02/16/1010-Radix-25-%E5%88%86/"/>
    <url>/2021/02/16/1010-Radix-25-%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1010-Radix-25-分"><a href="#1010-Radix-25-分" class="headerlink" title="1010 Radix (25 分)"></a>1010 Radix (25 分)</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本题考查 <strong>进制转换</strong>和<strong>二分法</strong></p><p>将两个不同进制的数比较，该如何实现呢？</p><p>将两个数都转化成十进制方便比较，由于转成10进制可能数字偏大，所以需要用<code>long long </code>存储十进制。</p><p>将结果转成十进制</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">convertDecimal</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-keyword">int</span> P)</span> </span>&#123;<br>    <span class="hljs-comment">// string s; // 输入的数字</span><br>    <span class="hljs-comment">// int P; // P进制</span><br>    <span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>; <span class="hljs-comment">// 表示当前进制</span><br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> sum = <span class="hljs-number">0</span>, temp;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = s.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        temp = isDigit(s[i]) ? <span class="hljs-number">0</span> + s[i] : <span class="hljs-number">0</span> + s[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        sum += temp * <span class="hljs-built_in">pow</span>(P, idx++);<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><p>将已知进制的数字转成十进制，然后在对未知进制的数字转十进制。</p><p>对未知进制的数字转十进制，需要使用二分法，确定未知进制的范围。</p><ul><li>未知进制的下界为所有数位中最大的那个加1</li><li>上界为下界与十进制中较大值加1</li></ul><p>注意：需要考虑溢出，若溢出，结果会小于0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">findRadix</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> num)</span> </span>&#123;<br>    <span class="hljs-keyword">char</span> maxEle = *max_element(s.begin(), s.end());<br>    <span class="hljs-comment">// 下界为所有数位中最大的那个加1</span><br>    <span class="hljs-comment">// 上界为下界与十进制的数较大值加1</span><br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> low = (<span class="hljs-built_in">isdigit</span>(maxEle) ? maxEle - <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">10</span> + maxEle - <span class="hljs-string">&#x27;a&#x27;</span>) + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> high = max(low, num) + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (low &lt;= high) &#123;<br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> mid = (low + high) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> temp = convertDecimal(s, mid);<br>        <span class="hljs-comment">// 溢出或者是进制过大导致结果超出num</span><br>        <span class="hljs-keyword">if</span> (temp &lt; <span class="hljs-number">0</span> || temp &gt; num) high = mid - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (temp == num) <span class="hljs-keyword">return</span> mid;<br>        <span class="hljs-keyword">else</span> low = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">// string s; // 输入的数字</span><br><span class="hljs-comment">// int P; // P进制</span><br><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">convertDecimal</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-keyword">int</span> P)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>; <span class="hljs-comment">// 表示当前进制位</span><br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> sum = <span class="hljs-number">0</span>, temp;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = s.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        temp = <span class="hljs-built_in">isdigit</span>(s[i]) ? s[i] - <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">10</span> + s[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        sum += temp * <span class="hljs-built_in">pow</span>(P, idx++);<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">findRadix</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> num)</span> </span>&#123;<br>    <span class="hljs-keyword">char</span> maxEle = *max_element(s.begin(), s.end());<br>    <span class="hljs-comment">// 下界为所有数位中最大的那个加1</span><br>    <span class="hljs-comment">// 上界为下界与十进制的数较大值加1</span><br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> low = (<span class="hljs-built_in">isdigit</span>(maxEle) ? maxEle - <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">10</span> + maxEle - <span class="hljs-string">&#x27;a&#x27;</span>) + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> high = max(low, num) + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (low &lt;= high) &#123;<br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> mid = (low + high) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> temp = convertDecimal(s, mid);<br>        <span class="hljs-comment">// 溢出或者是进制过大导致结果超出num</span><br>        <span class="hljs-keyword">if</span> (temp &lt; <span class="hljs-number">0</span> || temp &gt; num) high = mid - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (temp == num) <span class="hljs-keyword">return</span> mid;<br>        <span class="hljs-keyword">else</span> low = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">string</span> n1, n2;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> tag = <span class="hljs-number">0</span>, radix = <span class="hljs-number">0</span>, ans;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n1 &gt;&gt; n2 &gt;&gt; tag &gt;&gt; radix;<br>    <span class="hljs-keyword">if</span> (tag == <span class="hljs-number">2</span>) swap(n1, n2);<br>    ans = findRadix(n2, convertDecimal(n1, radix));<br>    <span class="hljs-keyword">if</span> (ans != <span class="hljs-number">-1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, ans);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Impossible\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="">算法笔记-上机训练实战指南</a></li><li><a href="https://blog.csdn.net/liuchuo/article/details/81436415">[Java] 1010. Radix (25)-PAT甲级</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>进制转换</tag>
      
      <tag>二分法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>485. 最大连续1的个数</title>
    <link href="/2021/02/15/485-%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <url>/2021/02/15/485-%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="485-最大连续1的个数"><a href="#485-最大连续1的个数" class="headerlink" title="485. 最大连续1的个数"></a><a href="https://leetcode-cn.com/problems/max-consecutive-ones/">485. 最大连续1的个数</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/7yY9PL.png" alt="7yY9PL"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本题考查 <strong>双指针</strong></p><p>设置两个指针<code>i,j</code>。</p><ul><li><code>i</code>表示一段连续1中的第一个1的位置。</li><li><code>j</code>表示一点连续1中的最后一个1的<strong>下一个位置</strong>。</li></ul><p>所以，首先需要找到<code>i</code>的位置，再从<code>i</code>开始，寻找最后一个1的位置，也就是<code>j-1</code>。最后使用<code>ans</code>变量记录最大值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">while</span> (i &lt; n &amp;&amp; j &lt; n) &#123;<br><span class="hljs-comment">// i走到第一个等于1的地方</span><br><span class="hljs-keyword">while</span> (i &lt; n) &#123;<br><span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;<br>i++;<br>&#125;<br>j = i; <span class="hljs-comment">// j从i开始，找到最后一个1的位置</span><br><span class="hljs-comment">// j 走到不为1的地方</span><br><span class="hljs-keyword">while</span> (j &lt; n &amp;&amp; nums[j] == <span class="hljs-number">1</span>) &#123;<br>j++;<br>&#125;<br><span class="hljs-comment">// 更新答案</span><br>ans = max(j - i, ans);<br><span class="hljs-comment">// i再次从j的位置开始，找第一个为1的位置</span><br>i = j;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findMaxConsecutiveOnes</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, n = nums.size();<br><br>        <span class="hljs-keyword">while</span> (i &lt; n &amp;&amp; j &lt; n) &#123;<br>            <span class="hljs-keyword">while</span> (i &lt; n) &#123;<br>                <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;<br>                i++;<br>            &#125;<br>            j = i;<br>            <span class="hljs-keyword">while</span> (j &lt; n &amp;&amp; nums[j] == <span class="hljs-number">1</span>) &#123;<br>                j++;<br>            &#125;<br>            ans = max(j - i, ans);<br>            i = j;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>数组</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1016 Phone Bills (25 分)</title>
    <link href="/2021/02/11/1016-Phone-Bills-25-%E5%88%86/"/>
    <url>/2021/02/11/1016-Phone-Bills-25-%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1016-Phone-Bills-25-分"><a href="#1016-Phone-Bills-25-分" class="headerlink" title="1016 Phone Bills (25 分)"></a>1016 Phone Bills (25 分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/KiD29Z.png" alt="KiD29Z"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>先按照姓名，在按照时间排序，选出有效的数据。</p><p>选出有效的数据后，计算他们打电话的时间段，并且计算出对应的金额，最后累加。</p><p>在选出有效的数据的时候，就可以进行计算了。使用一个<code>unordered_map&lt;string ,int&gt; umsi;</code>来判断是否这个人是第一次访问，如果是第一次访问，那么就打印出这个人的信息，同时设置<code>allCost = 0</code>变量来计算该用户下的总花费。若访问到一个新的用户，就重置<code>allCost = 0</code>。同时将上一个人的<code>allCost</code>打印出来。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt; umsi; <span class="hljs-comment">// 记录这个人有效记录次数，同时也可作为是否打印输出名称</span><br><span class="hljs-keyword">int</span> allCost = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 开始计算有效数据，并记录这个人当前是否已经打印了票据</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br><span class="hljs-comment">// 有效数据</span><br><span class="hljs-keyword">if</span> (vn[i].name == vn[i + <span class="hljs-number">1</span>].name &amp;&amp; vn[i].flag == <span class="hljs-literal">true</span> &amp;&amp; vn[i + <span class="hljs-number">1</span>].flag == <span class="hljs-literal">false</span>) &#123;<br><span class="hljs-keyword">if</span> (umsi.find(vn[i].name) == umsi.end()) &#123; <span class="hljs-comment">// 第一次访问该有效数据</span><br><span class="hljs-keyword">if</span> (allCost &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Total amount: $%.2lf\n&quot;</span>, allCost /<span class="hljs-number">100.0</span>);<br>&#125;<br>umsi[vn[i].name] = <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 打印出这个人的详细信息</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s %02d\n&quot;</span>, vn[i].name.c_str(), vn[i].MM);<br>allCost = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">int</span> time = <span class="hljs-number">0</span>, cost = <span class="hljs-number">0</span>;<br>computeTimeCost(i, i+<span class="hljs-number">1</span>, time, cost);<br>allCost += cost;<br><span class="hljs-comment">// 打印账单信息</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%02d:%02d:%02d %02d:%02d:%02d %d $%.2lf\n&quot;</span>,<br>  vn[i].dd, vn[i].HH, vn[i].mm, vn[i+<span class="hljs-number">1</span>].dd, vn[i+<span class="hljs-number">1</span>].HH, vn[i+<span class="hljs-number">1</span>].mm,<br>  time, cost / <span class="hljs-number">100.0</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (allCost &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Total amount: $%.2lf\n&quot;</span>, allCost /<span class="hljs-number">100.0</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>其中，如何计算时间和花费是比较难想的。这里参考的是<strong>《算法笔记-上机训练实战指南-胡凡》</strong>书中的方法。使用<code>time</code>变量记录分钟，然后每分钟就进行加1，直到超过60分钟的时候，每小时+1，若超过24小时，则每天+1.直到到达挂断时间的时候。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">computeTimeCost</span><span class="hljs-params">(<span class="hljs-keyword">int</span> on, <span class="hljs-keyword">int</span> off, <span class="hljs-keyword">int</span> &amp;time, <span class="hljs-keyword">int</span> &amp;cost)</span> </span>&#123;<br>    temp = vn[on];<br>    <span class="hljs-keyword">while</span> (temp.dd &lt; vn[off].dd || temp.HH &lt; vn[off].HH || temp.mm &lt; vn[off].mm) &#123;<br>        time++; <span class="hljs-comment">// 每分钟进行计算</span><br>        cost += toll[temp.HH];<br>        temp.mm++;<br>        <span class="hljs-keyword">if</span> (temp.mm &gt;= <span class="hljs-number">60</span>) &#123;<br>            temp.mm = <span class="hljs-number">0</span>;<br>            temp.HH++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (temp.HH &gt;= <span class="hljs-number">24</span>) &#123;<br>            temp.HH = <span class="hljs-number">0</span>;<br>            temp.dd++;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span><br>    <span class="hljs-built_in">string</span> name; <span class="hljs-comment">// 按字典序，大写字母在小写字母前面</span><br>    <span class="hljs-keyword">int</span> MM, dd, HH, mm;<br>    <span class="hljs-keyword">bool</span> flag; <span class="hljs-comment">// true表示on, false表示off</span><br>    node()&#123;&#125;<br>    node(<span class="hljs-built_in">string</span> _name, <span class="hljs-keyword">int</span> _MM, <span class="hljs-keyword">int</span> _dd, <span class="hljs-keyword">int</span> _HH, <span class="hljs-keyword">int</span> _mm, <span class="hljs-keyword">bool</span> _flag):<br>    name(_name), MM(_MM), dd(_dd), HH(_HH), mm(_mm), flag(_flag) &#123;&#125;<br>&#125;temp;<br><br><span class="hljs-built_in">vector</span>&lt;node&gt; vn;<br><span class="hljs-keyword">int</span> toll[<span class="hljs-number">25</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(node &amp;a, node &amp;b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (a.name != b.name) <span class="hljs-keyword">return</span> a.name &lt; b.name;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a.MM != b.MM) <span class="hljs-keyword">return</span> a.MM &lt; b.MM;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a.dd != b.dd) <span class="hljs-keyword">return</span> a.dd &lt; b.dd;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a.HH != b.HH) <span class="hljs-keyword">return</span> a.HH &lt; b.HH;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> a.mm &lt; b.mm;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">computeTimeCost</span><span class="hljs-params">(<span class="hljs-keyword">int</span> on, <span class="hljs-keyword">int</span> off, <span class="hljs-keyword">int</span> &amp;time, <span class="hljs-keyword">int</span> &amp;cost)</span> </span>&#123;<br>    temp = vn[on];<br>    <span class="hljs-keyword">while</span> (temp.dd &lt; vn[off].dd || temp.HH &lt; vn[off].HH || temp.mm &lt; vn[off].mm) &#123;<br>        time++; <span class="hljs-comment">// 每分钟进行计算</span><br>        cost += toll[temp.HH];<br>        temp.mm++;<br>        <span class="hljs-keyword">if</span> (temp.mm &gt;= <span class="hljs-number">60</span>) &#123;<br>            temp.mm = <span class="hljs-number">0</span>;<br>            temp.HH++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (temp.HH &gt;= <span class="hljs-number">24</span>) &#123;<br>            temp.HH = <span class="hljs-number">0</span>;<br>            temp.dd++;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-keyword">int</span> MM, dd, HH, mm;<br>    <span class="hljs-built_in">string</span> name, status;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">24</span>; i++) <span class="hljs-built_in">cin</span> &gt;&gt; toll[i];<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; name;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d:%d:%d:%d&quot;</span>, &amp;MM, &amp;dd, &amp;HH, &amp;mm);<br>        <span class="hljs-built_in">cin</span> &gt;&gt; status;<br>        vn.push_back(node(name, MM, dd, HH, mm, status == <span class="hljs-string">&quot;on-line&quot;</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>));<br>    &#125;<br><br>    <span class="hljs-comment">// 按照姓名和时间顺序排序</span><br>    sort(vn.begin(), vn.end(), cmp);<br><br>    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt; umsi; <span class="hljs-comment">// 记录这个人有效记录次数，同时也可作为是否打印输出名称</span><br>    <span class="hljs-keyword">int</span> allCost = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 开始计算有效数据，并记录这个人当前是否已经打印了票据</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-comment">// 有效数据</span><br>        <span class="hljs-keyword">if</span> (vn[i].name == vn[i + <span class="hljs-number">1</span>].name &amp;&amp; vn[i].flag == <span class="hljs-literal">true</span> &amp;&amp; vn[i + <span class="hljs-number">1</span>].flag == <span class="hljs-literal">false</span>) &#123;<br>            <span class="hljs-keyword">if</span> (umsi.find(vn[i].name) == umsi.end()) &#123; <span class="hljs-comment">// 第一次访问该有效数据</span><br>                <span class="hljs-keyword">if</span> (allCost &gt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Total amount: $%.2lf\n&quot;</span>, allCost /<span class="hljs-number">100.0</span>);<br>                &#125;<br>                umsi[vn[i].name] = <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">// 打印出这个人的详细信息</span><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s %02d\n&quot;</span>, vn[i].name.c_str(), vn[i].MM);<br>                allCost = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">int</span> time = <span class="hljs-number">0</span>, cost = <span class="hljs-number">0</span>;<br>            computeTimeCost(i, i+<span class="hljs-number">1</span>, time, cost);<br>            allCost += cost;<br>            <span class="hljs-comment">// 打印账单信息</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%02d:%02d:%02d %02d:%02d:%02d %d $%.2lf\n&quot;</span>,<br>                  vn[i].dd, vn[i].HH, vn[i].mm, vn[i+<span class="hljs-number">1</span>].dd, vn[i+<span class="hljs-number">1</span>].HH, vn[i+<span class="hljs-number">1</span>].mm,<br>                  time, cost / <span class="hljs-number">100.0</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (allCost &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Total amount: $%.2lf\n&quot;</span>, allCost /<span class="hljs-number">100.0</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>703. 数据流中的第 K 大元素</title>
    <link href="/2021/02/11/703-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E7%AC%AC-K-%E5%A4%A7%E5%85%83%E7%B4%A0/"/>
    <url>/2021/02/11/703-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E7%AC%AC-K-%E5%A4%A7%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="703-数据流中的第-K-大元素"><a href="#703-数据流中的第-K-大元素" class="headerlink" title="703. 数据流中的第 K 大元素"></a>703. 数据流中的第 K 大元素</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/ViSwek.png" alt="ViSwek"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题考查 <strong>最小堆</strong></p><p>题目比较简单，维护一个大小为<code>k</code>的最小堆，然后当堆的大小小于<code>k</code>的时候入堆，若等于<code>k</code>，且堆顶元素小于要进入的元素<code>x</code>，那么就将堆顶弹出，将<code>x</code>入堆，始终保持堆的大小是<code>k</code>.第<code>k</code>大的元素就是堆顶元素。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KthLargest</span> &#123;</span><br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> _k;<br>    <span class="hljs-built_in">priority_queue</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;, greater&lt;<span class="hljs-keyword">int</span>&gt;&gt; spq;<br><span class="hljs-keyword">public</span>:<br>    KthLargest(<span class="hljs-keyword">int</span> k, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-comment">// 4, 5, 8, 2</span><br>        <span class="hljs-comment">// 使用小堆</span><br>        <span class="hljs-comment">// 若比堆首大，就入堆，同时堆首出堆</span><br>        _k = k;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (spq.size() &lt; _k) &#123;<br>                spq.push(nums[i]);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (spq.top() &lt; nums[i]) &#123;<br>                spq.pop();<br>                spq.push(nums[i]);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (spq.size() &lt; _k) &#123;<br>            spq.push(val);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (spq.top() &lt; val) &#123;<br>            spq.pop();<br>            spq.push(val);<br>        &#125;<br>        <span class="hljs-keyword">return</span> spq.top();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your KthLargest object will be instantiated and called as such:</span><br><span class="hljs-comment"> * KthLargest* obj = new KthLargest(k, nums);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;add(val);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p>优化：在写法上优化一下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KthLargest</span> &#123;</span><br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> k;<br>    <span class="hljs-built_in">priority_queue</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;, greater&lt;<span class="hljs-keyword">int</span>&gt;&gt; spq;<br><span class="hljs-keyword">public</span>:<br>    KthLargest(<span class="hljs-keyword">int</span> k, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;k = k;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i++) &#123;<br>            add(nums[i]);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (spq.size() &lt; k) &#123;<br>            spq.push(val);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (spq.top() &lt; val) &#123;<br>            spq.pop();<br>            spq.push(val);<br>        &#125;<br>        <span class="hljs-keyword">return</span> spq.top();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your KthLargest object will be instantiated and called as such:</span><br><span class="hljs-comment"> * KthLargest* obj = new KthLargest(k, nums);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;add(val);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>堆</tag>
      
      <tag>优先队列</tag>
      
      <tag>最小堆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1014 Waiting in Line (30 分)</title>
    <link href="/2021/02/10/1014-Waiting-in-Line-30-%E5%88%86/"/>
    <url>/2021/02/10/1014-Waiting-in-Line-30-%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1014-Waiting-in-Line-30-分"><a href="#1014-Waiting-in-Line-30-分" class="headerlink" title="1014 Waiting in Line (30 分)"></a>1014 Waiting in Line (30 分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/gkFaAr.png" alt="gkFaAr"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题考查 <strong>时间模拟</strong></p><p>本题大致思路如下。</p><p>使用结构体记录每个人的开始和结束时间，还有办理业务时间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span><br><span class="hljs-keyword">int</span> startTime, finishTime, pTime;<br>&#125;<br></code></pre></td></tr></table></figure><p>计算每个人的开始办理业务时间和完成办理业务的时间。最开始有n个窗口，队伍中的每个人按顺序占据各个窗口的第一行，然后第二行，第三行，直到窗口的限额最大值。</p><p>先更新每个窗口第一行的人的开始和结束办理业务时间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>vn[i].startTime = <span class="hljs-number">0</span>; <span class="hljs-comment">// 第一行的人开始时间是0</span><br>vn[i].finishTime = vn[i].pTime; <span class="hljs-comment">// 第一行的人结束时间是处理完业务</span><br>&#125;<br></code></pre></td></tr></table></figure><p>然后更新每个队伍新入队的人的时间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">lastId = windows[windowId].back(); <span class="hljs-comment">// 目标窗口最后一个人</span><br>vn[i].startTime = vn[lastIdl].finishTime; <span class="hljs-comment">// 开始时间是队伍中上一个人的结束时间</span><br>vn[i].finishTime = vn[i].finishTime + vn[i].pTime; <span class="hljs-comment">// 结束时间是自己开始的时间+办理业务的时间</span><br></code></pre></td></tr></table></figure><p>接下来的人就开始找，那个窗口的人最先完成业务，最先完成业务的人出队，让下一个进入这个队伍。</p><p>注意：</p><ul><li>测试用例1一直出现<strong>段错误</strong>，经过排查，发现是因为窗口人数大于办理业务的人数，所以在初始化每个窗口第一行人的起始时间的时候，需要判断是否办理人数有n个人。</li><li>在17:00之前开始办理业务，即使在17:00后完成办理，也属于办理成功，而在17:00和17:00以后则无法办理。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// min(n,k)很重要，</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= min(n, k); i++) &#123;<br>windows[i].push(i);<br>vn[i].finishTime = vn[i].pTime;<br>vn[i].startTime = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">987654321</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> pTime, startTime, finishTime; <span class="hljs-comment">// pTime处理业务时间，finishTime 完成业务时间</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n, m, k, q;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; q;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;node&gt; <span class="hljs-title">vn</span><span class="hljs-params">(k + <span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">// 用户i</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; i++)<br>        <span class="hljs-built_in">cin</span> &gt;&gt; vn[i].pTime;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">windows</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">// n个窗口，每个窗口存储当前用户</span><br>    <span class="hljs-comment">// 初始化n个窗口第一行用户的时间</span><br>    <span class="hljs-comment">// 这里注意，如果窗口的人数大于办理业务人数，就只需要使用前k个窗口</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= min(n, k); i++)<br>    &#123;<br>        windows[i].push(i);<br>        vn[i].finishTime = vn[i].pTime;<br>        vn[i].startTime = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 将剩下的 n + 1 - k 个人进行队列</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n + <span class="hljs-number">1</span>; i &lt;= k; i++)<br>    &#123;<br>        <span class="hljs-keyword">int</span> windowId = <span class="hljs-number">1</span>, windowNum = INF;<br>        <span class="hljs-comment">// 找到队列最小的那个窗口</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (windowNum &gt; windows[j].size())<br>            &#123;<br>                windowId = j;<br>                windowNum = windows[j].size();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果存在窗口队列最小的窗口，将排到那个队列中</span><br>        <span class="hljs-keyword">if</span> (windowNum &lt; m)<br>        &#123; <span class="hljs-comment">// 排队到窗口最少的那边去。</span><br>            <span class="hljs-keyword">int</span> lastId = windows[windowId].back();<br>            vn[i].startTime = vn[lastId].finishTime;<br>            vn[i].finishTime = vn[lastId].finishTime + vn[i].pTime;<br>            <span class="hljs-comment">// windows[windowId].push_back(i);</span><br>            windows[windowId].push(i);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123; <span class="hljs-comment">// 每个队列都满了，那么就找到最先完成业务的，也就是队首中finshTime最小的那个</span><br>            <span class="hljs-comment">// 找到最先办理完业务的那个窗口</span><br>            <span class="hljs-keyword">int</span> finishTime = INF;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>            &#123;<br>                <span class="hljs-keyword">int</span> tempId = windows[j].front();<br>                <span class="hljs-keyword">if</span> (finishTime &gt; vn[tempId].finishTime)<br>                &#123;<br>                    windowId = j;<br>                    finishTime = vn[tempId].finishTime;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 将该人排到该窗口队列中</span><br>            <span class="hljs-keyword">int</span> lastId = windows[windowId].back();<br>            vn[i].startTime = vn[lastId].finishTime;<br>            vn[i].finishTime = vn[lastId].finishTime + vn[i].pTime;<br>            <span class="hljs-keyword">if</span> (!windows[windowId].empty())<br>                <span class="hljs-comment">// 队首元素完成业务，出队</span><br>                windows[windowId].pop();<br>            <span class="hljs-comment">// 添加这个人进去</span><br>            windows[windowId].push(i);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> userId;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; q; i++)<br>    &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; userId;<br>        <span class="hljs-keyword">if</span> (vn[userId].startTime &gt;= (<span class="hljs-number">17</span> - <span class="hljs-number">8</span>) * <span class="hljs-number">60</span>)<br>        &#123; <span class="hljs-comment">// 如果在17点（包含17点）还没服务，就不服务了</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Sorry\n&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%02d:%02d\n&quot;</span>, <span class="hljs-number">8</span> + (vn[userId].finishTime / <span class="hljs-number">60</span>), vn[userId].finishTime % <span class="hljs-number">60</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1013 数素数 (20 分)</title>
    <link href="/2021/02/09/1013-%E6%95%B0%E7%B4%A0%E6%95%B0-20-%E5%88%86/"/>
    <url>/2021/02/09/1013-%E6%95%B0%E7%B4%A0%E6%95%B0-20-%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1013-数素数-20-分"><a href="#1013-数素数-20-分" class="headerlink" title="1013 数素数 (20 分)"></a>1013 数素数 (20 分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/Iifv8h.png" alt="Iifv8h"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题考查 <strong>求素数</strong>。</p><p>求素数模板如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 注意最大N=10000，即第10000个素数大约在105000 内；这也是测试点4所测试的。</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">1e6</span>;<br><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; primes;<br><span class="hljs-keyword">bool</span> visited[MAX] = &#123;<span class="hljs-literal">false</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPrime</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= (<span class="hljs-keyword">int</span>)<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">1.0</span> * n); i++) &#123;<br>        <span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">findPrime</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; MAX; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!visited[i] &amp;&amp; isPrime(i)) &#123;<br>            primes.push_back(i);<br>            <span class="hljs-keyword">if</span> (primes.size() &gt; n) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &lt; MAX; j += i) &#123;<br>                visited[j] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>注意：测试点4的N的范围比较大，所以<code>MAX</code>的值也需要设大一点。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">// 注意最大N=10000，即第10000个素数大约在105000 内；这也是测试点4所测试的。</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">1e6</span>;<br><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; primes;<br><span class="hljs-keyword">bool</span> visited[MAX] = &#123;<span class="hljs-literal">false</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPrime</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= (<span class="hljs-keyword">int</span>)<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">1.0</span> * n); i++) &#123;<br>        <span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">findPrime</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; MAX; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!visited[i] &amp;&amp; isPrime(i)) &#123;<br>            primes.push_back(i);<br>            <span class="hljs-keyword">if</span> (primes.size() &gt; n) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &lt; MAX; j += i) &#123;<br>                visited[j] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-keyword">int</span> m, n;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; m &gt;&gt; n;<br>    findPrime(n);<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = m; i &lt;= n; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, primes[i - <span class="hljs-number">1</span>]);<br>        cnt++;<br>        <span class="hljs-keyword">if</span> (cnt % <span class="hljs-number">10</span> != <span class="hljs-number">0</span> &amp;&amp; i &lt; n) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相似题目"><a href="#相似题目" class="headerlink" title="相似题目"></a>相似题目</h2><ul><li><a href="https://emhui.fun/2021/02/09/1059-Prime-Factors-25-%E5%88%86/">1059 Prime Factors (25 分)</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>素数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1059 Prime Factors (25 分)</title>
    <link href="/2021/02/09/1059-Prime-Factors-25-%E5%88%86/"/>
    <url>/2021/02/09/1059-Prime-Factors-25-%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1059-Prime-Factors-25-分"><a href="#1059-Prime-Factors-25-分" class="headerlink" title="1059 Prime Factors (25 分)"></a>1059 Prime Factors (25 分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/ZX5Ygk.png" alt="ZX5Ygk"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题需要求素数，如果一个个判断，速度很慢，这里提供一个快速求素数的方法<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="(算法笔记)[]">[1]</span></a></sup>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">1e5</span>;<br><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; primes;<br><span class="hljs-keyword">bool</span> visited[MAX] = &#123;<span class="hljs-literal">false</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPrime</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= (<span class="hljs-keyword">int</span>)<span class="hljs-built_in">sqrt</span>(n); i++) &#123;<br>        <span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">findPrime</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; MAX; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!visited[i] &amp;&amp; isPrime(i)) &#123;<br>            primes.push_back(i);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &lt; MAX; j += i) &#123;<br>                visited[j] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>求完素数集后，再逐个判断是否是<code>n</code>的因子，以及它的指数。使用<code>pair&lt;int, int&gt;</code>来表示结果，前面的为因子，后面的为指数。最后如果答案不为1，需要将最后的因子加入到结果中去。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;utility&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">1e5</span>;<br><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; primes;<br><span class="hljs-keyword">bool</span> visited[MAX] = &#123;<span class="hljs-literal">false</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPrime</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= (<span class="hljs-keyword">int</span>)<span class="hljs-built_in">sqrt</span>(n); i++) &#123;<br>        <span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">findPrime</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; MAX; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!visited[i] &amp;&amp; isPrime(i)) &#123;<br>            primes.push_back(i);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &lt; MAX; j += i) &#123;<br>                visited[j] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    findPrime();<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1=1\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d=&quot;</span>, n);<br>    <span class="hljs-keyword">int</span> sq = (<span class="hljs-keyword">int</span>)<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">1.0</span> * n); <span class="hljs-comment">// 注意，因为n在改变，不能直接用在判断条件中</span><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt; ans; <span class="hljs-comment">// 第一个值存储因子，第二个值存储指数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; primes.size() &amp;&amp; primes[i] &lt;= sq; i++) &#123;<br>        <span class="hljs-keyword">if</span> (n % primes[i] == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//</span><br>            <span class="hljs-keyword">int</span> factor = primes[i]; <span class="hljs-comment">// 因子</span><br>            <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>; <span class="hljs-comment">// 指数个数</span><br>            <span class="hljs-keyword">while</span> (n % primes[i] == <span class="hljs-number">0</span>) &#123;<br>                cnt++;<br>                n /= primes[i];<br>            &#125;<br>            ans.push_back(<span class="hljs-built_in">make_pair</span>(factor, cnt));<br>        &#125;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 找到了结果退出</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (n != <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 如果还不能除尽</span><br>        ans.push_back(<span class="hljs-built_in">make_pair</span>(n, <span class="hljs-number">1</span>));<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ans.size(); i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ans[i].first);<br>        <span class="hljs-keyword">if</span> (ans[i].second &gt; <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;^%d&quot;</span>, ans[i].second);<br>        <span class="hljs-keyword">if</span> (i &lt; ans.size() - <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><section class="footnotes"><h2>参考</h2><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>(算法笔记)[]<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>素数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1096 Consecutive Factors (20 分)</title>
    <link href="/2021/02/09/1096-Consecutive-Factors-20-%E5%88%86/"/>
    <url>/2021/02/09/1096-Consecutive-Factors-20-%E5%88%86/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>1072 Gas Station (30 分)</title>
    <link href="/2021/02/09/1072-Gas-Station-30-%E5%88%86/"/>
    <url>/2021/02/09/1072-Gas-Station-30-%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1072-Gas-Station-30-分"><a href="#1072-Gas-Station-30-分" class="headerlink" title="1072 Gas Station (30 分)"></a>1072 Gas Station (30 分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/p9LJlg.png" alt="p9LJlg"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>求每个汽油站到各个城市的距离。</p><p>这一步是关键，使用邻接表存储数据，其中汽油站的结点放到城市的后面。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getUid</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (s[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;G&#x27;</span>) <span class="hljs-keyword">return</span> stoi(s);<br><span class="hljs-comment">// 汽油站放到 N的后面</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> N + stoi(s.substr(<span class="hljs-number">1</span>));<br>&#125;<br>G.resize(N + M + <span class="hljs-number">1</span>); <span class="hljs-comment">// 1-n , 1-m</span><br>dis.resize(N + M + <span class="hljs-number">1</span>); <span class="hljs-comment">// 这里需要添加到汽油站到汽油站的距离，因为汽油站可以作为中转</span><br>visited.resize(N + M + <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>然后对于每个最短距离进行判断,判断规则如下</p><ul><li>题目要求汽油站离城市最远，因此需要求出距离汽油最短距离的最大的那个路线。</li><li>若最大路线相同，那么选择到达每个城市的距离只和平均值最小的路线</li><li>若平均距离也相同，那么就选汽油站ID编号最小的</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 这里是要寻找离汽油站尽量远的房子</span><br><span class="hljs-comment">// 所以这里是比较距离最小的房子，如果最小距离都很大，那么房子离得肯定远</span><br><span class="hljs-keyword">if</span> (minDis &gt; ansMinDis) &#123;<br>ansDis = totalDis;<br>ansGasId = i;<br>ansMinDis = minDis;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (minDis == ansMinDis &amp;&amp; ansDis &gt; totalDis) &#123;<br>ansGasId = i;<br>ansDis = totalDis;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (minDis == ansMinDis &amp;&amp; ansDis == totalDis &amp;&amp; ansGasId &gt; i) &#123;<br>ansGasId = i;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;utility&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">987654321</span>;<br><br><span class="hljs-keyword">int</span> N, M, K, Ds;<br><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; dis;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; visited;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt;&gt; G;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getUid</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (s[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;G&#x27;</span>) <span class="hljs-keyword">return</span> stoi(s);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> N + stoi(s.substr(<span class="hljs-number">1</span>));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span> </span>&#123;<br>    fill(dis.begin(), dis.end(), INF);<br>    fill(visited.begin(), visited.end(), <span class="hljs-literal">false</span>);<br>    <span class="hljs-built_in">priority_queue</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt;, greater&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt;&gt; pq;<br>    dis[s] = <span class="hljs-number">0</span>;<br>    pq.push(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">0</span>, s));<br>    <span class="hljs-keyword">while</span> (!pq.empty()) &#123;<br>        <span class="hljs-keyword">int</span> u = pq.top().second;<br>        pq.pop();<br>        <span class="hljs-keyword">if</span> (visited[u]) <span class="hljs-keyword">continue</span>;<br>        visited[u] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 开始更新和u相关的边</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; G[u].size(); i++) &#123;<br>            <span class="hljs-keyword">int</span> v = G[u][i].first, dist = G[u][i].second;<br>            <span class="hljs-keyword">if</span> (!visited[v] &amp;&amp; dis[u] + dist &lt; dis[v]) &#123;<br>                dis[v] = dis[u] + dist;<br>                pq.push(<span class="hljs-built_in">make_pair</span>(dis[v], v));<br>            &#125;<br>        &#125;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">string</span> P1, P2;<br>    <span class="hljs-keyword">int</span> Dist;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; N &gt;&gt; M &gt;&gt; K &gt;&gt; Ds;<br>    G.resize(N + M + <span class="hljs-number">1</span>); <span class="hljs-comment">// 1-n , 1-m</span><br>    dis.resize(N + M + <span class="hljs-number">1</span>); <span class="hljs-comment">// 这里需要添加到汽油站到汽油站的距离，因为汽油站可以作为中转</span><br>    visited.resize(N + M + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">int</span> p1Uid, p2Uid;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; K; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; P1 &gt;&gt; P2 &gt;&gt; Dist;<br>        p1Uid = getUid(P1);<br>        p2Uid = getUid(P2);<br>        G[p1Uid].push_back(<span class="hljs-built_in">make_pair</span>(p2Uid, Dist));<br>        G[p2Uid].push_back(<span class="hljs-built_in">make_pair</span>(p1Uid, Dist));<br>    &#125;<br><br>    <span class="hljs-comment">// 开始从每个汽油站作为起点，求到每个城市的距离</span><br>    <span class="hljs-keyword">double</span> ansDis = <span class="hljs-number">-1</span>, ansMinDis = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">int</span> ansGasId = INF;<br>    <span class="hljs-keyword">bool</span> overRange = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 判断该汽车站能否到达所有房子</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = N + <span class="hljs-number">1</span>; i &lt;= N+M; i++) &#123;<br>        Dijkstra(i);<br>        <span class="hljs-keyword">double</span> totalDis = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> minDis = INF;<br>        overRange = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 判断该汽车站能否到达所有房子</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= N; j++) &#123;<br>            <span class="hljs-keyword">if</span> (dis[j] &gt; Ds) &#123;<br>                overRange = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            minDis = min(minDis, dis[j]);<br>            totalDis += dis[j];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (overRange) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">// 这里是要寻找离汽油站尽量远的房子</span><br>        <span class="hljs-comment">// 所以这里是比较距离最小的房子，如果最小距离都很大，那么房子离得肯定远</span><br>        <span class="hljs-comment">// if (ansDis &lt; totalDis) &#123;</span><br>        <span class="hljs-keyword">if</span> (minDis &gt; ansMinDis) &#123;<br>            ansDis = totalDis;<br>            ansGasId = i;<br>            ansMinDis = minDis;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (minDis == ansMinDis &amp;&amp; ansDis &gt; totalDis) &#123;<br>            ansGasId = i;<br>            ansDis = totalDis;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (minDis == ansMinDis &amp;&amp; ansDis == totalDis &amp;&amp; ansGasId &gt; i) &#123;<br>            ansGasId = i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (overRange) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No Solution\n&quot;</span>);<br>    <span class="hljs-comment">// round(a*100)/100</span><br>    <span class="hljs-comment">// else printf(&quot;G%d\n%.1lf %.1lf\n&quot;, ansGasId - N, ansMinDis, round(10 * ansDis / N) / 10);</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;G%d\n%.1lf %.1lf\n&quot;</span>, ansGasId - N, ansMinDis, ansDis / N);<br>&#125;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>最短距离</tag>
      
      <tag>优先队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1080 Graduate Admission (30 分)</title>
    <link href="/2021/02/08/1080-Graduate-Admission-30-%E5%88%86/"/>
    <url>/2021/02/08/1080-Graduate-Admission-30-%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1080-Graduate-Admission-30-分"><a href="#1080-Graduate-Admission-30-分" class="headerlink" title="1080 Graduate Admission (30 分)"></a>1080 Graduate Admission (30 分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/6GGSTS.png" alt="6GGSTS"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题考查 <strong>结构体排序</strong></p><p>题目比较复杂，需要进行简化，简化后就很简单。所以先可以简化为下面两步。</p><ol><li><p>首先根据成绩进行排序</p></li><li><p>排序完成后分配学校</p></li></ol><p>分配学校规则如下</p><ul><li>根据最后成绩，排序</li><li>若最后成绩相同，根据入学成绩排序，若入学成绩相同，则排名一样</li><li>每个人有K个选择，根据排名来选，若学校没有满员，那么可以入学，满了就换下一个学校。所有的都满了，那么这个人没有书读</li><li>如果两个人排名一样，学校也一样，学校即使满员也要让他们进去。</li></ul><p>该规则转化成代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 开始招收学生</span><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">quota</span><span class="hljs-params">(n)</span></span>; <span class="hljs-comment">// 每个学校的限额</span><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">admissions</span><span class="hljs-params">(m)</span></span>; <span class="hljs-comment">// 每个学校的人</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>applicant ap = va[i];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; k; j++) &#123;<br><span class="hljs-keyword">int</span> schoolId = ap.schools[j];<br><span class="hljs-keyword">int</span> num = admissions[schoolId].size();<br><span class="hljs-keyword">if</span> (quota[schoolId] &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 名额足够</span><br>admissions[schoolId].push_back(ap.id);<br>quota[schoolId]--; <span class="hljs-comment">// 名额-1</span><br><span class="hljs-keyword">break</span>;<br><span class="hljs-comment">// 名额不够但和最后一个人的排名一样，也可以加入</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rank[admissions[schoolId][num<span class="hljs-number">-1</span>]] == rank[ap.id]) &#123;<br>admissions[schoolId].push_back(ap.id);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">applicant</span>&#123;</span><br>    <span class="hljs-keyword">int</span> id, Ge, Gi, Gf, rank;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; schools;<br>    applicant()&#123;&#125;<br>    applicant(<span class="hljs-keyword">int</span> _id, <span class="hljs-keyword">int</span> _Ge, <span class="hljs-keyword">int</span> _Gi, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; _schools) &#123;<br>        id = _id;<br>        Ge = _Ge;<br>        Gi = _Gi;<br>        Gf = (Ge + Gi) / <span class="hljs-number">2</span>;<br>        schools = _schools;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(applicant &amp;a, applicant &amp;b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (a.Gf != b.Gf) <span class="hljs-keyword">return</span> a.Gf &gt; b.Gf;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a.Ge != b.Ge) <span class="hljs-keyword">return</span> a.Ge &gt; b.Ge;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, m, k;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">quota</span><span class="hljs-params">(m)</span></span>;<br>    <span class="hljs-built_in">vector</span>&lt;applicant&gt; va;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">preSchools</span><span class="hljs-params">(k)</span></span>; <span class="hljs-comment">// 存储每个人意向的学校</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) <span class="hljs-built_in">cin</span> &gt;&gt; quota[i]; <span class="hljs-comment">// 每个学校招生人数</span><br><br>    <span class="hljs-keyword">int</span> Gi, Ge;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; Ge &gt;&gt; Gi;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; k; j++) &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; preSchools[j];<br>        &#125;<br>        va.push_back(applicant(i, Ge, Gi, preSchools));<br>    &#125;<br><br>    sort(va.begin(), va.end(), cmp);<br>    <span class="hljs-comment">// 设置排名</span><br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">rank</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// va[i].rank = 1;</span><br>            rank[va[i].id] = <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (va[i].Gf == va[i - <span class="hljs-number">1</span>].Gf &amp;&amp; va[i].Ge == va[i - <span class="hljs-number">1</span>].Ge) &#123;<br>            <span class="hljs-comment">// va[i].rank = va[i - 1].rank;</span><br>            rank[va[i].id] = rank[va[i - <span class="hljs-number">1</span>].id];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// va[i].rank = i + 1;</span><br>            rank[va[i].id] = i + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 开始招收学生</span><br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">admissions</span><span class="hljs-params">(m)</span></span>; <span class="hljs-comment">// 每个学校的人</span><br>    <span class="hljs-comment">// quota 每个学校的限额</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        applicant ap = va[i];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; k; j++) &#123;<br>            <span class="hljs-keyword">int</span> schoolId = ap.schools[j];<br>            <span class="hljs-keyword">int</span> num = admissions[schoolId].size();<br>            <span class="hljs-keyword">if</span> (quota[schoolId] &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 名额足够</span><br>                admissions[schoolId].push_back(ap.id);<br>                quota[schoolId]--; <span class="hljs-comment">// 名额-1</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rank[admissions[schoolId][num<span class="hljs-number">-1</span>]] == rank[ap.id]) &#123; <span class="hljs-comment">// 如果和最后一个人的排名一样，也可以加入</span><br>                admissions[schoolId].push_back(ap.id);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 打印每个学校的录取情况</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        sort(admissions[i].begin(), admissions[i].end());<br>        <span class="hljs-keyword">int</span> size = admissions[i].size();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; size; j++) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, admissions[i][j]);<br>            <span class="hljs-keyword">if</span> (j &lt; size - <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1070 Mooncake (25 分)</title>
    <link href="/2021/02/08/1070-Mooncake-25-%E5%88%86/"/>
    <url>/2021/02/08/1070-Mooncake-25-%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1070-Mooncake-25-分"><a href="#1070-Mooncake-25-分" class="headerlink" title="1070 Mooncake (25 分)"></a>1070 Mooncake (25 分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/SDAaQB.png" alt="SDAaQB"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题考查 <strong>结构体排序</strong>。</p><p>根据题目列出下面表格</p><table><thead><tr><th></th><th>1</th><th>2</th><th>3</th><th>总</th></tr></thead><tbody><tr><td>总量</td><td>180</td><td>150</td><td>100</td><td></td></tr><tr><td>金额</td><td>7.5</td><td>7.2</td><td>4.5</td><td></td></tr><tr><td>方案</td><td>0</td><td>150</td><td>50</td><td>9.45</td></tr><tr><td>单价</td><td>$7.5/180 = 0.04$</td><td>$7.2/150=0.048$</td><td>$4.5/100=0.045$</td><td></td></tr></tbody></table><p>从上面可以看到，优先选单价最高的，若有剩余，再选单价第二，若仍有剩余，则依次选择，直到选完。</p><p>使用结构体存储总量，价格，单价。再按单价进行排序，挨个选择。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span><br><span class="hljs-keyword">double</span> totalAmount, totalPrice, price;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span><br>    <span class="hljs-comment">// 总量，总价格，单价</span><br>    <span class="hljs-keyword">double</span> totalAmount, totalPrice, price;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(node &amp;a, node &amp;b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a.price &gt; b.price;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, d;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; d;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;node&gt; <span class="hljs-title">vn</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) <span class="hljs-built_in">cin</span> &gt;&gt; vn[i].totalAmount;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; vn[i].totalPrice;<br>        vn[i].price = <span class="hljs-number">1.0</span> * vn[i].totalPrice / vn[i].totalAmount;<br>    &#125;<br>    sort(vn.begin(), vn.end(), cmp);<br>    <span class="hljs-keyword">double</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (vn[i].totalAmount == d) &#123;<br>            ans += vn[i].totalPrice;<br>            <span class="hljs-keyword">break</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (vn[i].totalAmount &lt; d) &#123;<br>            ans += vn[i].totalPrice;<br>            d -= vn[i].totalAmount;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ans += (vn[i].price * d);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2lf&quot;</span>, ans);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1069 The Black Hole of Numbers (20 分)</title>
    <link href="/2021/02/08/1069-The-Black-Hole-of-Numbers-20-%E5%88%86/"/>
    <url>/2021/02/08/1069-The-Black-Hole-of-Numbers-20-%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1069-The-Black-Hole-of-Numbers-20-分"><a href="#1069-The-Black-Hole-of-Numbers-20-分" class="headerlink" title="1069 The Black Hole of Numbers (20 分)"></a>1069 The Black Hole of Numbers (20 分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/CharIc.png" alt="CharIc"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这里使用 <code>string</code>存储数字，进行内部排序,使用<code>stoi</code>分别求出递减和递增的数字,求出它们的结果转成<code>string</code>再进行下一轮的计算，直到结果为<code>6174</code>或<code>0000</code>.</p><p>注意：因为可能输入的数字和<code>a-b</code>的结果都可能存在不满4位数情况。所以需要进行一个补0操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">while</span> (s.size() != <span class="hljs-number">4</span>) &#123;<br>s = <span class="hljs-string">&quot;0&quot;</span> + s;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">nonincreasing</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<br>    sort(s.begin(), s.end(), greater&lt;<span class="hljs-keyword">char</span>&gt;());<br>        <span class="hljs-keyword">return</span> s;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">nondecreasing</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<br>    sort(s.begin(), s.end());<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">string</span> s;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; s;<br><br>    <span class="hljs-comment">// 如果输入的不是四位数，则在前面补0</span><br>    <span class="hljs-keyword">while</span> (s.size() != <span class="hljs-number">4</span>) &#123;<br>            s = <span class="hljs-string">&quot;0&quot;</span> + s;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (result != <span class="hljs-number">6174</span>) &#123;<br>        <span class="hljs-keyword">int</span> a = stoi(nonincreasing(s));<br>        <span class="hljs-keyword">int</span> b = stoi(nondecreasing(s));<br>        <span class="hljs-keyword">if</span> (a == b) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s - %s = 0000\n&quot;</span>, s.c_str(), s.c_str());<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        result = a - b;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%04d - %04d = %04d\n&quot;</span>, a, b, result);<br>        s = to_string(result);<br><br>        <span class="hljs-keyword">while</span> (s.size() != <span class="hljs-number">4</span>) &#123; <span class="hljs-comment">//补充0</span><br>            s = <span class="hljs-string">&quot;0&quot;</span> + s;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1077 Kuchiguse (20 分)</title>
    <link href="/2021/02/08/1077-Kuchiguse-20-%E5%88%86/"/>
    <url>/2021/02/08/1077-Kuchiguse-20-%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1077-Kuchiguse-20-分"><a href="#1077-Kuchiguse-20-分" class="headerlink" title="1077 Kuchiguse (20 分)"></a>1077 Kuchiguse (20 分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/m9nYTC.png" alt="m9nYTC"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题考查 <strong>寻找公共字符串</strong></p><p>题目大致意思</p><p>The Japanese language is notorious for its sentence ending particles.</p><blockquote><p>日语中句子结尾部分很有名</p></blockquote><p>Personal preference of such particles can be considered as a reflection of the speaker’s personality.</p><blockquote><p>结尾这部分能反应讲话者的个人性格</p></blockquote><p>Such a preference is called “Kuchiguse” and is often exaggerated artistically in Anime and Manga.</p><blockquote><p>这种偏好叫做“Kuchiguse”,在日漫中常能看到</p></blockquote><p>题目大意是寻找几个句子的共同的后缀，存在就输出该后缀，否则不存在，就输出<code>nai</code></p><p>对于每个句子，从后往前开始遍历查找,看是否相同字符数量一致。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; vs;<br><span class="hljs-built_in">string</span> ans = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">int</span> step = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (step) &#123;<br><span class="hljs-keyword">char</span> ch = vs[<span class="hljs-number">0</span>][vs[<span class="hljs-number">0</span>].size() - step]; <span class="hljs-comment">// 倒数第i个字符</span><br><span class="hljs-keyword">int</span> cnt = <span class="hljs-number">1</span>; <span class="hljs-comment">// 统计拥有相同尾字符的字符串数量</span><br><span class="hljs-comment">// 遍历剩下的n-1个元素的倒数第step个字符</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br><span class="hljs-keyword">int</span> len = vs[i].size();<br><span class="hljs-keyword">if</span> (len - step &gt;= <span class="hljs-number">0</span> &amp;&amp; ch == vs[i][len - step]) &#123;<br>cnt++;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (cnt == n) ans += ch; <span class="hljs-comment">// n个元素拥有相同的字符，添加到答案中</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>step++;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">string</span> s;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <span class="hljs-built_in">cin</span>.get(); <span class="hljs-comment">// 使用getline时，如果前面有cin,需要吸收一下字符</span><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; vs;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        getline(<span class="hljs-built_in">cin</span>, s);<br>        vs.push_back(s);<br>    &#125;<br><br>    <span class="hljs-built_in">string</span> ans = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">int</span> step = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (step) &#123;<br>        <span class="hljs-keyword">char</span> ch = vs[<span class="hljs-number">0</span>][vs[<span class="hljs-number">0</span>].size() - step]; <span class="hljs-comment">// 倒数第i个字符</span><br>        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">1</span>; <span class="hljs-comment">// 统计拥有相同尾字符的字符串数量</span><br>        <span class="hljs-comment">// 遍历剩下的n-1个元素的倒数第step个字符</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">int</span> len = vs[i].size();<br>            <span class="hljs-keyword">if</span> (len - step &gt;= <span class="hljs-number">0</span> &amp;&amp; ch == vs[i][len - step]) &#123;<br>                cnt++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (cnt == n) ans += ch; <span class="hljs-comment">// n个元素拥有相同的字符，添加到答案中</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>        step++;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (ans == <span class="hljs-string">&quot;&quot;</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;nai\n&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        reverse(ans.begin(), ans.end());<br>        <span class="hljs-built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>字符串</tag>
      
      <tag>公共部分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1075 PAT Judge (25 分)</title>
    <link href="/2021/02/07/1075-PAT-Judge-25-%E5%88%86/"/>
    <url>/2021/02/07/1075-PAT-Judge-25-%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1075-PAT-Judge-25-分"><a href="#1075-PAT-Judge-25-分" class="headerlink" title="1075 PAT Judge (25 分)"></a>1075 PAT Judge (25 分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/gDRsJj.png" alt="gDRsJj"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题查考 <strong>结构体排序</strong></p><p>题目很简单，就是普通的结构体排序，每个题目的初始分数设置为<code>-2</code>,若分数为<code>-2</code>,则证明这道题没有提交，那么输出<code>-</code>,若分数为<code>-1</code>,证明提交但是没有编译通过，输出<code>0</code>。</p><p>但是部分用例无法通过，找了很久答案。终于发现是下面这个坑。</p><p><strong>有些人通过了，但是得了0分</strong>(太坑了，怎么会有这种设定啊。)，这部分人也要算入排名中，所以需要在结构题中设置一个变量<code>isPass</code>，若这个人的分数大于等于0，设置<code>isPass = true;</code>并且不可逆.代码如下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span> (!users[userId].isPass) users[userId].isPass = score &gt;= <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>然后再将<code>isPass = false</code>的人的总分数设置为<code>-1</code>,这样通过的人总分数是<code>&gt;= 0</code>,没有通过的人的总分数为<code>-1</code>. 这里的判断放在比较函数中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(node &amp;a, node &amp;b)</span> </span>&#123;<br><span class="hljs-comment">// 没有通过任何用例的人默认总分数为-1分</span><br>    <span class="hljs-keyword">int</span> aTotalScore = a.isPass ? <span class="hljs-number">0</span> : <span class="hljs-number">-1</span>, bTotalScore = b.isPass ? <span class="hljs-number">0</span> : <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">int</span> aPerfect = <span class="hljs-number">0</span>, bPerfect = <span class="hljs-number">0</span>; <span class="hljs-comment">// 满分题数量</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; i++) &#123;<br>        <span class="hljs-keyword">if</span> (a.p[i] &gt;= <span class="hljs-number">0</span>) aTotalScore += a.p[i];<br>        <span class="hljs-keyword">if</span> (b.p[i] &gt;= <span class="hljs-number">0</span>) bTotalScore += b.p[i];<br>        <span class="hljs-keyword">if</span> (a.p[i] == p[i]) aPerfect++;<br>        <span class="hljs-keyword">if</span> (b.p[i] == p[i]) bPerfect++;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (aTotalScore != bTotalScore) <span class="hljs-keyword">return</span> aTotalScore &gt; bTotalScore;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (aPerfect != bPerfect) <span class="hljs-keyword">return</span> aPerfect &gt; bPerfect;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> a.id &lt; b.id;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">100000</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXP = <span class="hljs-number">6</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><br>    <span class="hljs-keyword">int</span> id;<br>    <span class="hljs-keyword">int</span> p[MAXP];<br>    <span class="hljs-keyword">int</span> totalScore;<br>    <span class="hljs-keyword">bool</span> isPass;<br>    node() &#123;<br>        isPass = <span class="hljs-literal">false</span>;<br>        totalScore = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= MAXP; i++) p[i] = <span class="hljs-number">-2</span>;<br>    &#125;<br>&#125;users[MAX];<br><span class="hljs-keyword">int</span> Rank[MAX] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">int</span> n, m, k;<br><span class="hljs-keyword">int</span> p[MAXP] = &#123;<span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(node &amp;a, node &amp;b)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> aTotalScore = a.isPass ? <span class="hljs-number">0</span> : <span class="hljs-number">-1</span>, bTotalScore = b.isPass ? <span class="hljs-number">0</span> : <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">int</span> aPerfect = <span class="hljs-number">0</span>, bPerfect = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; i++) &#123;<br>        <span class="hljs-keyword">if</span> (a.p[i] &gt;= <span class="hljs-number">0</span>) aTotalScore += a.p[i];<br>        <span class="hljs-keyword">if</span> (b.p[i] &gt;= <span class="hljs-number">0</span>) bTotalScore += b.p[i];<br>        <span class="hljs-keyword">if</span> (a.p[i] == p[i]) aPerfect++;<br>        <span class="hljs-keyword">if</span> (b.p[i] == p[i]) bPerfect++;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (aTotalScore != bTotalScore) <span class="hljs-keyword">return</span> aTotalScore &gt; bTotalScore;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (aPerfect != bPerfect) <span class="hljs-keyword">return</span> aPerfect &gt; bPerfect;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> a.id &lt; b.id;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p[])</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= k; j++) &#123;<br>        <span class="hljs-keyword">if</span> (p[j] == <span class="hljs-number">-2</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; -&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p[j] == <span class="hljs-number">-1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; 0&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d&quot;</span>, p[j]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; k &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; p[i];<br>    &#125;<br>    <span class="hljs-keyword">int</span> userId, pId, score;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; userId &gt;&gt; pId &gt;&gt; score;<br>        users[userId].id = userId;<br>        users[userId].p[pId] = max(users[userId].p[pId],score);<br>        <span class="hljs-comment">// 若有的0就是得了0分。</span><br>        <span class="hljs-keyword">if</span> (!users[userId].isPass)<br>        users[userId].isPass = score &gt;= <span class="hljs-number">0</span>;<br>    &#125;<br>    sort(users, users + MAX, cmp);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">int</span> totalScore = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">6</span>; j++) &#123;<br>            <span class="hljs-keyword">if</span> (users[i].p[j] &gt; <span class="hljs-number">0</span>) totalScore += users[i].p[j];<br>        &#125;<br>        users[i].totalScore = totalScore;<br>    &#125;<br><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (users[i].isPass) &#123;<br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;<br>                Rank[users[i].id] = <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (users[i - <span class="hljs-number">1</span>].totalScore == users[i].totalScore) &#123;<br>                Rank[users[i].id] = Rank[users[i - <span class="hljs-number">1</span>].id];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                Rank[users[i].id] = i + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%0d %05d %d&quot;</span>, Rank[users[i].id], users[i].id, users[i].totalScore);<br>            show(users[i].p);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1074 Reversing Linked List (25 分)</title>
    <link href="/2021/02/07/1074-Reversing-Linked-List-25-%E5%88%86/"/>
    <url>/2021/02/07/1074-Reversing-Linked-List-25-%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1074-Reversing-Linked-List-25-分"><a href="#1074-Reversing-Linked-List-25-分" class="headerlink" title="1074 Reversing Linked List (25 分)"></a>1074 Reversing Linked List (25 分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/oiDVqa.png" alt="oiDVqa"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题考查 <strong>链表处理</strong></p><p>题目大意，每k个数反转一次。若最后不足k个数，就不用反转。</p><p>把数组存储到vector中,然后每k个进行一次反转，若还有剩余，则顺序输出。</p><p>注意：<strong>链表的题目中存在无效的链表</strong>，所以最后最好不要直接使用<code>n</code>.可以对<code>n</code>进行处理或者设置一个变量统计有效链表的个数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> temp = begin;<br><span class="hljs-keyword">int</span> vaildNum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (temp != <span class="hljs-number">-1</span>) &#123;<br>vlink.push_back(link[temp]);<br>temp = link[temp].next;<br>vaildNum++;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">100000</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span><br>    <span class="hljs-keyword">int</span> address, next, val;<br>&#125;link[MAX];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> begin, n, k;<br>    <span class="hljs-keyword">int</span> address, val, next;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; begin &gt;&gt; n &gt;&gt; k;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; address &gt;&gt; val &gt;&gt; next;<br>        link[address].address = address;<br>        link[address].val = val;<br>        link[address].next = next;<br>    &#125;<br>    <span class="hljs-built_in">vector</span>&lt;node&gt; vlink;<br>    <span class="hljs-keyword">int</span> temp = begin;<br>    <span class="hljs-keyword">while</span> (temp != <span class="hljs-number">-1</span>) &#123;<br>        vlink.push_back(link[temp]);<br>        temp = link[temp].next;<br>    &#125;<br>    n = vlink.size(); <span class="hljs-comment">// 重要，链表一定要考虑没有用的结点</span><br>    <span class="hljs-comment">// 每k个倒着打印</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n / k; i ++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = k * (i + <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>; j &gt;= i * k; j--) &#123;<br>            <span class="hljs-keyword">if</span> (j == i * k ) &#123; <span class="hljs-comment">// 如果是最后一个，打印下一个的地址</span><br>                <span class="hljs-keyword">if</span> ((i + <span class="hljs-number">2</span>) * k - <span class="hljs-number">1</span> &lt; n) &#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d %d %05d\n&quot;</span>, vlink[j].address, vlink[j].val, vlink[(i + <span class="hljs-number">2</span>) * k - <span class="hljs-number">1</span>].address);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n % k == <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">// 若是最后一个结点直接输出-1</span><br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d %d -1\n&quot;</span>, vlink[j].address, vlink[j].val);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d %d %05d\n&quot;</span>, vlink[j].address, vlink[j].val, vlink[k * (n / k)].address);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d %d %05d\n&quot;</span>, vlink[j].address, vlink[j].val, vlink[j - <span class="hljs-number">1</span>].address);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 按照顺序打印接下来的结点</span><br>    <span class="hljs-keyword">if</span> (n % k != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = k * (n / k); i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i &lt; n - <span class="hljs-number">1</span>)<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d %d %05d\n&quot;</span>, vlink[i].address, vlink[i].val, vlink[i + <span class="hljs-number">1</span>].address);<br>            <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d %d -1\n&quot;</span>, vlink[i].address, vlink[i].val);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1073 Scientific Notation (20 分)</title>
    <link href="/2021/02/07/1073-Scientific-Notation-20-%E5%88%86/"/>
    <url>/2021/02/07/1073-Scientific-Notation-20-%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1073-Scientific-Notation-20-分"><a href="#1073-Scientific-Notation-20-分" class="headerlink" title="1073 Scientific Notation (20 分)"></a>1073 Scientific Notation (20 分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/ivWsUd.png" alt="ivWsUd" style="zoom:50%;" /><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题大意是给出一个科学计数法表示的数字，然后还原为真实的数字</p><p>本题查考 <strong>字符串的处理</strong>和<strong>科学计数法的表示</strong></p><p><code> [+-][1-9].[0-9]+E[+-][0-9]+</code></p><blockquote><p>+1.23400E-03 -&gt; 0.00123400</p><p>-1.2E+10 -&gt; -12000000000</p></blockquote><ol><li>先把E的前面和后面分成两部分。</li></ol><ol start="2"><li>根据E后面的指数进行分类</li></ol><p>如果指数是负的，输出形式位<code>0.0000xxx</code>,其中<code>xxx</code>是除了小数点外的整数部分。</p><p><code>xxxx</code>到<code>.</code>之间的<code>0</code>的个数是<code>abs(exp) - 1</code>. 具体代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> <span class="hljs-built_in">exp</span>; <span class="hljs-comment">// 指数</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0.&quot;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">abs</span>(<span class="hljs-built_in">exp</span>) - <span class="hljs-number">1</span>; i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0&quot;</span>);<br><span class="hljs-comment">// 输出除小数点外的其他数字。</span><br></code></pre></td></tr></table></figure><p>如果指数是正的，小数点如何移动？？？</p><p>❌ 输出除小数点的其他数字再补0。(👇这种情况就会出现错误)</p><blockquote><p>————–示例—————–// 小数位数 | 关系 | 指数 | 操作</p><p>-1.2345E+03 = -1234.5     // 4 &gt; 3: 移动小数点，不能补0</p><p>-1.2345E+04 = -12345     // 4 = 4, 不用补0，也不用补小数点.</p><p>-1.2345E+08 = -123450000; // 4 &lt; 8 没有小数点，补4个0</p></blockquote><p>根据上面可以得出，指数为正数时</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> num; <span class="hljs-comment">// 小数位数</span><br><span class="hljs-keyword">int</span> <span class="hljs-built_in">exp</span>; <span class="hljs-comment">// 指数</span><br><br><span class="hljs-keyword">if</span> (num == <span class="hljs-built_in">exp</span>) &#123;<br><span class="hljs-comment">// 直接显示除小数点外的其他数字</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num &gt; <span class="hljs-built_in">exp</span>) &#123;<br><span class="hljs-comment">// 将小数点移动exp位，不需要补充0</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 不显示小数点，并且补充 exp - num 个0.</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">string</span> s;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; s;<br>    <span class="hljs-comment">// 0. 判断是否是负数</span><br>    <span class="hljs-keyword">if</span> (s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;-&#x27;</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-&quot;</span>);<br>    <span class="hljs-comment">// 1. 找到E的位置</span><br>    <span class="hljs-comment">// int n = s.size();</span><br>    <span class="hljs-keyword">int</span> pos = s.find(<span class="hljs-string">&quot;E&quot;</span>); <span class="hljs-comment">// pos == s.npos; 没有找到</span><br><br>    <span class="hljs-keyword">int</span> <span class="hljs-built_in">exp</span> = stoi(s.substr(pos + <span class="hljs-number">1</span>)); <span class="hljs-comment">// 绕过E的位置</span><br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">exp</span> == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s</span><br><span class="hljs-string">&quot;</span>, s.substr(<span class="hljs-number">1</span>, pos - <span class="hljs-number">1</span>).c_str()); <span class="hljs-comment">// 绕开第一个+/-,取 pos - 1个元素</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">exp</span> &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 如果指数是负的</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0.&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">abs</span>(<span class="hljs-built_in">exp</span>) - <span class="hljs-number">1</span>; i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0&quot;</span>);<br>        <span class="hljs-comment">// E的左边部分输出除了小数点其他数字</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c%s</span><br><span class="hljs-string">&quot;</span>, s[<span class="hljs-number">1</span>], s.substr(<span class="hljs-number">3</span>, pos - <span class="hljs-number">3</span>).c_str());<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 开始移动小数点</span><br>        <span class="hljs-comment">// 首先找到有几位小数</span><br>        <span class="hljs-keyword">int</span> num = pos - <span class="hljs-number">3</span>;<br>        <span class="hljs-comment">// 分三种情况判断</span><br>        <span class="hljs-keyword">if</span> (num == <span class="hljs-built_in">exp</span>) &#123; <span class="hljs-comment">// 没有小数点也没有多余的0，直接输出除了小数点部分的数字</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c%s</span><br><span class="hljs-string">&quot;</span>, s[<span class="hljs-number">1</span>], s.substr(<span class="hljs-number">3</span>, pos - <span class="hljs-number">3</span>).c_str());<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num &gt; <span class="hljs-built_in">exp</span>) &#123;<br>            <span class="hljs-comment">// 不需要补0，但是需要移动小数点</span><br>            <span class="hljs-comment">// 小数点移动 exp位</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c%s.%s</span><br><span class="hljs-string">&quot;</span>, s[<span class="hljs-number">1</span>], s.substr(<span class="hljs-number">3</span>, <span class="hljs-built_in">exp</span>).c_str(), s.substr(<span class="hljs-number">3</span> + <span class="hljs-built_in">exp</span> , num - <span class="hljs-built_in">exp</span>).c_str());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 没有小数点，并且输出多余的0</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c%s&quot;</span>, s[<span class="hljs-number">1</span>], s.substr(<span class="hljs-number">3</span>, pos - <span class="hljs-number">3</span>).c_str());<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">exp</span> - num; i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0&quot;</span>);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;</span><br><span class="hljs-string">&quot;</span>);<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1081 Rational Sum (20 分)</title>
    <link href="/2021/02/07/1081-Rational-Sum-20-%E5%88%86/"/>
    <url>/2021/02/07/1081-Rational-Sum-20-%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1081-Rational-Sum-20-分"><a href="#1081-Rational-Sum-20-分" class="headerlink" title="1081 Rational Sum (20 分)"></a>1081 Rational Sum (20 分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/bxZZQx.png" alt="bxZZQx"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题考查<strong>如何表示分数形式</strong>和<strong>求最大公约数</strong>。</p><p>分数四则运算可以参考 <a href="https://emhui.fun/2021/02/17/%E5%88%86%E6%95%B0%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97/">分数四则运算</a></p><blockquote><p>下面是以前写的，最新的思路可以参考上面链接，写法更加简单。</p></blockquote><p>如何表示分数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 将m/n以正确形式表示出来</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">showFormat</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;INF\n&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span> ((m &gt; <span class="hljs-number">0</span> &amp;&amp; n &lt; <span class="hljs-number">0</span>) || (m &lt; <span class="hljs-number">0</span> &amp;&amp; n &gt; <span class="hljs-number">0</span>)) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-&quot;</span>);<br>m = <span class="hljs-built_in">abs</span>(m);<br>n = <span class="hljs-built_in">abs</span>(n);<br><span class="hljs-comment">// 如果可以整除</span><br><span class="hljs-keyword">if</span> (m % n == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, m / n);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 注意这里需要转成最大公约数</span><br><span class="hljs-keyword">if</span> (m &gt; n) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d/%d&quot;</span>, m / n, m % n, n);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d/%d&quot;</span>, m % n, n);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如何求两个数的最大公约数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 12, 4</span><br><span class="hljs-comment">// gcd(12, 4) return 4;</span><br><span class="hljs-comment">// gcd(4, 0) return 4;</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> a;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> gcd(b, a % b);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 4, 12</span><br><span class="hljs-comment">// gcd(4, 12) return 4;</span><br><span class="hljs-comment">// gcd(12, 4) return 4;</span><br><span class="hljs-comment">// gcd(4, 0) return 4;</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br><span class="hljs-keyword">return</span> b == <span class="hljs-number">0</span> ? a : gcd(b, a % b);<br>&#125;<br></code></pre></td></tr></table></figure><p>题目中如果一次性加起来，肯定会出现溢出。所以需要在每次输入的时候进行计算，并且进行约分。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><blockquote><p>更新日期：2021-02-17 16:07</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> n == <span class="hljs-number">0</span> ? m : gcd(n, m % n);<br>&#125;<br><br><span class="hljs-comment">// 化简ab</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reduction</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;m, <span class="hljs-keyword">int</span> &amp;n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (m &lt; <span class="hljs-number">0</span>) &#123;<br>        n = -n;<br>        m = -m;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>        m = <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">int</span> d = gcd(<span class="hljs-built_in">abs</span>(m), <span class="hljs-built_in">abs</span>(n));<br>        m /= d;<br>        n /= d;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 打印 a, b;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">showFormat</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;INF\n&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>    <span class="hljs-comment">// 对m,n进行化简</span><br>    reduction(m, n);<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, m);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(m) &gt; <span class="hljs-built_in">abs</span>(n)) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d/%d\n&quot;</span>, m / n, <span class="hljs-built_in">abs</span>(m) % n, n);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d/%d\n&quot;</span>, m, n);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-keyword">int</span> c, d, a = <span class="hljs-number">0</span>, b = <span class="hljs-number">1</span>, g;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d/%d&quot;</span>, &amp;c, &amp;d);<br>        <span class="hljs-comment">// a / b + c / d = ad+bc / bd</span><br>        a = a * d + b * c;<br>        b = d * b;<br>        g = gcd(<span class="hljs-built_in">abs</span>(a), <span class="hljs-built_in">abs</span>(b));<br>        a /= g;<br>        b /= g;<br>    &#125;<br>    showFormat(a, b);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>更新日期:2021-02-07 10:20</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> n == <span class="hljs-number">0</span> ? m : gcd(n, m % n);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">showFormat</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;INF\n&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>    <span class="hljs-comment">// 这里经过约分处理，所以可以直接使用 m*n &lt; 0</span><br><span class="hljs-keyword">if</span> ((m &gt; <span class="hljs-number">0</span> &amp;&amp; n &lt; <span class="hljs-number">0</span>) || (m &lt; <span class="hljs-number">0</span> &amp;&amp; n &gt; <span class="hljs-number">0</span>)) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-&quot;</span>);<br>    <span class="hljs-comment">// if (m * n &lt; 0) printf(&quot;-&quot;);</span><br>m = <span class="hljs-built_in">abs</span>(m);<br>n = <span class="hljs-built_in">abs</span>(n);<br><span class="hljs-comment">// 如果可以整除</span><br><span class="hljs-keyword">if</span> (m % n == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, m / n);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (m &gt; n)&#123;<br><span class="hljs-comment">// 注意这里需要转成最大公约数,之前已经进行过约分处理</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d/%d\n&quot;</span>, m / n, m % n, n);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d/%d\n&quot;</span>, m % n, n);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-keyword">int</span> a1, b1, a = <span class="hljs-number">0</span>, b = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> numerator, denominator, g;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-comment">// numerator &lt; denominator</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d/%d&quot;</span>, &amp;a1, &amp;b1);<br>        <span class="hljs-comment">// 进行加法计算</span><br>        numerator = a1*b + a * b1; <span class="hljs-comment">// 分子</span><br>        denominator = b1 *b; <span class="hljs-comment">// 分母</span><br>        g = gcd(numerator, denominator);<br>        a = numerator / g;<br>        b = denominator / g;<br>    &#125;<br>    showFormat(a, b);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相似题目"><a href="#相似题目" class="headerlink" title="相似题目"></a>相似题目</h2><ul><li><a href="https://emhui.fun/2021/02/17/1088-Rational-Arithmetic-20-%E5%88%86/">1088 Rational Arithmetic (20 分)</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>最大公约数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1062 Talent and Virtue (25 分)</title>
    <link href="/2021/02/06/1062-Talent-and-Virtue-25-%E5%88%86/"/>
    <url>/2021/02/06/1062-Talent-and-Virtue-25-%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1062-Talent-and-Virtue-25-分"><a href="#1062-Talent-and-Virtue-25-分" class="headerlink" title="1062 Talent and Virtue (25 分)"></a>1062 Talent and Virtue (25 分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/HXrTWl.png" alt="HXrTWl"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题考查 <strong>结构体排序</strong>。</p><p>相对于一般的结构体排序，本题需要额外添加一个<code>type</code>字段，表示当前属于哪一个等级。等级规则如下</p><ol><li><strong>sages</strong>: <code> virtue &gt;= H &amp;&amp; talent &gt;= H</code></li><li><strong>noblemen</strong>: <code> virtue &gt;= H &amp;&amp; talent &lt; H</code></li><li><strong>fool men</strong>: <code> virtue &lt; H &amp;&amp; talent &lt; H &amp;&amp; virtue &gt;= talent</code></li><li><strong>others</strong>: <code> others</code></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><br>    <span class="hljs-keyword">int</span> id, vg, tg, type; <span class="hljs-comment">// type判断是哪一个等级</span><br>    node(<span class="hljs-keyword">int</span> _id, <span class="hljs-keyword">int</span> _vg, <span class="hljs-keyword">int</span> _tg, <span class="hljs-keyword">int</span> _type): id(_id), vg(_vg), tg(_tg), type(_type) &#123;&#125;<br>&#125;;<br><br><br><span class="hljs-keyword">int</span> n, m, l, h;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(node &amp;a, node &amp;b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (a.type != b.type) <span class="hljs-keyword">return</span> a.type &lt; b.type;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a.vg + a.tg != b.vg + b.tg) <span class="hljs-keyword">return</span> a.vg + a.tg &gt; b.vg + b.tg;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a.vg != b.vg) <span class="hljs-keyword">return</span> a.vg &gt; b.vg;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> a.id &lt; b.id;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;node&gt; vn;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; l &gt;&gt; h;<br>    <span class="hljs-keyword">int</span> id, vg, tg;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; id &gt;&gt; vg &gt;&gt; tg;<br>        <span class="hljs-keyword">if</span> (vg &gt;= l &amp;&amp; tg &gt;= l) &#123;<br>            <span class="hljs-keyword">if</span> (vg &gt;= h &amp;&amp; tg &gt;= h) &#123;<br>                vn.push_back(node(id, vg, tg, <span class="hljs-number">1</span>));<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (vg &gt;= h &amp;&amp; tg &lt; h) &#123;<br>                vn.push_back(node(id, vg, tg, <span class="hljs-number">2</span>));<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (vg &gt;= tg) &#123;<br>                vn.push_back(node(id, vg, tg, <span class="hljs-number">3</span>));<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                vn.push_back(node(id, vg, tg, <span class="hljs-number">4</span>));<br>            &#125;<br><br>        &#125;<br>    &#125;<br>    sort(vn.begin(), vn.end(), cmp);<br>    <span class="hljs-keyword">int</span> size = vn.size();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, size);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%08d %d %d\n&quot;</span>, vn[i].id, vn[i].vg, vn[i].tg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1058 A+B in Hogwarts (20 分)</title>
    <link href="/2021/02/06/1058-A-B-in-Hogwarts-20-%E5%88%86/"/>
    <url>/2021/02/06/1058-A-B-in-Hogwarts-20-%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1058-A-B-in-Hogwarts-20-分"><a href="#1058-A-B-in-Hogwarts-20-分" class="headerlink" title="1058 A+B in Hogwarts (20 分)"></a>1058 A+B in Hogwarts (20 分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/5DShR6.png" alt="5DShR6"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题考查 <strong>比较大的整数加法</strong>，<strong>不同单位转化（比如转成时分秒）</strong></p><p><strong>比较大的整数加法</strong></p><p>对于比较大的整数，使用<code>long long</code>类型，如果整数还是很大，比如超过$2^{63} - 1$，则使用<code>string</code>类型表示。</p><p>本题中需要对<code>int</code>类型强制转换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 前面需要加（long long）</span><br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> sum = (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)Galleon * (a1 + a2) + Sickle * (b1 + b2) + (c1 + c2);<br></code></pre></td></tr></table></figure><p><strong>不同单位转化</strong></p><p>比较常见的应用就是时分秒的转化。比如给你一个n秒，让你转成时分秒的格式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> h = n / <span class="hljs-number">3600</span>;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> m = n / <span class="hljs-number">60</span> % <span class="hljs-number">60</span>;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> s = n % <span class="hljs-number">60</span>;<br></code></pre></td></tr></table></figure><p>本题中对<code>Galleon, Sickle, Knuts</code>的转化如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld.%lld.%lld\n&quot;</span>, sum / Galleon, sum % Galleon / Sickle, sum % Sickle);<br></code></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-comment">// Seventeen silver Sickles to a Galleon and twenty-nine Knuts to a Sickle</span><br><span class="hljs-comment">// 17s = 1g, 29k = 1s, 29 * 17k = 1g;</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> Galleon = <span class="hljs-number">17</span> * <span class="hljs-number">29</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> Sickle = <span class="hljs-number">29</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> Knut = <span class="hljs-number">1</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> a1, b1, c1, a2, b2, c2;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d.%d.%d %d.%d.%d&quot;</span>, &amp;a1, &amp;b1, &amp;c1, &amp;a2, &amp;b2, &amp;c2);<br><br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> sum = (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)Galleon * (a1 + a2) + Sickle * (b1 + b2) + (c1 + c2);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld.%lld.%lld\n&quot;</span>, sum / Galleon, sum % Galleon / Sickle, sum % Sickle);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1040 Longest Symmetric String (25 分)</title>
    <link href="/2021/02/06/1040-Longest-Symmetric-String-25-%E5%88%86/"/>
    <url>/2021/02/06/1040-Longest-Symmetric-String-25-%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1040-Longest-Symmetric-String-25-分"><a href="#1040-Longest-Symmetric-String-25-分" class="headerlink" title="1040 Longest Symmetric String (25 分)"></a>1040 Longest Symmetric String (25 分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/UvjZhH.png" alt="UvjZhH"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题考查 <strong>回文数</strong>，<strong>双指针</strong>，<strong>滑动窗口</strong></p><p>题目要求找到最大长度的对称数，而对称数本身就是回文数。所以题目转化成了对回文数的判断。</p><p>最大长度的回文数如何判断，按照下面规则</p><ul><li>从第1个元素开始，分别取到第2,3,4,5…n个元素的字符串，判断是否是回文数</li><li>从第2个元素开始，分别取到第3,4,5…n个元素的字符串，判断是否是回文数</li><li>从第3个元素开始，分别取到第4,5…n个元素的字符串，判断是否是回文数</li><li>…</li><li>从第n个元素开始，分别取到第n个元素的字符串，判断是否是回文数</li></ul><p>从上面的结果中取出最大长度就是答案。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">rev</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<br>    reverse(s.begin(), s.end());<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">string</span> s;<br>    getline(<span class="hljs-built_in">cin</span>, s);<br>    <span class="hljs-keyword">int</span> n = s.size();<br>    <span class="hljs-keyword">int</span> maxLength = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> len = <span class="hljs-number">1</span>; len &lt;= n - i; len++) &#123; <span class="hljs-comment">// len是每次选择的长度</span><br>            <span class="hljs-keyword">if</span> (s.substr(i, len) == rev(s.substr(i, len))) &#123;<br>                maxLength = max(maxLength, len);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, maxLength);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>C++读取一行元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">getline(<span class="hljs-built_in">cin</span>, s);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>双指针</tag>
      
      <tag>滑动窗口</tag>
      
      <tag>回文数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1423. 可获得的最大点数</title>
    <link href="/2021/02/06/1423-%E5%8F%AF%E8%8E%B7%E5%BE%97%E7%9A%84%E6%9C%80%E5%A4%A7%E7%82%B9%E6%95%B0/"/>
    <url>/2021/02/06/1423-%E5%8F%AF%E8%8E%B7%E5%BE%97%E7%9A%84%E6%9C%80%E5%A4%A7%E7%82%B9%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="1423-可获得的最大点数"><a href="#1423-可获得的最大点数" class="headerlink" title="1423. 可获得的最大点数"></a><a href="https://leetcode-cn.com/problems/maximum-points-you-can-obtain-from-cards/">1423. 可获得的最大点数</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/Inp0x9.png" alt="Inp0x9"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题考查 <strong>前缀和</strong>和<strong>双指针</strong></p><p>依次按下面规则计算出和进行比较(<strong>某段范围内的和使用前缀和实现</strong>)。</p><ul><li>首先取左边0个元素和，右边k个元素和</li><li>再取左边1个元素和，右边k-1个元素和</li><li>取左边2个元素和，右边k-2个元素和</li><li>….</li><li>最后取左边k个元素和，右边0个元素和</li></ul><p>上面的最大和就是结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= k; i++) &#123;<br><span class="hljs-comment">// sum([0, i]) + sum([n - k + i, n - 1]);</span><br>maxSum = max(maxSum, preSum[i] + preSum[n] - preSum[n - k + i]);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxScore</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; cardPoints, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = cardPoints.size();<br>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">preSum</span><span class="hljs-params">(n+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            preSum[i + <span class="hljs-number">1</span>] = preSum[i] + cardPoints[i];<br>        &#125;<br>        <span class="hljs-keyword">int</span> maxSum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= k; i++) &#123;<br>        maxSum = max(maxSum, preSum[i] + preSum[n] - preSum[n - k + i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxSum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>前缀和</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1043 Is It a Binary Search Tree (25 分)</title>
    <link href="/2021/02/05/1043-Is-It-a-Binary-Search-Tree-25-%E5%88%86/"/>
    <url>/2021/02/05/1043-Is-It-a-Binary-Search-Tree-25-%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1043-Is-It-a-Binary-Search-Tree-25-分"><a href="#1043-Is-It-a-Binary-Search-Tree-25-分" class="headerlink" title="1043 Is It a Binary Search Tree (25 分)"></a>1043 Is It a Binary Search Tree (25 分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/ivcz6j.png" alt="ivcz6j"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题考查<strong>二叉搜索树的建立</strong></p><p>判断给出序列是否是二叉搜索树或镜像二叉搜索树的前序遍历。</p><p><del>分别根据输入建立二叉搜索树和镜像二叉搜索数</del></p><p>先使用二叉搜索树建立的模板建立一颗二叉树。模板如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">TreeNode* <span class="hljs-title">insert</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) &#123;<br>        root = <span class="hljs-keyword">new</span> TreeNode;<br>        root-&gt;val = val;<br>        root-&gt;left = root-&gt;right = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (root-&gt; val &gt; val) &#123;<br>        root-&gt;left = insert(root-&gt;left, val);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        root-&gt;right = insert(root-&gt;right, val);<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后先求出该树的先序遍历，而该树的镜像的先序遍历就只需要先访问树的右结点，再访问树的左结点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfsMirror</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    tempMirror.push_back(root-&gt;val);<br>    dfsMirror(root-&gt;right);<br>    dfsMirror(root-&gt;left);<br>&#125;<br></code></pre></td></tr></table></figure><p>最后判断给出序列是否是该树或者该树的镜像树的先序遍历。若是输出它的后续遍历，而后续遍历经过发现，就是它的镜像树的先序遍历从后往前输出即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span> &#123;</span><br>    <span class="hljs-keyword">int</span> val;<br>    TreeNode *left, *right;<br>&#125;;<br><br><span class="hljs-function">TreeNode* <span class="hljs-title">insert</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) &#123;<br>        root = <span class="hljs-keyword">new</span> TreeNode;<br>        root-&gt;val = val;<br>        root-&gt;left = root-&gt;right = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (root-&gt; val &gt; val) &#123;<br>        root-&gt;left = insert(root-&gt;left, val);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        root-&gt;right = insert(root-&gt;right, val);<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; temp, tempMirror;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    temp.push_back(root-&gt;val);<br>    dfs(root-&gt;left);<br>    dfs(root-&gt;right);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfsMirror</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    tempMirror.push_back(root-&gt;val);<br>    dfsMirror(root-&gt;right);<br>    dfsMirror(root-&gt;left);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">origin</span><span class="hljs-params">(n)</span></span>;<br>    TreeNode *root = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; origin[i];<br>        root = insert(root, origin[i]); <span class="hljs-comment">// 建立二叉树</span><br>    &#125;<br>    dfs(root);<br>    dfsMirror(root);<br><br>    <span class="hljs-keyword">if</span> (origin == temp) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;YES\n&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, tempMirror[i]);<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (origin == tempMirror) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;YES\n&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, temp[i]);<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NO\n&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><ul><li><a href="https://emhui.fun/2021/01/30/1115-Counting-Nodes-in-a-BST-30%E5%88%86/">1115 Counting Nodes in a BST (30分)</a></li><li><a href="https://emhui.fun/2021/01/20/1066-Root-of-AVL-Tree/">1066 Root of AVL Tree</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>bst</tag>
      
      <tag>二叉搜索树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1035 Password (20 分)</title>
    <link href="/2021/02/05/1035-Password-20-%E5%88%86/"/>
    <url>/2021/02/05/1035-Password-20-%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1035-Password-20-分"><a href="#1035-Password-20-分" class="headerlink" title="1035 Password (20 分)"></a>1035 Password (20 分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/DkY1lt.png" alt="DkY1lt"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>题目意思</p><p>字符串中</p><ul><li><code>1,l</code>容易混淆</li><li><code>0,O</code>容易混淆</li></ul><p>解决方法，按照下面规则替换</p><ul><li><code>1 -&gt; @</code></li><li><code>0 -&gt; %</code></li><li><code>l -&gt; L</code></li><li><code>O -&gt; o</code></li></ul><p>注意，题目要求只需要修改密码部分。</p><p>题目比较简单，直接对上面四种情况进行判断即可。</p><p>这里使用<code>pair&lt;string, string&gt;</code>存储<code>account, password</code></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;utility&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">string</span> account, passowrd;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-built_in">string</span>,<span class="hljs-built_in">string</span>&gt;&gt; vpss;<br>    <span class="hljs-keyword">bool</span> isModify = <span class="hljs-literal">false</span>;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; account &gt;&gt; passowrd;<br>        isModify = <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 1-@,0-%,l-L,O-o</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; passowrd.size(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (passowrd[i] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                passowrd[i] = <span class="hljs-string">&#x27;@&#x27;</span>;<br>                isModify = <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (passowrd[i] == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>                passowrd[i] = <span class="hljs-string">&#x27;%&#x27;</span>;<br>                isModify = <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (passowrd[i] == <span class="hljs-string">&#x27;l&#x27;</span>) &#123;<br>                passowrd[i] = <span class="hljs-string">&#x27;L&#x27;</span>;<br>                isModify = <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (passowrd[i] == <span class="hljs-string">&#x27;O&#x27;</span>) &#123;<br>                passowrd[i] = <span class="hljs-string">&#x27;o&#x27;</span>;<br>                isModify = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (isModify) &#123;<br>            vpss.push_back(<span class="hljs-built_in">make_pair</span>(account, passowrd));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">int</span> size = vpss.size();<br>    <span class="hljs-keyword">if</span> (size &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, size);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s %s\n&quot;</span>, vpss[i].first.c_str(), vpss[i].second.c_str());<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;There is 1 account and no account is modified\n&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;There are %d accounts and no account is modified\n&quot;</span>, n);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1030 Travel Plan (30 分)</title>
    <link href="/2021/02/05/1030-Travel-Plan-30-%E5%88%86/"/>
    <url>/2021/02/05/1030-Travel-Plan-30-%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1030-Travel-Plan-30-分"><a href="#1030-Travel-Plan-30-分" class="headerlink" title="1030 Travel Plan (30 分)"></a>1030 Travel Plan (30 分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/ZFsGSY.png" alt="ZFsGSY"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题考察<strong>求有附加条件的最短路径</strong>和<strong>打印出唯一最短路径</strong></p><p>最短路径求解模板如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> n; <span class="hljs-comment">// 结点数量</span><br><span class="hljs-comment">// pre 存储最短路径中，每一个结点的前一个结点</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; pre, visited, dis;<br><span class="hljs-keyword">int</span> G[u][v]; <span class="hljs-comment">// 邻接矩阵</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span> </span>&#123;<br>dis[s] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) pre[i] = i;<br><span class="hljs-built_in">priority_queue</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt;, greater&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt;&gt; pq;<br>pq.push(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">0</span>, s));<br><span class="hljs-keyword">while</span> (!pq.empty()) &#123;<br><span class="hljs-keyword">int</span> u = pq.top().second;<br><span class="hljs-keyword">if</span> (visited[u]) <span class="hljs-keyword">continue</span>;<br>visited[u] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v = <span class="hljs-number">0</span>; v &lt; n; v++) &#123;<br><span class="hljs-keyword">if</span> (!visited[v] &amp;&amp; G[u][v] != INF &amp;&amp; dis[u] + G[u][v] &lt; dis[v]) &#123;<br>dis[v] = dis[u] + G[u][v];<br>pre[v] = u; <span class="hljs-comment">// 更新上一个结点</span><br>pq.push(<span class="hljs-built_in">make_pair</span>(dis[v], v));<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里<code>pre</code>存储的是最短路径，打印的话需要使用后续遍历，从后往前打印，代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (v == s) &#123; <span class="hljs-comment">// 如果到了起点</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, v);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>dfs(pre[v]);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, v);<br>&#125;<br></code></pre></td></tr></table></figure><p>本题中，若最短路径相同，则比较最小花费，所以只需要在更新<code>v</code>的参数这块进行判断，代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v = <span class="hljs-number">0</span>; v &lt; n; v++) &#123;<br><span class="hljs-keyword">if</span> (!visited[v] &amp;&amp; G[u][v] != INF) &#123;<br><span class="hljs-keyword">if</span> (dis[u] + G[u][v] &lt; dis[v]) &#123;<br>dis[v] = dis[u] + G[u][v];<br>cost[v] = cost[u] + Cost[u][v];<br>pre[v] = u;<br>pq.push(<span class="hljs-built_in">make_pair</span>(dis[v], v));<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dis[u] + G[u][v] == dis[v]) &#123;<br><span class="hljs-keyword">if</span> (cost[u] + Cost[u][v] &lt; cost[v]) &#123;<br>cost[v] = cost[u] + Cost[u][v];<br>pre[v] = u;<br>pq.push(<span class="hljs-built_in">make_pair</span>(dis[v], v));<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h2 id="方法一：使用Priority-queue实现Dijkstra"><a href="#方法一：使用Priority-queue实现Dijkstra" class="headerlink" title="方法一：使用Priority_queue实现Dijkstra"></a>方法一：使用Priority_queue实现Dijkstra</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;utility&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">501</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">987654321</span>;<br><br><span class="hljs-keyword">int</span> G[MAX][MAX], Cost[MAX][MAX];<br><span class="hljs-keyword">int</span> n, m, s, d;<br><span class="hljs-keyword">int</span> dis[MAX], cost[MAX], pre[MAX];<br><span class="hljs-keyword">bool</span> visited[MAX] = &#123;<span class="hljs-literal">false</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span> </span>&#123;<br>    fill(dis, dis + MAX, INF);<br>    fill(cost, cost + MAX, INF);<br>    <span class="hljs-comment">// 最小堆</span><br>    <span class="hljs-built_in">priority_queue</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt;, greater&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt;&gt; pq;<br>    dis[s] = <span class="hljs-number">0</span>;<br>    cost[s] = <span class="hljs-number">0</span>;<br>    pq.push(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">0</span>, s));<br>    <span class="hljs-keyword">while</span> (!pq.empty()) &#123;<br>        <span class="hljs-keyword">int</span> u = pq.top().second;<br>        pq.pop();<br>        <span class="hljs-keyword">if</span> (visited[u]) <span class="hljs-keyword">continue</span>;<br>        visited[u] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v = <span class="hljs-number">0</span>; v &lt; n; v++) &#123;<br>            <span class="hljs-keyword">if</span> (!visited[v] &amp;&amp; G[u][v] != INF) &#123;<br>                <span class="hljs-keyword">if</span> (dis[u] + G[u][v] &lt; dis[v]) &#123;<br>                    dis[v] = dis[u] + G[u][v];<br>                    cost[v] = cost[u] + Cost[u][v];<br>                    pre[v] = u;<br>                    pq.push(<span class="hljs-built_in">make_pair</span>(dis[v], v));<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dis[u] + G[u][v] == dis[v]) &#123;<br>                    <span class="hljs-keyword">if</span> (cost[u] + Cost[u][v] &lt; cost[v]) &#123;<br>                        cost[v] = cost[u] + Cost[u][v];<br>                        pre[v] = u;<br>                        pq.push(<span class="hljs-built_in">make_pair</span>(dis[v], v));<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (x == s) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, s);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    dfs(pre[x]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; d;<br>    <span class="hljs-keyword">int</span> id1, id2;<br>    fill(G[<span class="hljs-number">0</span>], G[<span class="hljs-number">0</span>] + MAX*MAX, INF);<br>    fill(Cost[<span class="hljs-number">0</span>], Cost[<span class="hljs-number">0</span>] + MAX*MAX, INF);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; id1 &gt;&gt; id2;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; G[id1][id2] &gt;&gt; Cost[id1][id2];<br>        G[id2][id1] = G[id1][id2];<br>        Cost[id2][id1] = Cost[id1][id2];<br>    &#125;<br>    Dijkstra(s);<br>    dfs(d);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>,dis[d], cost[d]);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法二：传统Dijkstra"><a href="#方法二：传统Dijkstra" class="headerlink" title="方法二：传统Dijkstra"></a>方法二：传统Dijkstra</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;utility&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">501</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">987654321</span>;<br><br><span class="hljs-keyword">int</span> G[MAX][MAX], Cost[MAX][MAX];<br><span class="hljs-keyword">int</span> n, m, s, d;<br><span class="hljs-keyword">int</span> dis[MAX], cost[MAX], pre[MAX];<br><span class="hljs-keyword">bool</span> visited[MAX] = &#123;<span class="hljs-literal">false</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span> </span>&#123;<br>    fill(dis, dis + MAX, INF);<br>    fill(cost, cost + MAX, INF);<br>    dis[s] = <span class="hljs-number">0</span>;<br>    cost[s] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) pre[i] = i;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">int</span> u = <span class="hljs-number">-1</span>, MIN = INF;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (!visited[j] &amp;&amp; dis[j] &lt; MIN) &#123;<br>                u = j;<br>                MIN = dis[j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (u == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span>;<br>        visited[u] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v = <span class="hljs-number">0</span>; v &lt; n; v++) &#123;<br>            <span class="hljs-keyword">if</span> (!visited[v] &amp;&amp; G[u][v] != INF) &#123;<br>                <span class="hljs-keyword">if</span> (dis[u] + G[u][v] &lt; dis[v]) &#123;<br>                    dis[v] = dis[u] + G[u][v];<br>                    cost[v] = cost[u] + Cost[u][v];<br>                    pre[v] = u;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dis[u] + G[u][v] == dis[v]) &#123;<br>                    <span class="hljs-keyword">if</span> (cost[u] + Cost[u][v] &lt; cost[v]) &#123;<br>                        cost[v] = cost[u] + Cost[u][v];<br>                        pre[v] = u;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (x == s) &#123;<br>        <span class="hljs-comment">//printf(&quot;%d &quot;, x);</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    dfs(pre[x]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, pre[x]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; d;<br>    <span class="hljs-keyword">int</span> id1, id2;<br>    fill(G[<span class="hljs-number">0</span>], G[<span class="hljs-number">0</span>] + MAX*MAX, INF);<br>    fill(Cost[<span class="hljs-number">0</span>], Cost[<span class="hljs-number">0</span>] + MAX*MAX, INF);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; id1 &gt;&gt; id2;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; G[id1][id2] &gt;&gt; Cost[id1][id2];<br>        G[id2][id1] = G[id1][id2];<br>        Cost[id2][id1] = Cost[id1][id2];<br>    &#125;<br>    Dijkstra(s);<br>    <span class="hljs-comment">// 打印出总花费</span><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans;<br>    <span class="hljs-comment">// int sum = 0;</span><br>    <span class="hljs-keyword">int</span> end = d;<br>    <span class="hljs-keyword">while</span> (s != d) &#123;<br>        d = pre[d];<br>        ans.push_back(d);<br>    &#125;<br>    <span class="hljs-comment">// ans.push_back(s);</span><br>    <span class="hljs-comment">// 打印总距离，总成本</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = ans.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, ans[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d %d\n&quot;</span>, end, dis[end], cost[end]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相似题目"><a href="#相似题目" class="headerlink" title="相似题目"></a>相似题目</h2><ul><li><a href="https://emhui.fun/2021/01/31/1111-Online-Map-30%E5%88%86/">1111 Online Map (30分)</a></li><li><a href="https://emhui.fun/2021/01/20/1087-All-Roads-Lead-to-Rome/">1087 All Roads Lead to Rome</a></li><li><a href="https://emhui.fun/2021/01/19/1018-Public-Bike-Management/">1018 Public Bike Management</a></li><li><a href="https://emhui.fun/2021/01/31/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-Dijkstra%E6%A8%A1%E6%9D%BF/">最短路径 Dijkstra模板</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>Dijkstra</tag>
      
      <tag>最短路径</tag>
      
      <tag>优先队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1024 Palindromic Number (25 分)</title>
    <link href="/2021/02/05/1024-Palindromic-Number-25-%E5%88%86/"/>
    <url>/2021/02/05/1024-Palindromic-Number-25-%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1024-Palindromic-Number-25-分"><a href="#1024-Palindromic-Number-25-分" class="headerlink" title="1024 Palindromic Number (25 分)"></a>1024 Palindromic Number (25 分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/yUU9qd.png" alt="yUU9qd"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题考察 <strong>判断回文数</strong>和<strong>两数相加</strong></p><p><strong>两数相加</strong>一般使用字符串来实现，而如果使用字符串的话，那么判断回文数也就变得简单起来了。下面两段代码分别是两数相加和判断回文数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 判断是否是回文数 s == rev(s)</span><br><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">rev</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<br>    reverse(s.begin(), s.end());<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br><br><span class="hljs-comment">// 两个数字相加</span><br><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<br>    <span class="hljs-built_in">string</span> rev_s = rev(s);<br>    <span class="hljs-keyword">int</span> remainder = <span class="hljs-number">0</span>, n = s.length();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">int</span> num = (s[i] - <span class="hljs-string">&#x27;0&#x27;</span>) + (rev_s[i] - <span class="hljs-string">&#x27;0&#x27;</span>) + remainder;<br>        s[i] = num % <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;0&#x27;</span>;<br>        remainder = num / <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (remainder &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;1&quot;</span> + s;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> s;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>本题中注意，如果该字符串本身是回文数，那么需要输出本身，并且次数为0。</p><p>例如：<br>输入</p><blockquote><p>12321 5</p></blockquote><p>输出</p><blockquote><p>12321 0</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">rev</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<br>    reverse(s.begin(), s.end());<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<br>    <span class="hljs-built_in">string</span> rev_s = rev(s);<br>    <span class="hljs-keyword">int</span> remainder = <span class="hljs-number">0</span>, n = s.length();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">int</span> num = (s[i] - <span class="hljs-string">&#x27;0&#x27;</span>) + (rev_s[i] - <span class="hljs-string">&#x27;0&#x27;</span>) + remainder;<br>        s[i] = num % <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;0&#x27;</span>;<br>        remainder = num / <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (remainder &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;1&quot;</span> + s;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> s;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">string</span> s, ans;<br>    <span class="hljs-keyword">int</span> k;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; s &gt;&gt; k;<br>    <span class="hljs-keyword">if</span> (s == rev(s)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n0&quot;</span>, s.c_str());<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span>  i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= k; i++) &#123;<br>        s = add(s);<br>        <span class="hljs-keyword">if</span> (s == rev(s)) <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n%d\n&quot;</span>, s.c_str(), i &lt;=k ? i : k);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相似题目"><a href="#相似题目" class="headerlink" title="相似题目"></a>相似题目</h2><ul><li><a href="https://emhui.fun/2021/01/25/1136-A-Delayed-Palindrome-20%E5%88%86/">1136 A Delayed Palindrome (20分)</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>回文数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1013 Battle Over Cities (25 分)</title>
    <link href="/2021/02/04/1013-Battle-Over-Cities-25-%E5%88%86/"/>
    <url>/2021/02/04/1013-Battle-Over-Cities-25-%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1013-Battle-Over-Cities-25-分"><a href="#1013-Battle-Over-Cities-25-分" class="headerlink" title="1013 Battle Over Cities (25 分)"></a>1013 Battle Over Cities (25 分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/NKatyr.png" alt="NKatyr"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题考察 <strong>去除某个结点后连通分量个数</strong>。</p><p>先使用一个<code>vector&lt;int, int&gt; edges</code>记录所有的边。然后在查询中，绕过查询的结点，计算剩下结点的连通分量。连通分量使用并查集来求比较方便。</p><p>注意: 求到的连通分量需要-2</p><ul><li>去除被敌人占据的结点</li><li>n个连通分量需要n-1条边才能连通。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 记录输入的值，每次重建并查集,同时计算连通分量，连通分量-2就是需要链接的数量。</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;utility&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">int</span> setCount;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; parent;<br><span class="hljs-keyword">int</span> n, m, k; <span class="hljs-comment">// 题目给出</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (x != parent[x]) &#123;<br>        parent[x] = find(parent[x]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> parent[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>    u = find(u), v = find(v);<br>    <span class="hljs-keyword">if</span> (u == v) <span class="hljs-keyword">return</span>;<br>    parent[u] = v;<br>    setCount--;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    setCount = n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n + <span class="hljs-number">1</span>; i++) parent[i] = i;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> u, v; <span class="hljs-comment">// 待输入</span><br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt; edges;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; u &gt;&gt; v;<br>        edges.push_back(<span class="hljs-built_in">make_pair</span>(u,v));<br>    &#125;<br>    <span class="hljs-comment">// 处理父亲结点</span><br>    parent.resize(n + <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">int</span> query;<br>    <span class="hljs-keyword">while</span> (k--) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; query;<br>        init();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            u = edges[i].first, v = edges[i].second;<br>            <span class="hljs-keyword">if</span> (u == query || v == query) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (find(u) != find(v)) &#123;<br>                merge(u, v);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 求到的连通分量需要-2，去除被敌人占据的+n个连通分量需要n-1条边才能连通。</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, setCount - <span class="hljs-number">2</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
      <tag>union-find</tag>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1012 The Best Rank (25 分)</title>
    <link href="/2021/02/04/1012-The-Best-Rank-25-%E5%88%86/"/>
    <url>/2021/02/04/1012-The-Best-Rank-25-%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1012-The-Best-Rank-25-分"><a href="#1012-The-Best-Rank-25-分" class="headerlink" title="1012 The Best Rank (25 分)"></a>1012 The Best Rank (25 分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/d1bn7Z.png" alt="d1bn7Z"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题考察<strong>结构体排序</strong>。</p><p>求出每们成绩的排名。然后输出他们各个成绩中排名最佳的那个课程和排名。</p><p>因为有四个成绩，所有得分别对每个成绩进行排序，如果在查询的时候对他们排序，会出现超时，因此可以使用<code>Rank[1000000][4]</code>来预先对它们进行排名。</p><p>同时成绩最好按照<code>&#123;&#39;A&#39;, &#39;C&#39;, &#39;M&#39;, &#39;E&#39;&#125;</code>的顺序来先后排序。最后输出也是要按照这个优先级。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (now = <span class="hljs-number">0</span>; now &lt; <span class="hljs-number">4</span>; now++) &#123;<br>sort(stu, stu + n, cmp);<br>Rank[stu[<span class="hljs-number">0</span>].id][now] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br><span class="hljs-keyword">if</span> (stu[i].grade[now] == stu[i - <span class="hljs-number">1</span>].grade[now]) &#123; <span class="hljs-comment">// 和之前排名一样</span><br>Rank[stu[i].id][now] = Rank[stu[i - <span class="hljs-number">1</span>].id][now];<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>Rank[stu[i].id][now] = i + <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">2000</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span>&#123;</span><br>    <span class="hljs-keyword">int</span> id;<br>    <span class="hljs-keyword">int</span> grade[<span class="hljs-number">4</span>];<br>&#125;stu[MAX];<br><br><span class="hljs-keyword">int</span> Rank[<span class="hljs-number">1000000</span>][<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// 每个用户的排名</span><br><br><span class="hljs-keyword">int</span> now = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">char</span> course[<span class="hljs-number">4</span>] = &#123;<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;M&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Student&amp; a, Student &amp;b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a.grade[now] &gt; b.grade[now];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, m;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>,&amp;stu[i].id, &amp;stu[i].grade[<span class="hljs-number">1</span>], &amp;stu[i].grade[<span class="hljs-number">2</span>], &amp;stu[i].grade[<span class="hljs-number">3</span>]);<br>        stu[i].grade[<span class="hljs-number">0</span>] = round(<span class="hljs-number">1.0</span> * (stu[i].grade[<span class="hljs-number">1</span>] + stu[i].grade[<span class="hljs-number">2</span>] + stu[i].grade[<span class="hljs-number">3</span>]) / <span class="hljs-number">3</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 开始排序并且设置排名</span><br>    <span class="hljs-keyword">for</span> (now = <span class="hljs-number">0</span>; now &lt; <span class="hljs-number">4</span>; now++) &#123;<br>        sort(stu, stu + n, cmp);<br>        Rank[stu[<span class="hljs-number">0</span>].id][now] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (stu[i].grade[now] == stu[i - <span class="hljs-number">1</span>].grade[now]) &#123; <span class="hljs-comment">// 和之前排名一样</span><br>                Rank[stu[i].id][now] = Rank[stu[i - <span class="hljs-number">1</span>].id][now];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                Rank[stu[i].id][now] = i + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">int</span> id;<br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;id);<br>        <span class="hljs-keyword">if</span> (Rank[id][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;N/A\n&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">int</span> maxRank = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>                <span class="hljs-keyword">if</span> (Rank[id][maxRank] &gt; Rank[id][i]) &#123; <span class="hljs-comment">// 找到排名最高的，就是值最小的</span><br>                    maxRank = i;<br>                &#125;<br>            &#125;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %c\n&quot;</span>, Rank[id][maxRank], course[maxRank]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>数组</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>643. 子数组最大平均数 I</title>
    <link href="/2021/02/04/643-%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E6%95%B0-I/"/>
    <url>/2021/02/04/643-%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E6%95%B0-I/</url>
    
    <content type="html"><![CDATA[<h1 id="643-子数组最大平均数-I"><a href="#643-子数组最大平均数-I" class="headerlink" title="643. 子数组最大平均数 I"></a><a href="https://leetcode-cn.com/problems/maximum-average-subarray-i/">643. 子数组最大平均数 I</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定 n 个整数，找出平均数最大且长度为 k 的连续子数组，并输出该最大平均数。</p><p>示例：</p><blockquote><p>输入：[1,12,-5,-6,50,3], k = 4</p><p>输出：12.75</p><p>解释：最大平均数 (12-5-6+50)/4 = 51/4 = 12.75</p></blockquote><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>使用前缀和求出某个范围内的值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">preSum</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>preSum[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>preSum[i + <span class="hljs-number">1</span>] = preSum[i] + nums[i];<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/RWxUMT.png" alt="RWxUMT"></p><p>这里需要注意两点</p><ul><li>preSum[0] 应该为<code>-10000</code>,因为nums的范围是<code>[-10000, 10000]</code>。</li><li>[i,j]之间的和为<code>preSum[i+n] - preSum[i]</code>。</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">findMaxAverage</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">// 使用前缀和，求出某个范围内最大的值</span><br>        <span class="hljs-keyword">int</span> n = nums.size();<br>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">preSum</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        preSum[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            preSum[i + <span class="hljs-number">1</span>] = preSum[i] + nums[i];<br>        &#125;<br>        <span class="hljs-comment">// 因为存在负数，所以这里不能设置为0</span><br>        <span class="hljs-keyword">double</span> maxAverage = <span class="hljs-number">-10000</span>;<br>        <span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (idx + k &lt; n + <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">double</span> average = <span class="hljs-number">1.0</span> * (preSum[idx + k] - preSum[idx]) / k;<br>            maxAverage = max(maxAverage, average);<br>            idx++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxAverage;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>前缀和</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1089 Insert or Merge (25 分)</title>
    <link href="/2021/02/03/1089-Insert-or-Merge-25-%E5%88%86/"/>
    <url>/2021/02/03/1089-Insert-or-Merge-25-%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1089-Insert-or-Merge-25-分"><a href="#1089-Insert-or-Merge-25-分" class="headerlink" title="1089 Insert or Merge (25 分)"></a>1089 Insert or Merge (25 分)</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/xv3r5Q.png" alt="xv3r5Q"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题查考 <strong>插入排序</strong> 和 <strong>归并排序</strong>的流程。先判断是否是插入排序，这个比较简单。</p><p>插入排序怎么写</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 2, 3, 1, 5</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insertSort</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br><span class="hljs-keyword">int</span> j = i;<br><span class="hljs-keyword">while</span> (j - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j] &lt; arr[j - <span class="hljs-number">1</span>]) &#123;<br>swap(arr[j], arr[j<span class="hljs-number">-1</span>]);<br>j--;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insertSort</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br><span class="hljs-keyword">int</span> temp = arr[i], j = i;<br><span class="hljs-keyword">while</span> (j - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; temp &lt; arr[j - <span class="hljs-number">1</span>]) &#123;<br>swap(arr[j], arr[j<span class="hljs-number">-1</span>]);<br>j--;<br>&#125;<br>arr[j] = temp;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>归并排序怎么写？</p><p>归并排序是先俩俩排序，再渐渐合并俩俩，最终变成一个大的排序</p><p>以下是递归的三种实现方法</p><p>方法一：小规模排序使用<code>sort</code>替代了<code>merge</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> step = <span class="hljs-number">2</span>; step / <span class="hljs-number">2</span> &lt;= n; step *= <span class="hljs-number">2</span>) &#123; <span class="hljs-comment">// 时间复杂度 O(logn)</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i += step) &#123;<br> sort(temp.begin() + i, temp.begin() + min(i + step, n));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法二：使用递归，非递归和<code>merge</code>实现归并排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> A[], <span class="hljs-keyword">int</span> l1, <span class="hljs-keyword">int</span> r1, <span class="hljs-keyword">int</span> l2, <span class="hljs-keyword">int</span> r2)</span> </span>&#123;<br><span class="hljs-keyword">int</span> i = l1, j = l2, idx = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> temp[MAX];<br><span class="hljs-keyword">while</span> (i &lt;= r1 &amp;&amp; j &lt;= r2) &#123;<br><span class="hljs-keyword">if</span> (A[i] &lt;= A[j]) temp[idx++] = A[i++];<br><span class="hljs-keyword">else</span> temp[idx++] = A[j++];<br>&#125;<br><span class="hljs-keyword">while</span> (i &lt;= r1) temp[idx++] = A[i++];<br><span class="hljs-keyword">while</span> (j &lt;= r2) temp[idx++] = A[j++];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; idx; i++) &#123;<br>A[l1 + i] = temp[i];<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 递归实现</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> A[], <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (l &gt; r) <span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>mergeSort(A, l, mid);<br>mergeSort(A, mid + <span class="hljs-number">1</span>, r);<br>merge(A, l, mid, mid + <span class="hljs-number">1</span>, r);<br>&#125;<br><br><span class="hljs-comment">// 非递归实现</span><br><span class="hljs-keyword">int</span> n; <span class="hljs-comment">// 序列数量</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 为什么step/2 &lt;= n;</span><br><span class="hljs-comment">// 因为当step = step/2 的时候，只剩下最后两组序列需要归并了。</span><br><span class="hljs-comment">// step &gt; step/2 已经是最后一组了，无需归并</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> step = <span class="hljs-number">2</span>; step / <span class="hljs-number">2</span> &lt;= n; step *= <span class="hljs-number">2</span>) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i += step) &#123;<br><span class="hljs-keyword">int</span> l = i, r = min(i + step, n);<br><span class="hljs-comment">// 这里需要注意，每个区间元素个数 step, 所以mid应该是 i + step / 2 - 1.</span><br><span class="hljs-keyword">int</span> mid = l + step / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (mid + <span class="hljs-number">1</span> &lt; n) &#123;<br>merge(A, l, mid, mid + <span class="hljs-number">1</span>, r);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，本题中初始序列不参与比较。即不能在还没有排序的时候就去比较是否找到了结果。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">int</span> n;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; origin, target, temp;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">insertSort</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (i != <span class="hljs-number">1</span> &amp;&amp; temp == target) flag = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 原始序列不参与排序</span><br>        <span class="hljs-keyword">int</span> j = i;<br>        <span class="hljs-keyword">while</span> (j - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; temp[j] &lt; temp[j - <span class="hljs-number">1</span>]) &#123;<br>            swap(temp[j], temp[j - <span class="hljs-number">1</span>]);<br>            j--;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (flag) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> step = <span class="hljs-number">2</span>; step / <span class="hljs-number">2</span> &lt;= n; step *= <span class="hljs-number">2</span>) &#123; <span class="hljs-comment">// 时间复杂度 O(logn)</span><br>        <span class="hljs-keyword">if</span> (step != <span class="hljs-number">2</span> &amp;&amp; temp == target) flag = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i += step) &#123;<br>            sort(temp.begin() + i, temp.begin() + min(i + step, n));<br>        &#125;<br>        <span class="hljs-keyword">if</span> (flag) <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    origin.resize(n), target.resize(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) <span class="hljs-built_in">cin</span> &gt;&gt; origin[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) <span class="hljs-built_in">cin</span> &gt;&gt; target[i];<br>    temp = origin;<br>    <span class="hljs-keyword">if</span> (insertSort()) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Insertion Sort\n&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, temp[i]);<br>            <span class="hljs-keyword">if</span> (i &lt; n - <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        temp = origin;<br>        mergeSort();<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Merge Sort\n&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, temp[i]);<br>            <span class="hljs-keyword">if</span> (i &lt; n - <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>排序</tag>
      
      <tag>归并排序</tag>
      
      <tag>插入排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1083 List Grades (25 分)</title>
    <link href="/2021/02/02/1083-List-Grades-25-%E5%88%86/"/>
    <url>/2021/02/02/1083-List-Grades-25-%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1083-List-Grades-25-分"><a href="#1083-List-Grades-25-分" class="headerlink" title="1083 List Grades (25 分)"></a>1083 List Grades (25 分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/oW2RoK.png" alt="oW2RoK"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题考察</p><ul><li>结构体排序</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><br>    <span class="hljs-built_in">string</span> name, id;<br>    <span class="hljs-keyword">int</span> grade;<br>    node(<span class="hljs-built_in">string</span> _name, <span class="hljs-built_in">string</span> _id, <span class="hljs-keyword">int</span> _grade): name(_name), id(_id), grade(_grade) &#123;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(node &amp;a, node &amp;b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a.grade &gt; b.grade;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, grade1, grade2, grade;<br>    <span class="hljs-built_in">string</span> name, id;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <span class="hljs-built_in">vector</span>&lt;node&gt; vn;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; name &gt;&gt; id &gt;&gt; grade;<br>        vn.push_back(node(name, id, grade));<br>    &#125;<br>    sort(vn.begin(), vn.end(), cmp);<br>    <span class="hljs-built_in">cin</span> &gt;&gt; grade1 &gt;&gt; grade2;<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (vn[i].grade &gt;= grade1 &amp;&amp; vn[i].grade &lt;= grade2) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s %s\n&quot;</span>,vn[i].name.c_str(), vn[i].id.c_str());<br>            cnt++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (cnt == <span class="hljs-number">0</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NONE\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>数组</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1084 Broken Keyboard (20 分)</title>
    <link href="/2021/02/02/1084-Broken-Keyboard-20-%E5%88%86/"/>
    <url>/2021/02/02/1084-Broken-Keyboard-20-%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1084-Broken-Keyboard-20-分"><a href="#1084-Broken-Keyboard-20-分" class="headerlink" title="1084 Broken Keyboard (20 分)"></a>1084 Broken Keyboard (20 分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/pE3exE.png" alt="pE3exE"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题主要是使用<strong>哈希表记录按键数量</strong></p><p>其中两个问题要解决</p><ul><li>小写字符转大写</li><li>如何按序输出坏键</li></ul><p><strong>需要将所有小写字符转成大写</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">ch - <span class="hljs-string">&#x27;a&#x27;</span> + <span class="hljs-string">&#x27;A&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>输出需要按照原来的顺序输出。这一步怎么实现?</strong></p><p>使用一个变量<code>has[128]</code>记录使用键盘键入的字符串中每个字符的数量，然后再去原始的字符串中按顺序进行删除操作。若出现<code>has[i] &lt; 0</code>证明该键是缺失的，同时题目要求坏键只输出一遍，因此在用<code>visited[i]</code>记录当前坏键是否已经访问，若没有访问就打印出来，并标记为已经访问。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">81</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">switch2capital</span><span class="hljs-params">(<span class="hljs-keyword">char</span> ch)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (ch &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;z&#x27;</span>) &#123;<br>            ch = ch - <span class="hljs-string">&#x27;a&#x27;</span> + <span class="hljs-string">&#x27;A&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ch;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">char</span> origin[MAX], type_out[MAX], ch;<br>    <span class="hljs-keyword">char</span> has[<span class="hljs-number">128</span>] =&#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">bool</span> visited[<span class="hljs-number">128</span>] = &#123;<span class="hljs-literal">false</span>&#125;;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%s&quot;</span>, origin, type_out);<br>    <span class="hljs-keyword">int</span> m = <span class="hljs-built_in">strlen</span>(origin), n = <span class="hljs-built_in">strlen</span>(type_out);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        ch = switch2capital(type_out[i]);<br>        has[ch]++;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        ch = switch2capital(origin[i]);<br>        has[ch]--;<br>        <span class="hljs-keyword">if</span> (has[ch] &lt; <span class="hljs-number">0</span> &amp;&amp; !visited[ch]) &#123;<br>            visited[ch] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, ch);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1085 Perfect Sequence (25 分)</title>
    <link href="/2021/02/02/1085-Perfect-Sequence-25-%E5%88%86/"/>
    <url>/2021/02/02/1085-Perfect-Sequence-25-%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1085-Perfect-Sequence-25-分"><a href="#1085-Perfect-Sequence-25-分" class="headerlink" title="1085 Perfect Sequence (25 分)"></a>1085 Perfect Sequence (25 分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/yQuGfG.png" alt="yQuGfG"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题需要满足$M&lt;=m*p$。因此可以先对序列进行排序，然后设置两个指针<code>i = 0,j = 0</code>。</p><p>当满足<code>arr[j] &lt;= arr[i] * p</code>的时候，不断的让<code>j</code>进行右移，在移动过程中，始终维护一个<code>count</code>，该值为<code>i,j</code>最大的范围。若不满足$M &lt;= m * p$,则让<code>i</code>进行右移。</p><p>流程如下</p><table><thead><tr><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>20</th></tr></thead><tbody><tr><td>i,j</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>i</td><td>j</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>i</td><td>-</td><td>j</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>i</td><td>-</td><td>-</td><td>j</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>i</td><td>-</td><td>-</td><td>-</td><td>j</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>i</td><td>-</td><td>-</td><td>-</td><td>-</td><td>j</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>i</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>j</td><td>-</td><td>-</td><td>-</td></tr><tr><td>i</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>j</td><td>-</td><td>-</td></tr><tr><td>-</td><td>i</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>j</td><td>-</td><td>-</td></tr><tr><td>-</td><td>i</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>j</td><td>-</td></tr><tr><td>-</td><td>-</td><td>i</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>j</td></tr></tbody></table><p>上面的流程写成代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (j &lt; n) &#123;<br><span class="hljs-keyword">while</span> (j &lt; n &amp;&amp; arr[j] &lt;= (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)arr[i] * p) &#123;<br>count = max(count, j - i + <span class="hljs-number">1</span>);<br>j++;<br>&#125;<br>i++;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, p;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; p;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">arr</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) <span class="hljs-built_in">cin</span> &gt;&gt; arr[i];<br>    sort(arr.begin(), arr.end());<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (j &lt; n) &#123;<br>        <span class="hljs-keyword">while</span> (j &lt; n &amp;&amp; arr[j] &lt;= (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)arr[i] * p) &#123;<br>            count = max(count, j - i + <span class="hljs-number">1</span>);<br>            j++;<br>        &#125;<br>        i++;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d</span><br><span class="hljs-string">&quot;</span>, count);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><ul><li><a href="https://emhui.fun/2021/02/02/424-%E6%9B%BF%E6%8D%A2%E5%90%8E%E7%9A%84%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6-%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89/">424. 替换后的最长重复字符 - 力扣（LeetCode）</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>双指针</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1095 Cars on Campus (30分)</title>
    <link href="/2021/02/02/1095-Cars-on-Campus-30%E5%88%86/"/>
    <url>/2021/02/02/1095-Cars-on-Campus-30%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1095-Cars-on-Campus-30分"><a href="#1095-Cars-on-Campus-30分" class="headerlink" title="1095 Cars on Campus (30分)"></a>1095 Cars on Campus (30分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/z8WDFU.png" alt="z8WDFU"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>将所有数据按照姓名排序，然后在按照时间先后排序。选出有效的数据，其中时间可以转化为秒进行比较。</p><p>当<code>if(同一个车牌 &amp;&amp; 当前是进入停车 &amp;&amp; 下一个是驶出停车)</code>的时候为有效数据，具体代码如下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br><span class="hljs-comment">// 若同一辆车在连续有效时间内进出，则该车为有效</span><br><span class="hljs-keyword">if</span> (vn[i].nubmer == vn[i + <span class="hljs-number">1</span>].nubmer &amp;&amp; vn[i].flag == <span class="hljs-literal">true</span> &amp;&amp; vn[i + <span class="hljs-number">1</span>].flag == <span class="hljs-literal">false</span>) &#123;<br>vaildCar[vn[i].nubmer].push_back(<span class="hljs-built_in">make_pair</span>(vn[i].time, vn[i + <span class="hljs-number">1</span>].time));<br><span class="hljs-comment">// 统计有效车辆停留的时间。</span><br><span class="hljs-keyword">if</span> (carTime.find(vn[i].nubmer) == carTime.end()) &#123;<br>carTime[vn[i].nubmer] = vn[i + <span class="hljs-number">1</span>].time - vn[i].time;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>carTime[vn[i].nubmer] += vn[i + <span class="hljs-number">1</span>].time - vn[i].time;<br>&#125;<br><span class="hljs-comment">// 计算出最大时间</span><br>longestTime = max(longestTime, carTime[vn[i].nubmer]);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><blockquote><p>下面这个代码会超时</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;utility&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt;&gt; vaildCar; <span class="hljs-comment">// 记录有效的车进出时间</span><br><span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt; carTime; <span class="hljs-comment">// 车子停留时间</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span><br>    <span class="hljs-built_in">string</span> nubmer;<br>    <span class="hljs-keyword">bool</span> flag; <span class="hljs-comment">// flag 为 true表示in， flag为false表示out</span><br>    <span class="hljs-keyword">int</span> time;<br>    node()&#123;&#125;<br>    node(<span class="hljs-built_in">string</span> _number, <span class="hljs-keyword">int</span> _time, <span class="hljs-keyword">int</span> _flag): nubmer(_number), time(_time), flag(_flag) &#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">// 时分秒转成秒为单位</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hms2s</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hh, <span class="hljs-keyword">int</span> mm, <span class="hljs-keyword">int</span> ss)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> hh * <span class="hljs-number">3600</span> + mm * <span class="hljs-number">60</span> + ss;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(node &amp;a, node &amp;b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (a.nubmer != b.nubmer) <span class="hljs-keyword">return</span> a.nubmer &lt; b.nubmer;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> a.time &lt; b.time;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, k;<br>    <span class="hljs-built_in">string</span> number, flag;<br>    <span class="hljs-keyword">int</span> hh, mm, ss;<br>    <span class="hljs-built_in">vector</span>&lt;node&gt; vn;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; k;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; number;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d:%d:%d&quot;</span>, &amp;hh, &amp;mm, &amp;ss);<br>        <span class="hljs-built_in">cin</span> &gt;&gt; flag;<br>        vn.push_back(node(number, hms2s(hh, mm, ss), flag == <span class="hljs-string">&quot;in&quot;</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>));<br>    &#125;<br>    <span class="hljs-comment">// 根据车牌号和进出时间排序</span><br>    sort(vn.begin(), vn.end(), cmp);<br>    <span class="hljs-keyword">int</span> longestTime = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-comment">// 若同一辆车在连续有效时间内进出，则该车为有效</span><br>        <span class="hljs-keyword">if</span> (vn[i].nubmer == vn[i + <span class="hljs-number">1</span>].nubmer &amp;&amp; vn[i].flag == <span class="hljs-literal">true</span> &amp;&amp; vn[i + <span class="hljs-number">1</span>].flag == <span class="hljs-literal">false</span>) &#123;<br>            vaildCar[vn[i].nubmer].push_back(<span class="hljs-built_in">make_pair</span>(vn[i].time, vn[i + <span class="hljs-number">1</span>].time));<br>            <span class="hljs-comment">// 统计有效车辆停留的时间。</span><br>            <span class="hljs-keyword">if</span> (carTime.find(vn[i].nubmer) == carTime.end()) &#123;<br>                carTime[vn[i].nubmer] = vn[i + <span class="hljs-number">1</span>].time - vn[i].time;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                carTime[vn[i].nubmer] += vn[i + <span class="hljs-number">1</span>].time - vn[i].time;<br>            &#125;<br>            <span class="hljs-comment">// 计算出最大时间</span><br>            longestTime = max(longestTime, carTime[vn[i].nubmer]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>, time;<br><br>    <span class="hljs-keyword">while</span> (k--) &#123;<br>        cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d:%d:%d&quot;</span>, &amp;hh, &amp;mm, &amp;ss);<br>        time = hms2s(hh, mm, ss);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;car: vaildCar) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; car.second.size(); i++) &#123;<br>                <span class="hljs-keyword">if</span> (time &gt;= car.second[i].first &amp;&amp; time &lt; car.second[i].second) &#123;<br>                    cnt++;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, cnt);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;car: carTime) &#123;<br>        <span class="hljs-keyword">if</span> (car.second == longestTime) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s &quot;</span>, car.first.c_str());<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%02d:%02d:%02d\n&quot;</span>, longestTime / <span class="hljs-number">3600</span>, (longestTime % <span class="hljs-number">3600</span> ) / <span class="hljs-number">60</span>, longestTime % <span class="hljs-number">60</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>424. 替换后的最长重复字符 - 力扣（LeetCode）</title>
    <link href="/2021/02/02/424-%E6%9B%BF%E6%8D%A2%E5%90%8E%E7%9A%84%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6-%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89/"/>
    <url>/2021/02/02/424-%E6%9B%BF%E6%8D%A2%E5%90%8E%E7%9A%84%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6-%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="424-替换后的最长重复字符-力扣（LeetCode）"><a href="#424-替换后的最长重复字符-力扣（LeetCode）" class="headerlink" title="424. 替换后的最长重复字符 - 力扣（LeetCode）"></a><a href="https://leetcode-cn.com/problems/longest-repeating-character-replacement">424. 替换后的最长重复字符 - 力扣（LeetCode）</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 k 次。在执行上述操作后，找到包含重复字母的最长子串的长度。</p><p>注意：字符串长度 和 k 不会超过 104。</p><p><strong>示例1</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：s = <span class="hljs-string">&quot;ABAB&quot;</span>, k = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">4</span><br>解释：用两个&#x27;A&#x27;替换为两个&#x27;B&#x27;,反之亦然。<br></code></pre></td></tr></table></figure><p><strong>示例2</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lsl">输入：s = <span class="hljs-string">&quot;AABABBA&quot;</span>, k = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">4</span><br>解释：<br>将中间的一个&#x27;A&#x27;替换为&#x27;B&#x27;,字符串变为 <span class="hljs-string">&quot;AABBBBA&quot;</span>。<br>子串 <span class="hljs-string">&quot;BBBB&quot;</span> 有最长重复字母, 答案为 <span class="hljs-number">4</span>。<br></code></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题需要维护一个最大范围的滑动窗口。同时该滑动窗口需要移动，扩张和收缩<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="C++最详细题解！">[1]</span></a></sup>。</p><p>使用<code>left,right</code>记录滑动窗口范围，同时使用<code>max_count</code>统计当前窗口内出现某个字符出现最多的次数。若当<code>right - left + 1 - max_count &gt; k</code>证明<code>k</code>值不够用，这是就需要进行收缩，同时<code>left</code>所在的字符出现的频率也要<code>-1</code>.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">characterReplacement</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>, max_count = <span class="hljs-number">0</span>, n = s.length();<br>        <span class="hljs-keyword">int</span> freq[<span class="hljs-number">26</span>] = &#123;<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// 记录s中left-right之间单词出现的频率</span><br>        <span class="hljs-keyword">while</span> (right &lt; n) &#123;<br>            freq[s[right] - <span class="hljs-string">&#x27;A&#x27;</span>]++; <span class="hljs-comment">//</span><br>            max_count = max(max_count, freq[s[right] - <span class="hljs-string">&#x27;A&#x27;</span>]); <span class="hljs-comment">// 计算当前的l-r范围内出现次数的的字符数量</span><br>            <span class="hljs-comment">// k的数量不够，需要进行收缩</span><br>            <span class="hljs-keyword">if</span> (right - left + <span class="hljs-number">1</span> - max_count &gt; k) &#123;<br>                freq[s[left] - <span class="hljs-string">&#x27;A&#x27;</span>]--; <span class="hljs-comment">// 字符收缩</span><br>                left++;<br><br>            &#125;<br>            ans = max(ans, right - left + <span class="hljs-number">1</span>);<br>            right++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><section class="footnotes"><h2>参考</h2><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://leetcode-cn.com/problems/longest-repeating-character-replacement/solution/czui-xiang-xi-ti-jie-by-heroding-olgt/">C++最详细题解！</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>双指针</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1100 Mars Numbers (20分)</title>
    <link href="/2021/02/01/1100-Mars-Numbers-20%E5%88%86/"/>
    <url>/2021/02/01/1100-Mars-Numbers-20%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1100-Mars-Numbers-20分"><a href="#1100-Mars-Numbers-20分" class="headerlink" title="1100 Mars Numbers (20分)"></a>1100 Mars Numbers (20分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h2 id="1100-Mars-Numbers-20分-1"><a href="#1100-Mars-Numbers-20分-1" class="headerlink" title="1100 Mars Numbers (20分)"></a>1100 Mars Numbers (20分)</h2><p>People on Mars count their numbers with base 13:</p><ul><li>Zero on Earth is called “tret” on Mars.<br>The numbers 1 to 12 on Earth is called “jan, feb, mar, apr, may, jun, jly, aug, sep, oct, nov, dec” on Mars, respectively.</li><li>For the next higher digit, Mars people name the 12 numbers as “tam, hel, maa, huh, tou, kes, hei, elo, syy, lok, mer, jou”, respectively.</li><li>For examples, the number 29 on Earth is called “hel mar” on Mars; and “elo nov” on Mars corresponds to 115 on Earth. In order to help communication between people from these two planets, you are supposed to write a program for mutual translation between Earth and Mars number systems.</li></ul><p><strong>Input Specification:</strong></p><p>Each input file contains one test case. For each case, the first line contains a positive integer N (&lt;100). Then N lines follow, each contains a number in [0, 169), given either in the form of an Earth number, or that of Mars.</p><p><strong>Output Specification:</strong></p><p>For each number, print in a line the corresponding number in the other language.</p><p><strong>Sample Input:</strong></p><blockquote><p>4</p><p>29</p><p>5</p><p>elo nov</p><p>tam</p></blockquote><p><strong>Sample Output:</strong></p><blockquote><p>hel mar</p><p>may</p><p>115</p><p>13</p></blockquote><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题的火星数字为13进制，由于题目中告知了转换的火星文数字范围在<code>169</code>以内，因此可以将<code>169</code>个值全部算出来。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">string</span> lowDigit[<span class="hljs-number">13</span>] = &#123;<span class="hljs-string">&quot;tret&quot;</span>, <span class="hljs-string">&quot;jan&quot;</span>, <span class="hljs-string">&quot;feb&quot;</span>, <span class="hljs-string">&quot;mar&quot;</span>, <span class="hljs-string">&quot;apr&quot;</span>, <span class="hljs-string">&quot;may&quot;</span>, <span class="hljs-string">&quot;jun&quot;</span>, <span class="hljs-string">&quot;jly&quot;</span>, <span class="hljs-string">&quot;aug&quot;</span>, <span class="hljs-string">&quot;sep&quot;</span>, <span class="hljs-string">&quot;oct&quot;</span>, <span class="hljs-string">&quot;nov&quot;</span>, <span class="hljs-string">&quot;dec&quot;</span>&#125;;<br><span class="hljs-built_in">string</span> highDigit[<span class="hljs-number">13</span>] = &#123;<span class="hljs-string">&quot;tret&quot;</span>, <span class="hljs-string">&quot;tam&quot;</span>, <span class="hljs-string">&quot;hel&quot;</span>, <span class="hljs-string">&quot;maa&quot;</span>, <span class="hljs-string">&quot;huh&quot;</span>, <span class="hljs-string">&quot;tou&quot;</span>, <span class="hljs-string">&quot;kes&quot;</span>, <span class="hljs-string">&quot;hei&quot;</span>, <span class="hljs-string">&quot;elo&quot;</span>, <span class="hljs-string">&quot;syy&quot;</span>, <span class="hljs-string">&quot;lok&quot;</span>, <span class="hljs-string">&quot;mer&quot;</span>, <span class="hljs-string">&quot;jou&quot;</span>&#125;<br></code></pre></td></tr></table></figure><p>把所有结果都计算出来</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt; mars2earth;<br><span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">string</span>&gt; earth2mars;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">13</span>; i++) &#123;<br><span class="hljs-comment">// 低位 (0 - 12)</span><br>earth2mars[i] = lowDigit[i];<br>mars2earth[lowDigit[i]] = i;<br><span class="hljs-comment">// 高位 (0 - 12) * 13</span><br>earth2mars[i * <span class="hljs-number">13</span>] = highDigit[i];<br>mars2earth[highDigit[i]] = i * <span class="hljs-number">13</span>;<br>&#125;<br><span class="hljs-comment">// 计算其他位置的值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">13</span>; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">13</span>; j++) &#123;<br><span class="hljs-built_in">string</span> s = highDigit[i] + <span class="hljs-string">&quot; &quot;</span> + lowDigit[j];<br>earth2mars[i * <span class="hljs-number">13</span> + j] = s;<br>mars2earth[s] = i * <span class="hljs-number">13</span> + j;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：这里的输入需要读取一整行，一整行的输入使用<code>getline()</code>.</p><p><code>getline</code>的用法<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="C++ 每次读取一行字符串输入">[1]</span></a></sup></p><blockquote><p>注意的是：当 getline(cin, str);前面的输入是cin&gt;&gt;ss;的话，那么此处str的值时空的，因为他会读取上一行的结束符。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">getline(<span class="hljs-built_in">cin</span>, str)<br></code></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-built_in">string</span> lowDigit[<span class="hljs-number">13</span>] = &#123;<span class="hljs-string">&quot;tret&quot;</span>, <span class="hljs-string">&quot;jan&quot;</span>, <span class="hljs-string">&quot;feb&quot;</span>,<br>                       <span class="hljs-string">&quot;mar&quot;</span>, <span class="hljs-string">&quot;apr&quot;</span>, <span class="hljs-string">&quot;may&quot;</span>,<br>                       <span class="hljs-string">&quot;jun&quot;</span>, <span class="hljs-string">&quot;jly&quot;</span>, <span class="hljs-string">&quot;aug&quot;</span>,<br>                       <span class="hljs-string">&quot;sep&quot;</span>, <span class="hljs-string">&quot;oct&quot;</span>, <span class="hljs-string">&quot;nov&quot;</span>, <span class="hljs-string">&quot;dec&quot;</span>&#125;;<br><span class="hljs-built_in">string</span> highDigit[<span class="hljs-number">13</span>] = &#123;<span class="hljs-string">&quot;tret&quot;</span>, <span class="hljs-string">&quot;tam&quot;</span>, <span class="hljs-string">&quot;hel&quot;</span>,<br>                        <span class="hljs-string">&quot;maa&quot;</span>, <span class="hljs-string">&quot;huh&quot;</span>, <span class="hljs-string">&quot;tou&quot;</span>,<br>                        <span class="hljs-string">&quot;kes&quot;</span>, <span class="hljs-string">&quot;hei&quot;</span>, <span class="hljs-string">&quot;elo&quot;</span>,<br>                        <span class="hljs-string">&quot;syy&quot;</span>, <span class="hljs-string">&quot;lok&quot;</span>, <span class="hljs-string">&quot;mer&quot;</span>, <span class="hljs-string">&quot;jou&quot;</span>&#125;;<br><br><span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt; mars2earth;<br><span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">string</span>&gt; earth2mars;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">13</span>; i++) &#123;<br>        <span class="hljs-comment">// 低位 (0 - 12)</span><br>        earth2mars[i] = lowDigit[i];<br>        mars2earth[lowDigit[i]] = i;<br>        <span class="hljs-comment">// 高位 (0 - 12) * 13</span><br>        earth2mars[i * <span class="hljs-number">13</span>] = highDigit[i];<br>        mars2earth[highDigit[i]] = i * <span class="hljs-number">13</span>;<br>    &#125;<br>    <span class="hljs-comment">// 计算所有的值</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">13</span>; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">13</span>; j++) &#123;<br>            <span class="hljs-built_in">string</span> s = highDigit[i] + <span class="hljs-string">&quot; &quot;</span> + lowDigit[j];<br>            earth2mars[i * <span class="hljs-number">13</span> + j] = s;<br>            mars2earth[s] = i * <span class="hljs-number">13</span> + j;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    init();<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">string</span> s;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    getchar(); <span class="hljs-comment">// 吸收回车字符串</span><br>    <span class="hljs-keyword">while</span> (n--) &#123;<br>        getline(<span class="hljs-built_in">cin</span>, s); <span class="hljs-comment">// 读取一行数据</span><br>        <span class="hljs-keyword">if</span> (s[<span class="hljs-number">0</span>] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s[<span class="hljs-number">0</span>] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>            <span class="hljs-built_in">cout</span> &lt;&lt; earth2mars[stoi(s)] &lt;&lt; <span class="hljs-built_in">endl</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">cout</span> &lt;&lt; mars2earth[s] &lt;&lt; <span class="hljs-built_in">endl</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><section class="footnotes"><h2>参考</h2><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://blog.csdn.net/lwgkzl/article/details/53232889">C++ 每次读取一行字符串输入</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>哈希表</tag>
      
      <tag>数组</tag>
      
      <tag>进制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1101 Quick Sort (25分)</title>
    <link href="/2021/02/01/1101-Quick-Sort-25%E5%88%86/"/>
    <url>/2021/02/01/1101-Quick-Sort-25%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1101-Quick-Sort-25分"><a href="#1101-Quick-Sort-25分" class="headerlink" title="1101 Quick Sort (25分)"></a>1101 Quick Sort (25分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="1101-Quick-Sort-25分-1"><a href="#1101-Quick-Sort-25分-1" class="headerlink" title="1101 Quick Sort (25分)"></a>1101 Quick Sort (25分)</h3><p>There is a classical process named partition in the famous quick sort algorithm. In this process we typically choose one element as the pivot. Then the elements less than the pivot are moved to its left and those larger than the pivot to its right. Given N distinct positive integers after a run of partition, could you tell how many elements could be the selected pivot for this partition?</p><p>For example, given N=5 and the numbers 1, 3, 2, 4, and 5. We have:</p><ul><li>1 could be the pivot since there is no element to its left and all the elements to its right are larger than it;</li><li>3 must not be the pivot since although all the elements to its left are smaller, the number 2 to its right is less than it as well;</li><li>2 must not be the pivot since although all the elements to its right are larger, the number 3 to its left is larger than it as well;</li><li>and for the similar reason, 4 and 5 could also be the pivot.<br>Hence in total there are 3 pivot candidates.</li></ul><p><strong>Input Specification:</strong></p><p>Each input file contains one test case. For each case, the first line gives a positive integer N (≤10^5). Then the next line contains N distinct positive integers no larger than 10^9. The numbers in a line are separated by spaces.</p><p><strong>Output Specification:</strong></p><p>For each test case, output in the first line the number of pivot candidates. Then in the next line print these candidates in increasing order. There must be exactly 1 space between two adjacent numbers, and no extra space at the end of each line.</p><p><strong>Sample Input:</strong></p><blockquote><p>5</p><p>1 3 2 4 5</p></blockquote><p><strong>Sample Output:</strong></p><blockquote><p>3</p><p>1 4 5</p></blockquote><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>每个数字都要左右去比较，那么肯定会超时。能否使用两个数组记录第i个数的左边的最大值和右边的最小值为多少呢？当满足<code>arr[i] &gt; max_left &amp;&amp; arr[i] &lt; min_right</code>。则这个数可能是<code>pivot</code></p><ul><li><p>左边最大值</p></li><li><p>右边最小值</p><p>每次和这个最大值最小值比较就可以</p></li></ul><p>使用两个数组来分别遍历和存储左边的最大值和右边的最小值？</p><p>如下所示</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//  1, 3, 2, 4, 5.</span><br><br><span class="hljs-keyword">int</span> max_l[MAX], min_r[MAX];<br><br>max_l[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<br>max_l[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>max_l[<span class="hljs-number">2</span>] = <span class="hljs-number">3</span>;<br>max_l[<span class="hljs-number">3</span>] = <span class="hljs-number">3</span>;<br>max_l[<span class="hljs-number">4</span>] = <span class="hljs-number">4</span>;<br><br>max_l[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>max_l[i + <span class="hljs-number">1</span>] = arr[i] &gt; max_l[i] ? arr[i] : max_l[i];<br>&#125;<br><br><span class="hljs-comment">// 1, 3, 2, 4, 5.</span><br><br>min_r[<span class="hljs-number">4</span>] = <span class="hljs-number">1e9</span>;<br>min_r[<span class="hljs-number">3</span>] = <span class="hljs-number">5</span>;<br>min_r[<span class="hljs-number">2</span>] = <span class="hljs-number">4</span>;<br>min_r[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>min_r[<span class="hljs-number">0</span>] = <span class="hljs-number">2</span>;<br><br>min_r[n - <span class="hljs-number">1</span>] =<span class="hljs-number">1e9</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">1</span>; i--) &#123;<br>min_r[i - <span class="hljs-number">1</span>] = arr[i] &lt; min_r[i] ? arr[i] : min_r[i];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INT_MAX = <span class="hljs-number">1e9</span> + <span class="hljs-number">1</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    vector&lt;int&gt; arr(n), max_l(n), min_r(n), ans;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) <span class="hljs-built_in">cin</span> &gt;&gt; arr[i];<br><br>    max_l[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>, min_r[n - <span class="hljs-number">1</span>] = INT_MAX;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>    max_l[i + <span class="hljs-number">1</span>] = arr[i] &gt; max_l[i] ? arr[i] : max_l[i];<br><br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>    min_r[i - <span class="hljs-number">1</span>] = arr[i] &lt; min_r[i] ? arr[i] : min_r[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (arr[i] &gt; max_l[i] &amp;&amp; arr[i] &lt; min_r[i]) &#123;<br>            ans.push_back(arr[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">int</span> size = ans.size();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, size);<br>    sort(ans.begin(), ans.end());<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ans[i]);<br>        <span class="hljs-keyword">if</span> (i &lt; size - <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>不知道能不能等于号，在目前的用例中，加不加无所谓。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br><span class="hljs-comment">// if (arr[i] &gt;= max_l[i] &amp;&amp; arr[i] =&lt; min_r[i]) &#123;</span><br><span class="hljs-keyword">if</span> (arr[i] &gt; max_l[i] &amp;&amp; arr[i] &lt; min_r[i]) &#123;<br>ans.push_back(arr[i]);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
      <tag>快速排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1105 Spiral Matrix (25分)</title>
    <link href="/2021/02/01/1105-Spiral-Matrix-25%E5%88%86/"/>
    <url>/2021/02/01/1105-Spiral-Matrix-25%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1105-Spiral-Matrix-25分"><a href="#1105-Spiral-Matrix-25分" class="headerlink" title="1105 Spiral Matrix (25分)"></a>1105 Spiral Matrix (25分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="1105-Spiral-Matrix-25分-1"><a href="#1105-Spiral-Matrix-25分-1" class="headerlink" title="1105 Spiral Matrix (25分)"></a>1105 Spiral Matrix (25分)</h3><p>This time your job is to fill a sequence of N positive integers into a spiral matrix in non-increasing order. A spiral matrix is filled in from the first element at the upper-left corner, then move in a clockwise spiral. The matrix has m rows and n columns, where m and n satisfy the following: m×n must be equal to N; m≥n; and m−n is the minimum of all the possible values.</p><p><strong>Input Specification:</strong></p><p>Each input file contains one test case. For each case, the first line gives a positive integer N. Then the next line contains N positive integers to be filled into the spiral matrix. All the numbers are no more than 10^4. The numbers in a line are separated by spaces.</p><p><strong>Output Specification:</strong></p><p>For each test case, output the resulting matrix in m lines, each contains n numbers. There must be exactly 1 space between two adjacent numbers, and no extra space at the end of each line.</p><p><strong>Sample Input:</strong></p><blockquote><p>12</p><p>37 76 20 98 76 42 53 95 60 81 58 93</p></blockquote><p><strong>Sample Output:</strong></p><blockquote><p>98 95 93</p><p>42 37 81</p><p>53 20 76</p><p>58 60 76</p></blockquote><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>用一段递减的序列，从左上角开始，顺时针填充一个m*n大小的矩阵。</p><ol><li><p>m 和 n 如何求？</p></li><li><p>如何顺时针填充？</p></li></ol><blockquote><p>12</p><p>37 76 20 98 76 42 53 95 60 81 58 93</p></blockquote><p>先排序</p><blockquote><p>98 95 93 81 76 76 60 58 53 42 37 20</p></blockquote><p>然后求 m 和 n 的大小</p><p>$min{|m&gt;n|}$, $m &gt; n$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> size = n;<br><span class="hljs-keyword">int</span> m = <span class="hljs-built_in">ceil</span>(<span class="hljs-built_in">sqrt</span>(size)); <span class="hljs-comment">// 向上取整</span><br><span class="hljs-keyword">while</span> (size % m != <span class="hljs-number">0</span>) &#123;m++;&#125;<br>n = size / m;<br></code></pre></td></tr></table></figure><p>接下来就是如何填充。设置四个变量，每次填充完成一圈，就向内收缩</p><blockquote><p>98 95 93 81 76 76 60 58 53 42 37 20</p></blockquote><blockquote><p>98 95 93</p><p>42 37 81</p><p>53 20 76</p><p>58 60 76</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>, top = <span class="hljs-number">0</span>, bottom = m - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>, i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (idx &lt; size) &#123;<br><span class="hljs-keyword">while</span> (idx &lt; size &amp;&amp; j &lt; right) &#123;<br>martix[i][j++] = vi[idx++];<br>&#125;<br><span class="hljs-keyword">while</span> (idx &lt; size &amp;&amp; i &lt; bottom) &#123;<br>martix[i++][j] = vi[idx++];<br>&#125;<br><span class="hljs-keyword">while</span> (idx &lt; size &amp;&amp; j &gt; left) &#123;<br>martix[i][j--] = vi[idx++];<br>&#125;<br><span class="hljs-keyword">while</span> (idx &lt; size &amp;&amp; i &gt; top) &#123;<br>martix[i--][j] = vi[idx++];<br>&#125;<br>top++, right--, bottom--, left++;<br><br>i++, j++; <span class="hljs-comment">// 移动到下一个</span><br><br><span class="hljs-keyword">if</span> (idx == size - <span class="hljs-number">1</span>) &#123;<br>martix[i][j] = vi[idx++];<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意只有一个元素的时候，直接返回</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">vi</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<span class="hljs-built_in">cin</span> &gt;&gt; vi[i];&#125;<br><br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, vi[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    sort(vi.begin(), vi.end(), greater&lt;<span class="hljs-keyword">int</span>&gt;());<br>    <span class="hljs-keyword">int</span> size = n;<br>    <span class="hljs-keyword">int</span> m = <span class="hljs-built_in">ceil</span>(<span class="hljs-built_in">sqrt</span>(size));<br>    <span class="hljs-keyword">while</span> (size % m != <span class="hljs-number">0</span>) &#123;m++;&#125;<br>    n = size / m;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">martix</span><span class="hljs-params">(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n, <span class="hljs-number">-1</span>))</span></span>;<br><br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>, top = <span class="hljs-number">0</span>, bottom = m - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>, i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (idx &lt; size) &#123;<br>        <span class="hljs-keyword">while</span> (idx &lt; size &amp;&amp; j &lt; right) &#123;<br>            martix[i][j++] = vi[idx++];<br>        &#125;<br>        <span class="hljs-keyword">while</span> (idx &lt; size &amp;&amp; i &lt; bottom) &#123;<br>            martix[i++][j] = vi[idx++];<br>        &#125;<br>        <span class="hljs-keyword">while</span> (idx &lt; size &amp;&amp; j &gt; left) &#123;<br>            martix[i][j--] = vi[idx++];<br>        &#125;<br>        <span class="hljs-keyword">while</span> (idx &lt; size &amp;&amp; i &gt; top) &#123;<br>            martix[i--][j] = vi[idx++];<br>        &#125;<br>        top++, right--, bottom--, left++;<br><br>        i++, j++; <span class="hljs-comment">// 移动到下一个</span><br><br>        <span class="hljs-keyword">if</span> (idx == size - <span class="hljs-number">1</span>) &#123;<br>            martix[i][j] = vi[idx++];<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, martix[i][j]);<br>            <span class="hljs-keyword">if</span> (j &lt; n - <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>数学</tag>
      
      <tag>数组</tag>
      
      <tag>图形</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1104 Sum of Number Segments (20分)</title>
    <link href="/2021/02/01/1104-Sum-of-Number-Segments-20%E5%88%86/"/>
    <url>/2021/02/01/1104-Sum-of-Number-Segments-20%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1104-Sum-of-Number-Segments-20分"><a href="#1104-Sum-of-Number-Segments-20分" class="headerlink" title="1104 Sum of Number Segments (20分)"></a>1104 Sum of Number Segments (20分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/CVyd6y.png" alt="CVyd6y"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><strong>题目意思</strong></p><p>给定一个序列，求出他们的总和</p><blockquote><p>sequence { 0.1, 0.2, 0.3, 0.4 }, we have 10 segments: (0.1) (0.1, 0.2) (0.1, 0.2, 0.3) (0.1, 0.2, 0.3, 0.4) (0.2) (0.2, 0.3) (0.2, 0.3, 0.4) (0.3) (0.3, 0.4) and (0.4).</p></blockquote><p>he sum of all the 10 segments is 0.1 + 0.3 + 0.6 + 1.0 + 0.2 + 0.5 + 0.9 + 0.3 + 0.7 + 0.4 = 5.0.</p><p>本题不难，可以使用下面的方法进行暴力遍历，但是肯定会运行超时。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-keyword">double</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-title">vi</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; vi[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">int</span> idx = i;<br>        <span class="hljs-keyword">while</span> (idx++ &lt; n) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &lt; idx; j++) &#123;<br>                sum += vi[j];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2lf\n&quot;</span>, sum);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>暴力不行，那就开始分析给出的数据。主要就是找到各个元素出现的次数有什么规律。</p><hr><p>{ 0.1, 0.2, 0.3, 0.4 },</p><p>看看各个数字出现次数</p><p>0.1 - 4<br>0.2 - 6<br>0.3 - 6<br>0.4 - 4</p><hr><p>{1,2,3,4,5}</p><p>1,<br>1,2<br>1,2,3<br>1,2,3,4<br>1,2,3,4,5</p><p>2,<br>2,3<br>2,3,4<br>2,3,4,5</p><p>3,<br>3,4<br>3,4,5</p><p>4,<br>4,5</p><p>5</p><p>1: 5 5 * 1<br>2: 8 4 * 2<br>3: 9 3 * 3<br>4: 8 2 * 4<br>5: 5 1 * 5</p><hr><p>{1,2,3,4,5,6}</p><p>1,<br>1,2<br>1,2,3<br>1,2,3,4<br>1,2,3,4,5<br>1,2,3,4,5,6</p><p>2,<br>2,3<br>2,3,4<br>2,3,4,5<br>2,3,4,5,6</p><p>3,<br>3,4<br>3,4,5<br>3,4,5,6</p><p>4,<br>4,5<br>4,5,6</p><p>5,<br>5,6</p><p>6</p><p>1: 6 6 * 1<br>2: 10 5 * 2<br>3: 12 4 * 3<br>4: 12 3 * 4<br>5: 10 2 * 5<br>6: 6 1 * 6</p><hr><p>所以规律等于</p><p>vi[i] 出现的次数为 (i + 1) * (n - i);</p><p>sum += vi[i] * (i + 1) * (n - i);</p><p>所以可以写出下面的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">// 经测试，用例中存在一个精度问题，不能使用double</span><br><span class="hljs-comment">// double 在大量运行过程中会出现精度丢失</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-keyword">double</span> sum = <span class="hljs-number">0</span>, val;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; val;<br>        sum += (val  * i * (n - i + <span class="hljs-number">1</span>));<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2lf\n&quot;</span>, sum / <span class="hljs-number">1000.0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是有一个用例没有通过，在网上看到别人写的<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="由一道 OJ 引发的关于 double 类型的一些思考">[1]</span></a></sup>，发现是doble精度问题。</p><p><strong>double在大量运算过程中会出现精度丢失，在涉及到金钱计算的程序中尽量不用。</strong></p><h2 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">// 经测试，用例中存在一个精度问题，不能使用double</span><br><span class="hljs-comment">// double 在大量运行过程中会出现精度丢失</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">double</span> val;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; val;<br>        sum += (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)((val * <span class="hljs-number">1000</span>) * i * (n - i + <span class="hljs-number">1</span>));<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2lf\n&quot;</span>, sum / <span class="hljs-number">1000.0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><section class="footnotes"><h2>参考</h2><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://blog.zhengrh.com/post/about-double/">由一道 OJ 引发的关于 double 类型的一些思考</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1108 Finding Average (20分)</title>
    <link href="/2021/01/31/1108-Finding-Average-20%E5%88%86/"/>
    <url>/2021/01/31/1108-Finding-Average-20%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1108-Finding-Average-20分"><a href="#1108-Finding-Average-20分" class="headerlink" title="1108 Finding Average (20分)"></a>1108 Finding Average (20分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/2VgDDa.png" alt="2VgDDa"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>给定n个数字，求平均值,过滤一些无效数据</p><blockquote><p>7</p><p>5 -3.2 aaa 9999 2.3.4 7.123 2.35</p></blockquote><p>如何判断输入值合法</p><ol><li>判断是否是数字，存在多个<code>.,-</code>符号。</li></ol><blockquote><p>主要过滤 aaa 2.3.4 -2-1-1 这类数据</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 判断是否是合格数字，存在多个.,-符号。</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isDigit</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> cnt_dot = <span class="hljs-number">0</span>, cnt_neg = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.size(); i++) &#123;<br>        <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;-&#x27;</span>) &#123;<br>            cnt_neg++;<br>            <span class="hljs-keyword">if</span> (cnt_neg &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 存在多个-号</span><br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>            cnt_dot++;<br>            <span class="hljs-keyword">if</span> (cnt_dot &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 存在多个小数点</span><br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(s[i] &lt; <span class="hljs-string">&#x27;0&#x27;</span> || s[i] &gt; <span class="hljs-string">&#x27;9&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>如何判断数字是否有效</li></ol><blockquote><p>主要过滤超过三位小数的数字，例如 1.234</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isVaildFact</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; s.size(); i++) &#123;<br>        <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;.&#x27;</span>) <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">// 不是小数直接返回</span><br>    <span class="hljs-keyword">if</span> (i == s.size()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> s.size() - i - <span class="hljs-number">1</span> &lt;= <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>过滤超出范围的数字</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isRange</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (n &gt;= <span class="hljs-number">-1000</span> &amp;&amp; n &lt;= <span class="hljs-number">1000</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">// 判断是否是合格数字，存在多个.,-符号。</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isDigit</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> cnt_dot = <span class="hljs-number">0</span>, cnt_neg = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.size(); i++) &#123;<br>        <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;-&#x27;</span>) &#123;<br>            cnt_neg++;<br>            <span class="hljs-keyword">if</span> (cnt_neg &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 存在多个-号</span><br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>            cnt_dot++;<br>            <span class="hljs-keyword">if</span> (cnt_dot &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 存在多个小数点</span><br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(s[i] &lt; <span class="hljs-string">&#x27;0&#x27;</span> || s[i] &gt; <span class="hljs-string">&#x27;9&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 1. 首先判断是否是合格小数</span><br><span class="hljs-comment">// 若发现小数点，则从小数开始枚举存在多少位</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isVaildFact</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; s.size(); i++) &#123;<br>        <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;.&#x27;</span>) <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">// 不是小数直接返回</span><br>    <span class="hljs-keyword">if</span> (i == s.size()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> s.size() - i - <span class="hljs-number">1</span> &lt;= <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, cnt_vaild = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">string</span> s;<br>    <span class="hljs-keyword">double</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; s;<br>        <span class="hljs-keyword">if</span> (isDigit(s) &amp;&amp; isVaildFact(s) &amp;&amp; (stod(s) &lt;= <span class="hljs-number">1000</span> &amp;&amp; stod(s) &gt;= <span class="hljs-number">-1000</span>)) &#123;<br>            sum += stod(s);<br>            cnt_vaild++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ERROR: %s is not a legal number\n&quot;</span>, s.c_str());<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (cnt_vaild == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The average of 0 numbers is Undefined\n&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cnt_vaild == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The average of 1 number is %.2lf\n&quot;</span>, sum);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The average of %d numbers is %.2lf\n&quot;</span>, cnt_vaild, sum / cnt_vaild);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1109 Group Photo (25分)</title>
    <link href="/2021/01/31/1109-Group-Photo-25%E5%88%86/"/>
    <url>/2021/01/31/1109-Group-Photo-25%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1109-Group-Photo-25分"><a href="#1109-Group-Photo-25分" class="headerlink" title="1109 Group Photo (25分)"></a>1109 Group Photo (25分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/KcGWj7.png" alt="KcGWj7"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>N个人按照K行排列，排列规则如下。</p><ol><li>每行人数 N/K, 向下取整，多的人在最后一行（在本题示例可以看到，排列和现实是反过来的，输出的第一行是现实的最后一行）</li><li>后面那行的人不得比前面的人矮</li><li>每行中，最高的站中间(m/2 + 1).</li><li>每行的身高中，按身高递减，先安排在最高的人右边，在安排在左边，反复该操作。（输出和现实是反的，在输出中，可以看到其实是先安排左边。）</li><li>当身高相同的时候，按照名字排</li></ol><p>第4条规则比较关键，大概意思如下。</p><blockquote><p>In each row, other people must enter the row in non-increasing order of their heights, alternately taking their positions first to the right and then to the left of the tallest one (For example, given five people with their heights 190, 188, 186, 175, and 170, the final formation would be 175, 188, 190, 186, and 170. Here we assume that you are facing the group so your left-hand side is the right-hand side of the one at the central position.);</p></blockquote><blockquote><p>在每行中，其他人必须以身高非递增序列，交替站在最高的人旁边，先是右边，然后在左边。<br>例如 190, 188, 186, 175, 170.</p><p>190</p><p>188 190</p><p>188 190 186</p><p>175 188 190 186</p><p>175 188 190 186 170</p></blockquote><p><strong>具体实现</strong></p><p>先按照高度由高到小进行排序，若高度相同，则按照姓名排序。</p><p>然后计算每组的人数<code>cols = n / k;</code>,其中最后一组的人数应该为<code>max_cols = n / k + n % k;</code></p><p>确定好每行站多少人，开始按照规则进行站队。用一个二维<code>string</code>数组存储每个人的名字</p><ol><li>首先选出最高的人站的位置<code>mid = cur_cols / 2</code>;</li><li>然后选出他左右人的位置<code>left = mid - 1, right = mid + 1</code></li><li>反复找出左右人的位置。若当<code>left &gt;= 0 || right &lt; cur_cols</code>证明该行所有人已经站好了。注意：如果<code>left == 0</code>证明最左边还有一个人，需要将他填上去。</li><li>最后输出<code>string</code>输出即可。</li></ol><p>主要代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br><span class="hljs-keyword">int</span> cur_cols = i == <span class="hljs-number">0</span> ? max_cols : cols;<br>mid = cur_cols / <span class="hljs-number">2</span>;<br>vvs[i][mid] = vp[idx++].first; <span class="hljs-comment">// 先放最高的人</span><br>left = mid - <span class="hljs-number">1</span>, right = mid + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt; cur_cols) &#123;<br>vvs[i][left--] = vp[idx++].first;<br>vvs[i][right++] = vp[idx++].first;<br>&#125;<br><span class="hljs-comment">// 如果cols 为偶数，那么一般左边会多一个人，当left=0时，这个位置还没有被填充。</span><br><span class="hljs-keyword">if</span> (left == <span class="hljs-number">0</span>) vvs[i][<span class="hljs-number">0</span>] = vp[idx++].first;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面是示例，当前已经按照身高排好序</p><ul><li>Joe 190</li><li>Tom 188</li><li>Nick 186</li><li>Bob 175</li><li>Mike 170</li><li>Ann 168</li><li>Eva 168</li><li>Amy 160</li><li>Tim 160</li><li>John 159</li></ul><p>先排最后一行</p><p>mid = 4 / 2 = 2</p><p>s[0][2] = Joe</p><p>left = 1, right = 3</p><p>s[0][1] = TOM</p><p>s[0][3] = Nick</p><p>left = 0 right = 4</p><p>s[0][0] = Bob</p><p>再排倒数第二行<br>mid = 3 / 2 = 1</p><p>s[1][1] = Mike</p><p>left = 0, right = 2</p><p>s[1][0] = ANN</p><p>s[1][2] = Eva</p><p>其他同理</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;utility&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt; a, <span class="hljs-built_in">pair</span>&lt;<span class="hljs-built_in">string</span>,<span class="hljs-keyword">int</span>&gt; b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (a.second != b.second) <span class="hljs-keyword">return</span> a.second &gt; b.second;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> a.first &lt; b.first;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, k, height;<br>    <span class="hljs-built_in">string</span> s;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; k;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt;&gt; vp;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; s &gt;&gt; height;<br>        vp.push_back(<span class="hljs-built_in">make_pair</span>(s, height));<br>    &#125;<br>    sort(vp.begin(), vp.end(), cmp); <span class="hljs-comment">// 按照身高从小到大排序</span><br><br>    <span class="hljs-keyword">int</span> cols = n / k, max_cols = n / k + n % k;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt; <span class="hljs-title">vvs</span><span class="hljs-params">(k, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;(max_cols))</span></span>;<br>    <span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> mid, left, right;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>        <span class="hljs-keyword">int</span> cur_cols = i == <span class="hljs-number">0</span> ? max_cols : cols;<br>        mid = cur_cols / <span class="hljs-number">2</span>;<br>        vvs[i][mid] = vp[idx++].first; <span class="hljs-comment">// 先放最高的人</span><br>        left = mid - <span class="hljs-number">1</span>, right = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt; cur_cols) &#123;<br>            vvs[i][left--] = vp[idx++].first;<br>            vvs[i][right++] = vp[idx++].first;<br>        &#125;<br>        <span class="hljs-comment">// 如果cols 为偶数，那么一般左边会多一个人，当left=0时，这个位置还没有被填充。</span><br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-number">0</span>) vvs[i][<span class="hljs-number">0</span>] = vp[idx++].first;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>        <span class="hljs-keyword">int</span> cur_cols = i == <span class="hljs-number">0</span> ? max_cols : cols;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cur_cols; j++) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, vvs[i][j].c_str());<br>            <span class="hljs-keyword">if</span> (j &lt; cur_cols - <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1111 Online Map (30分)</title>
    <link href="/2021/01/31/1111-Online-Map-30%E5%88%86/"/>
    <url>/2021/01/31/1111-Online-Map-30%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1111-Online-Map-30分"><a href="#1111-Online-Map-30分" class="headerlink" title="1111 Online Map (30分)"></a>1111 Online Map (30分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/dtuD9S.png" alt="dtuD9S"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>给定一个有向图，找出两条路径，分别是</p><ul><li>以距离为权变的最短路径</li><li>以时间为权边的最短路径</li></ul><p>要求输出</p><blockquote><p>In case the shortest path is not unique, output the fastest one among the shortest paths, which is guaranteed to be unique. In case the fastest path is not unique, output the one that passes through the fewest intersections, which is guaranteed to be unique.</p></blockquote><blockquote><p>距离最短路径不唯一，则输出最短时间中最快的一条。所以需要使用一个变量记录所有的最短路径，找出时间最短的一条。<br>时间最短的路径不唯一，输出通过最少结点的路径。使用一个变量记录所有经历过的结点， 经过点最小的路径。</p></blockquote><hr><p>题目中给出的图如下所示</p><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/FLzRUZ.png" alt="FLzRUZ"></p><p>根据分析，这道题就变成了分别求两个最短路径：<strong>以距离为边的权值最短距离</strong>和<strong>以时间为边的权值的最短距离</strong>。</p><p>因此设置两个二维数组分别存储距离值和时间值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> D[MAX][MAX], T[MAX][MAX];<br></code></pre></td></tr></table></figure><p>在建图的时候需要注意，这是一个有向图，需要判断方向。</p><p>其中题目要求输出唯一的最短路径。因为路径要求是唯一，可以参考</p><ul><li><a href="https://emhui.fun/2021/01/19/1030-Travel-Plan/">1030 Travel Plan</a></li></ul><p>如题目要求输出所有路径，则参考</p><ul><li><a href="https://emhui.fun/2021/01/19/1018-Public-Bike-Management/">1018 Public Bike Management</a></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">987654321</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">500</span>;<br><br><span class="hljs-keyword">int</span> n, m;<br><span class="hljs-keyword">int</span> D[MAX][MAX]; <span class="hljs-comment">// 最短距离图</span><br><span class="hljs-keyword">int</span> T[MAX][MAX]; <span class="hljs-comment">// 最短时间图</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt; visited; <span class="hljs-comment">// 记录是否被访问</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; dis, tim, tempPath, path, node;<br><span class="hljs-comment">// vector&lt;int&gt; preDis[MAX], preTime[MAX]; // pre记录路径</span><br><span class="hljs-keyword">int</span> preDis[MAX], preTime[MAX];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dijkstra_dis</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span> </span>&#123;<br>    fill(dis.begin(), dis.end(), INF); <span class="hljs-comment">// 初始化最短路径</span><br>    fill(tim.begin(), tim.end(), INF); <span class="hljs-comment">// 初始化最短路径上的时间消费</span><br>    fill(visited.begin(), visited.end(), <span class="hljs-number">0</span>); <span class="hljs-comment">// 初始化所有参观过的点</span><br>    dis[s] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 这里把dis设置为经过点的数量</span><br>    tim[s] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// preDis[s].push_back(s); // 自己的前一个</span><br>    <span class="hljs-comment">// 初始化所有的路径</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) preDis[i] = i;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-comment">// 1. 找到最小的距离</span><br>        <span class="hljs-keyword">int</span> u = <span class="hljs-number">-1</span>, min = INF;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (!visited[j] &amp;&amp; min &gt; dis[j]) &#123;<br>                u = j;<br>                min = dis[j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (u == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span>;<br>        visited[u] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 优化以u为结点的点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v = <span class="hljs-number">0</span>; v &lt; n; v++) &#123;<br>            <span class="hljs-keyword">if</span> (!visited[v] &amp;&amp; D[u][v] != INF) &#123;<br>                <span class="hljs-keyword">if</span> (dis[u] + D[u][v] &lt; dis[v]) &#123;<br>                    dis[v] = dis[u] + D[u][v];<br>                    tim[v] = tim[u] + T[u][v]; <span class="hljs-comment">// 最短路径上的时间话费</span><br>                    preDis[v] = u;<br>                    <span class="hljs-comment">// preDis[v].clear();</span><br>                    <span class="hljs-comment">// preDis[v].push_back(u);</span><br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dis[u] + D[u][v] == dis[v]) &#123; <span class="hljs-comment">// 存在多条最短路径</span><br>                    <span class="hljs-keyword">if</span> (tim[u] + T[u][v] &lt; tim[v]) &#123; <span class="hljs-comment">// 消耗时间最短</span><br>                        tim[v] = tim[u] + T[u][v];<br>                        preDis[v] = u;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dijkstra_tim</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span> </span>&#123;<br>    fill(node.begin(), node.end(), INF); <span class="hljs-comment">// 初始化最短路径</span><br>    fill(tim.begin(), tim.end(), INF); <span class="hljs-comment">// 初始化最短路径上的时间消费</span><br>    fill(visited.begin(), visited.end(), <span class="hljs-number">0</span>); <span class="hljs-comment">// 初始化所有参观过的点</span><br>    node[s] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 起点为0</span><br>    tim[s] = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// preDis[s].push_back(s); // 自己的前一个</span><br>    <span class="hljs-comment">// 初始化所有的路径</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) preTime[i] = i;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-comment">// 1. 找到最小的距离</span><br>        <span class="hljs-keyword">int</span> u = <span class="hljs-number">-1</span>, min = INF;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (!visited[j] &amp;&amp; min &gt; tim[j]) &#123;<br>                u = j;<br>                min = tim[j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (u == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span>;<br>        visited[u] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 优化以u为结点的点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v = <span class="hljs-number">0</span>; v &lt; n; v++) &#123;<br>            <span class="hljs-keyword">if</span> (!visited[v] &amp;&amp; T[u][v] != INF) &#123;<br>                <span class="hljs-keyword">if</span> (tim[u] + T[u][v] &lt; tim[v]) &#123;<br>                    tim[v] = tim[u] + T[u][v];<br>                    node[v] = node[u] + <span class="hljs-number">1</span>; <span class="hljs-comment">// 在u的基础上在走了一个点。</span><br>                    preTime[v] = u;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tim[u] + T[u][v] == tim[v]) &#123; <span class="hljs-comment">// 存在多条最短路径</span><br>                    <span class="hljs-keyword">if</span> (node[u] + <span class="hljs-number">1</span> &lt; node[v]) &#123;<br>                        node[v] = node[u] + <span class="hljs-number">1</span>;<br>                        preTime[v] = u;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> v1,v2, one_way, length, time;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br>    dis.resize(n);<br>    tim.resize(n);<br>    node.resize(n);<br>    visited.resize(n);<br>    fill(D[<span class="hljs-number">0</span>], D[<span class="hljs-number">0</span>] + MAX * MAX, INF);<br>    fill(T[<span class="hljs-number">0</span>], T[<span class="hljs-number">0</span>] + MAX * MAX, INF);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; one_way &gt;&gt; length &gt;&gt; time;<br>        D[v1][v2] = length;<br>        T[v1][v2] = time;<br>        <span class="hljs-keyword">if</span> (one_way == <span class="hljs-number">0</span>) &#123;<br>            D[v2][v1] = length;<br>            T[v2][v1] = time;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">int</span> start, destination;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; start &gt;&gt; destination;<br>    dijkstra_dis(start);<br>    dijkstra_tim(start);<br><br><br>    <span class="hljs-comment">// dfs(destination, start);</span><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; path_dis, path_time; <span class="hljs-comment">// 记录最佳路径</span><br>    <span class="hljs-keyword">int</span> i = start, j = destination;<br>    <span class="hljs-keyword">while</span> (j != i) &#123;<br>        path_dis.push_back(j);<br>        j = preDis[j];<br>    &#125;<br>    path_dis.push_back(start); <span class="hljs-comment">// 加入起点</span><br><br>    i = start, j = destination;<br>    <span class="hljs-keyword">while</span> (j != i) &#123;<br>        path_time.push_back(j);<br>        j = preTime[j];<br>    &#125;<br>    path_time.push_back(start);<br><br>    <span class="hljs-keyword">if</span> (path_dis == path_time) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Distance = %d; Time = %d: &quot;</span>, dis[destination], tim[destination]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = path_dis.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, path_dis[i]);<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; -&gt; &quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Distance = %d: &quot;</span>, dis[destination]);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = path_dis.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> ; i--) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, path_dis[i]);<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; -&gt; &quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Time = %d: &quot;</span>, tim[destination]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = path_time.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> ; i--) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, path_time[i]);<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; -&gt; &quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法二：使用priority-queue实现Dijkstra"><a href="#方法二：使用priority-queue实现Dijkstra" class="headerlink" title="方法二：使用priority_queue实现Dijkstra"></a>方法二：使用<code>priority_queue</code>实现Dijkstra</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">987654321</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">500</span>;<br><br><span class="hljs-keyword">int</span> n, m;<br><span class="hljs-keyword">int</span> D[MAX][MAX]; <span class="hljs-comment">// 最短距离图</span><br><span class="hljs-keyword">int</span> T[MAX][MAX]; <span class="hljs-comment">// 最短时间图</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt; visited; <span class="hljs-comment">// 记录是否被访问</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; dis, tim, tempPath, path, node;<br><span class="hljs-keyword">int</span> preDis[MAX], preTime[MAX];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dijkstra_dis</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span> </span>&#123;<br>    fill(dis.begin(), dis.end(), INF); <span class="hljs-comment">// 初始化最短路径</span><br>    fill(tim.begin(), tim.end(), INF); <span class="hljs-comment">// 初始化最短路径上的时间消费</span><br>    fill(visited.begin(), visited.end(), <span class="hljs-number">0</span>); <span class="hljs-comment">// 初始化所有参观过的点</span><br>    <span class="hljs-comment">// 注意这里需要使用最小堆</span><br>    <span class="hljs-built_in">priority_queue</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt;, greater&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt;&gt; pq;<br>    pq.push(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">0</span>, s));<br>    dis[s] = <span class="hljs-number">0</span>;<br>    tim[s] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) preDis[i] = i;<br>    <span class="hljs-keyword">while</span> (!pq.empty()) &#123;<br>        <span class="hljs-keyword">int</span> u_dis = pq.top().first;<br>        <span class="hljs-keyword">int</span> u = pq.top().second;<br>        pq.pop();<br>        <span class="hljs-keyword">if</span> (visited[u]) <span class="hljs-keyword">continue</span>;<br>        visited[u] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v = <span class="hljs-number">0</span>; v &lt; n; v++) &#123;<br>            <span class="hljs-keyword">if</span> (!visited[v] &amp;&amp; D[u][v] != INF) &#123;<br>                <span class="hljs-keyword">if</span> (dis[u] + D[u][v] &lt; dis[v]) &#123;<br>                    dis[v] = dis[u] + D[u][v];<br>                    tim[v] = tim[u] + T[u][v]; <span class="hljs-comment">// 时间</span><br>                    preDis[v] = u;<br>                    pq.push(<span class="hljs-built_in">make_pair</span>(dis[v], v));<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dis[u] + D[u][v] == dis[v]) &#123;<br>                    <span class="hljs-keyword">if</span> (tim[u] + T[u][v] &lt; tim[v]) &#123;<br>                        tim[v] = tim[u] + T[u][v];<br>                        preDis[v] = u;<br>                        pq.push(<span class="hljs-built_in">make_pair</span>(dis[v], v));<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dijkstra_tim</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span> </span>&#123;<br>    fill(node.begin(), node.end(), INF); <span class="hljs-comment">//初始化经历过的结点数量</span><br>    fill(tim.begin(), tim.end(), INF); <span class="hljs-comment">// 初始化最短路径上的时间消费</span><br>    fill(visited.begin(), visited.end(), <span class="hljs-number">0</span>); <span class="hljs-comment">// 初始化所有参观过的点</span><br>    <span class="hljs-built_in">priority_queue</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt;, greater&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt;&gt; pq;<br>    pq.push(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">0</span>, s));<br>    node[s] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 起点为0</span><br>    tim[s] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) preTime[i] = i;<br>    <span class="hljs-keyword">while</span> (!pq.empty()) &#123;<br>        <span class="hljs-keyword">int</span> u = pq.top().second;<br>        pq.pop();<br>        <span class="hljs-keyword">if</span> (visited[u]) <span class="hljs-keyword">continue</span>;<br>        visited[u] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v = <span class="hljs-number">0</span>; v &lt; n; v++) &#123;<br>            <span class="hljs-keyword">if</span> (!visited[v] &amp;&amp; T[u][v] != INF) &#123;<br>                <span class="hljs-keyword">if</span> (tim[u] + T[u][v] &lt; tim[v]) &#123;<br>                    tim[v] = tim[u] + T[u][v];<br>                    node[v] = node[u] + <span class="hljs-number">1</span>;<br>                    preTime[v] = u;<br>                    pq.push(<span class="hljs-built_in">make_pair</span>(tim[v], v));<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tim[u] + T[u][v] == tim[v]) &#123;<br>                    <span class="hljs-keyword">if</span> (node[u] + <span class="hljs-number">1</span> &lt; node[v]) &#123;<br>                        node[v] = node[u] + <span class="hljs-number">1</span>;<br>                        preTime[v] = u;<br>                        pq.push(<span class="hljs-built_in">make_pair</span>(tim[v], v));<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> v1,v2, one_way, length, time;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br>    dis.resize(n);<br>    tim.resize(n);<br>    node.resize(n);<br>    visited.resize(n);<br>    fill(D[<span class="hljs-number">0</span>], D[<span class="hljs-number">0</span>] + MAX * MAX, INF);<br>    fill(T[<span class="hljs-number">0</span>], T[<span class="hljs-number">0</span>] + MAX * MAX, INF);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; one_way &gt;&gt; length &gt;&gt; time;<br>        D[v1][v2] = length;<br>        T[v1][v2] = time;<br>        <span class="hljs-keyword">if</span> (one_way == <span class="hljs-number">0</span>) &#123;<br>            D[v2][v1] = length;<br>            T[v2][v1] = time;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">int</span> start, destination;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; start &gt;&gt; destination;<br>    dijkstra_dis(start);<br>    dijkstra_tim(start);<br><br><br>    <span class="hljs-comment">// dfs(destination, start);</span><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; path_dis, path_time; <span class="hljs-comment">// 记录最佳路径</span><br>    <span class="hljs-keyword">int</span> i = start, j = destination;<br>    <span class="hljs-keyword">while</span> (j != i) &#123;<br>        path_dis.push_back(j);<br>        j = preDis[j];<br>    &#125;<br>    path_dis.push_back(start); <span class="hljs-comment">// 加入起点</span><br><br>    i = start, j = destination;<br>    <span class="hljs-keyword">while</span> (j != i) &#123;<br>        path_time.push_back(j);<br>        j = preTime[j];<br>    &#125;<br>    path_time.push_back(start);<br><br>    <span class="hljs-keyword">if</span> (path_dis == path_time) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Distance = %d; Time = %d: &quot;</span>, dis[destination], tim[destination]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = path_dis.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, path_dis[i]);<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; -&gt; &quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Distance = %d: &quot;</span>, dis[destination]);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = path_dis.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> ; i--) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, path_dis[i]);<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; -&gt; &quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Time = %d: &quot;</span>, tim[destination]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = path_time.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> ; i--) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, path_time[i]);<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; -&gt; &quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>最短路径</tag>
      
      <tag>priority_queue</tag>
      
      <tag>优先队列</tag>
      
      <tag>dijkstra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最短路径 Dijkstra模板</title>
    <link href="/2021/01/31/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-Dijkstra%E6%A8%A1%E6%9D%BF/"/>
    <url>/2021/01/31/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-Dijkstra%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="最短路径-Dijkstra模板"><a href="#最短路径-Dijkstra模板" class="headerlink" title="最短路径 Dijkstra模板"></a>最短路径 Dijkstra模板</h1><h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// G 图, d 距离, s 起始点</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">(G, d[], s)</span> </span>&#123;<br>初始化;<br><span class="hljs-keyword">for</span> ( 循环n次 ) &#123;<br>u = 使d[u]最小，且没有被访问顶点;<br>记录u被访问;<br><span class="hljs-keyword">for</span> (从u出发能到达的所有顶点v) &#123;<br><span class="hljs-keyword">if</span> (v没有被访问 &amp;&amp; 以u为中介到v的距离比d[v]更优) &#123;<br>优化d[v];<br>&#125;<br><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="邻接矩阵实现"><a href="#邻接矩阵实现" class="headerlink" title="邻接矩阵实现"></a>邻接矩阵实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> INF = <span class="hljs-number">987654321</span>;<br><span class="hljs-keyword">int</span> MAX = <span class="hljs-number">10000</span>;<br><span class="hljs-keyword">int</span> G[MAX][MAX];<br><span class="hljs-keyword">int</span> d[MAX];<br><span class="hljs-keyword">int</span> n; <span class="hljs-comment">// 顶点个数</span><br><span class="hljs-keyword">bool</span> visited[MAX] = &#123;<span class="hljs-literal">false</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span> </span>&#123;<br><span class="hljs-comment">// 1. 初始化操作</span><br>fill(d, d + MAX, INF); <span class="hljs-comment">// 初始化所有路径</span><br>d[s] = <span class="hljs-number">1</span>;<br><span class="hljs-comment">// visited[s] = true;</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123; <span class="hljs-comment">// 依次找n个结点</span><br><span class="hljs-comment">// 2. 找到最小且没有被访问的的d[u]</span><br><span class="hljs-keyword">int</span> u = <span class="hljs-number">-1</span>, min = INF;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br><span class="hljs-comment">// 2.1 找到没有被访问 &amp;&amp; d[u]最小的的值</span><br><span class="hljs-keyword">if</span> (!visited[j] &amp;&amp; min &gt; d[j]) &#123;<br>u = j;<br>min = d[j];<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (u == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 没有找到</span><br>visited[u] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 已经访问到了</span><br><span class="hljs-comment">// 3. 优化以u作为中介到v的点和d[v]进行比较;</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v = <span class="hljs-number">0</span>; v &lt; n; v++) &#123;<br><span class="hljs-keyword">if</span> (!visited[v] &amp;&amp; G[u][v] != INF &amp;&amp; d[u] + G[u][v] &lt; d[v]) &#123;<br>d[v] = d[u] + G[u][v]; <span class="hljs-comment">// 优化d[v];</span><br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="邻接表实现"><a href="#邻接表实现" class="headerlink" title="邻接表实现"></a>邻接表实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> MAX = <span class="hljs-number">10000</span>;<br><span class="hljs-keyword">int</span> INF = <span class="hljs-number">987654321</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>&#123;</span><br><span class="hljs-keyword">int</span> v, dis;<br>&#125;<br><span class="hljs-built_in">vector</span>&lt;Node&gt; G[MAX];<br><span class="hljs-keyword">int</span> d[MAX];<br><span class="hljs-keyword">bool</span> viisted[MAX] = &#123;<span class="hljs-literal">false</span>&#125;;<br><span class="hljs-keyword">int</span> n;<br><br><span class="hljs-comment">// s 起点</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span> </span>&#123;<br><span class="hljs-comment">// 1. 初始化</span><br>fill(d, d + MAX, INF); <span class="hljs-comment">// 初始化所有距离;</span><br>d[s] = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 2. 开始依次找到n个最短距离</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123; <span class="hljs-comment">// 找n个距离最小的点</span><br><span class="hljs-comment">// 2.1 找到没有被访问且距离最短的顶点</span><br><span class="hljs-keyword">int</span> u = <span class="hljs-number">-1</span>, min = INF;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br><span class="hljs-keyword">if</span> (!visited[j] &amp;&amp; min &gt; d[j]) &#123;<br>u = j;<br>min = d[j];<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (u == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span>;<br>visited[u] = <span class="hljs-literal">true</span>;<br><span class="hljs-comment">// 只有这部分不一样</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; G[u].size(); j++) &#123;<br><span class="hljs-keyword">int</span> v = G[u][j].v;<br><span class="hljs-keyword">if</span> (!visited[v] &amp;&amp; d[u] + G[u][v].dis &lt; d[v]) &#123;<br>d[v] = d[u] + G[u][v].dis;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="优化：使用priority-queue实现"><a href="#优化：使用priority-queue实现" class="headerlink" title="优化：使用priority_queue实现"></a>优化：使用<code>priority_queue</code>实现</h2><blockquote><p>注意：这里需要使用最小堆</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> v;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt; adj;<br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dis</span><span class="hljs-params">(v, INF)</span></span>;<br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(v, <span class="hljs-literal">false</span>)</span></span>;<br>dis[s] = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">priority_queue</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt;, greater&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt;&gt; pq;<br>pq.push(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">0</span>, s));<br><span class="hljs-keyword">while</span> (!pq.empty()) &#123;<br><span class="hljs-keyword">int</span> u_dis = pq.top().first;<br><span class="hljs-keyword">int</span> u = pq.top().second;<br><span class="hljs-keyword">if</span> (visited[u]) <span class="hljs-keyword">continue</span>;<br>visited[u] = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; adj[u].size(); i++) &#123;<br><span class="hljs-keyword">int</span> v = adj[u][i].first;<br><span class="hljs-keyword">if</span> (!visited[v] &amp;&amp; dis[u] + adj[u][v] &lt; dis[v]) &#123;<br>dis[v] = dis[u] + adj[u][v].second;<br>pq.push(<span class="hljs-built_in">make_pair</span>(dis[v], v));<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> dis;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里其实可以不用<code>visited</code>变量，此方法参考《算法问题实战策略》</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> v;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt; adj;<br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dis</span><span class="hljs-params">(v, INF)</span></span>;<br>dis[s] = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">priority_queue</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt;, greater&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt;&gt; pq;<br>pq.push(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">0</span>, s));<br><span class="hljs-keyword">while</span> (!pq.empty()) &#123;<br><span class="hljs-keyword">int</span> u_dis = pq.top().first;<br><span class="hljs-keyword">int</span> u = pq.top().second;<br><span class="hljs-keyword">if</span> (d[u] &lt; u_dis) <span class="hljs-keyword">continue</span>;<br>visited[u] = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; adj[u].size(); i++) &#123;<br><span class="hljs-keyword">int</span> v = adj[u][i].first;<br><span class="hljs-keyword">if</span> (!visited[v] &amp;&amp; dis[u] + adj[u][v].second &lt; dis[v]) &#123;<br>dis[v] = dis[u] + adj[u][v].second;<br>pq.push(<span class="hljs-built_in">make_pair</span>(dis[v], v));<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> dis;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
      <tag>Dijkstra</tag>
      
      <tag>最短路径</tag>
      
      <tag>priority_queue</tag>
      
      <tag>优先队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>839. 相似字符串组</title>
    <link href="/2021/01/31/839-%E7%9B%B8%E4%BC%BC%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%84/"/>
    <url>/2021/01/31/839-%E7%9B%B8%E4%BC%BC%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="839-相似字符串组"><a href="#839-相似字符串组" class="headerlink" title="839. 相似字符串组"></a><a href="https://leetcode-cn.com/problems/similar-string-groups/">839. 相似字符串组</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/fmjjEv.png" alt="fmjjEv"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>将每个字符串作为一个点，将相似的字符串连通到一起，本题就变成了求连通分量个数。</p><p>如何判断是否相似，若两个字符串中只存在两个不同的字符，那么就等于相似。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSimilar</span><span class="hljs-params">(<span class="hljs-built_in">string</span>&amp; a, <span class="hljs-built_in">string</span>&amp; b, <span class="hljs-keyword">int</span> len)</span> </span>&#123;<br><span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br><span class="hljs-keyword">if</span> (a[i] != b[i]) &#123;<br>num++;<br><span class="hljs-keyword">if</span> (num &gt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; parent;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> parent[x] ==  x ? x : parent[x] = find(parent[x]);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSimilar</span><span class="hljs-params">(<span class="hljs-built_in">string</span>&amp; a, <span class="hljs-built_in">string</span>&amp; b, <span class="hljs-keyword">int</span> len)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-keyword">if</span> (a[i] != b[i]) &#123;<br>                num++;<br>                <span class="hljs-keyword">if</span> (num &gt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numSimilarGroups</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; strs)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = strs.size();<br>        <span class="hljs-keyword">int</span> m = strs[<span class="hljs-number">0</span>].size();<br>        <span class="hljs-keyword">int</span> setCount = n;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) parent.push_back(i);<br>        <span class="hljs-comment">// 开始连通每个字符串</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">int</span> iRoot = find(i), jRoot = find(j);<br>                <span class="hljs-keyword">if</span> (iRoot == jRoot) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span> (isSimilar(strs[i], strs[j], m)) &#123;<br>                    parent[iRoot] = jRoot;<br>                    setCount--;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> setCount;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://leetcode-cn.com/problems/similar-string-groups/solution/xiang-si-zi-fu-chuan-zu-by-leetcode-solu-8jt9/">相似字符串组</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>union-find</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1114 Family Property (25分)</title>
    <link href="/2021/01/30/1114-Family-Property-25%E5%88%86/"/>
    <url>/2021/01/30/1114-Family-Property-25%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1114-Family-Property-25分"><a href="#1114-Family-Property-25分" class="headerlink" title="1114 Family Property (25分)"></a>1114 Family Property (25分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/6vm9f2.png" alt="6vm9f2"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>步骤：</p><blockquote><p>方法一和方法二差不多，就是最后处理有点不同。 方法二使用下面步骤。</p></blockquote><ol><li>求出总共的人数</li><li>建立并查集，ID越小，权重越大</li><li>找出并查集中连通分量的根结点和每个连通分量中的结点数量。</li><li>建立一个新的数组<code>temp</code>，该数组下标为用户ID。</li><li>对有房地产和房地产面积的用户，找到他们的根结点<code>root</code>，将他们的房地产，面积全部累加到新的数组<code>tmep[root]</code>中去（新的数组下标就是用户ID）。</li><li>把新数组中的根用户添加到<code>vector</code>中，最后在排序即可。</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>方法一</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;utility&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Family</span>&#123;</span><br><span class="hljs-keyword">int</span> id, num; <span class="hljs-comment">// num 家庭总数</span><br><span class="hljs-keyword">double</span> estate, area;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; relative;<br>&#125;;<br><br><span class="hljs-keyword">int</span> numPerson = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; int2uid, uid2int;<br><span class="hljs-built_in">vector</span>&lt;Family&gt; families;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getUid</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (int2uid.find(id) == int2uid.end()) &#123; <span class="hljs-comment">// 如果不存在</span><br>        int2uid[id] = numPerson;<br>        uid2int[numPerson] = id;<br>        <span class="hljs-keyword">return</span> numPerson++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> int2uid[id];<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span>&#123;</span><br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; parent;<br>    <span class="hljs-keyword">int</span> setCount;<br>    <span class="hljs-keyword">public</span>:<br>    UnionFind(<span class="hljs-keyword">int</span> n) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) parent.push_back(i);<br>        setCount = n;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n != parent[n]) parent[n] = find(parent[n]);<br>        <span class="hljs-keyword">return</span> parent[n];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>        u = find(u), v = find(v);<br>        <span class="hljs-keyword">if</span> (u == v) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 挂在到挂在id比较小的上面</span><br>        <span class="hljs-keyword">if</span> (uid2int[u] &lt; uid2int[v]) &#123;swap(u, v);&#125;<br>        parent[u] = v;<br>        setCount--;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isConnected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v)</span> </span>&#123;<span class="hljs-keyword">return</span> find(u) == find(v);&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> setCount;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, Family&gt;&amp; a, <span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, Family&gt;&amp; b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (a.second.area != b.second.area) <span class="hljs-keyword">return</span> a.second.area &gt; b.second.area;<br>    <span class="hljs-keyword">return</span> a.first &lt; b.first;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, id, fa, mo, k, child, estate, area;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        Family family;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; id &gt;&gt; fa &gt;&gt; mo &gt;&gt; k;<br>        family.id = getUid(id);<br>        <span class="hljs-keyword">if</span> (fa != <span class="hljs-number">-1</span>) family.relative.push_back(getUid(fa));<br>        <span class="hljs-keyword">if</span> (mo != <span class="hljs-number">-1</span>) family.relative.push_back(getUid(mo));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; k; j++) &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; child;<br>            family.relative.push_back(getUid(child));<br>        &#125;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; estate &gt;&gt; area;<br>        family.estate = estate;<br>        family.area = area;<br>        families.push_back(family);<br>    &#125;<br><br>    <span class="hljs-function">UnionFind <span class="hljs-title">uf</span><span class="hljs-params">(numPerson)</span></span>; <span class="hljs-comment">// 建立并查集</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">int</span> id = families[i].id;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; families[i].relative.size(); j++) &#123;<br>            <span class="hljs-keyword">int</span> relative = families[i].relative[j];<br>            <span class="hljs-keyword">if</span> (!uf.isConnected(id, relative)) &#123;<br>                uf.unite(id, relative);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, uf.getCount());<br>    <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>,Family&gt; ans;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numPerson; i++) &#123;<br>        ans[uid2int[uf.find(i)]].num++; <span class="hljs-comment">// 统计人数</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">int</span> key = uid2int[uf.find(families[i].id)];<br>        <span class="hljs-comment">// ans[key].num++;</span><br>        ans[key].estate += families[i].estate;<br>        ans[key].area += families[i].area;<br>    &#125;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, Family&gt;&gt; ans2;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, Family&gt;:: iterator it = ans.begin(); it != ans.end(); it++) &#123;<br>        it-&gt;second.estate = it-&gt;second.estate * <span class="hljs-number">1.0</span> / it-&gt;second.num;<br>        it-&gt;second.area = it-&gt;second.area * <span class="hljs-number">1.0</span> / it-&gt;second.num;<br>        ans2.push_back(<span class="hljs-built_in">make_pair</span>(it-&gt;first, it-&gt;second));<br>    &#125;<br>    sort(ans2.begin(), ans2.end(), cmp);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ans2.size(); i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%04d %d %.3lf %.3lf\n&quot;</span>, ans2[i].first, ans2[i].second.num,<br>               ans2[i].second.estate, ans2[i].second.area);<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>方法二</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Family</span>&#123;</span><br><span class="hljs-keyword">int</span> id, num; <span class="hljs-comment">// num 家庭总数</span><br><span class="hljs-keyword">double</span> estate, area ;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; relative;<br>    Family(): num(<span class="hljs-number">0</span>), estate(<span class="hljs-number">0.0</span>), area(<span class="hljs-number">0.0</span>) &#123;&#125; <span class="hljs-comment">// 初始化为0</span><br>&#125;;<br><br><span class="hljs-keyword">int</span> numPerson = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; int2uid, uid2int;<br><span class="hljs-built_in">vector</span>&lt;Family&gt; families;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getUid</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (int2uid.find(id) == int2uid.end()) &#123; <span class="hljs-comment">// 如果不存在</span><br>        int2uid[id] = numPerson;<br>        uid2int[numPerson] = id;<br>        <span class="hljs-keyword">return</span> numPerson++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> int2uid[id];<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span>&#123;</span><br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; parent;<br>    <span class="hljs-keyword">int</span> setCount;<br>    <span class="hljs-keyword">public</span>:<br>    UnionFind(<span class="hljs-keyword">int</span> n) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) parent.push_back(i);<br>        setCount = n;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n != parent[n]) parent[n] = find(parent[n]);<br>        <span class="hljs-keyword">return</span> parent[n];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>        u = find(u), v = find(v);<br>        <span class="hljs-keyword">if</span> (u == v) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 挂在到挂在id比较小的上面</span><br>        <span class="hljs-keyword">if</span> (uid2int[u] &lt; uid2int[v]) &#123;swap(u, v);&#125;<br>        parent[u] = v;<br>        setCount--;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isConnected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v)</span> </span>&#123;<span class="hljs-keyword">return</span> find(u) == find(v);&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> setCount;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Family&amp; a, Family&amp; b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (a.area != b.area) <span class="hljs-keyword">return</span> a.area &gt; b.area;<br>    <span class="hljs-keyword">return</span> a.id &lt; b.id;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, id, fa, mo, k, child, estate, area;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        Family family;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; id &gt;&gt; fa &gt;&gt; mo &gt;&gt; k;<br>        family.id = getUid(id);<br>        <span class="hljs-keyword">if</span> (fa != <span class="hljs-number">-1</span>) family.relative.push_back(getUid(fa));<br>        <span class="hljs-keyword">if</span> (mo != <span class="hljs-number">-1</span>) family.relative.push_back(getUid(mo));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; k; j++) &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; child;<br>            family.relative.push_back(getUid(child));<br>        &#125;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; estate &gt;&gt; area;<br>        family.estate = estate;<br>        family.area = area;<br>        families.push_back(family);<br>    &#125;<br><br>    <span class="hljs-function">UnionFind <span class="hljs-title">uf</span><span class="hljs-params">(numPerson)</span></span>; <span class="hljs-comment">// 建立并查集</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">int</span> id = families[i].id;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; families[i].relative.size(); j++) &#123;<br>            <span class="hljs-keyword">int</span> relative = families[i].relative[j];<br>            <span class="hljs-keyword">if</span> (!uf.isConnected(id, relative)) &#123;<br>                uf.unite(id, relative);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, uf.getCount());<br>    <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; mp;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numPerson; i++) &#123;<br>        mp[uf.find(i)]++; <span class="hljs-comment">// 统计人数</span><br>    &#125;<br><br>    <span class="hljs-comment">// 注意：families的下标没有表达任何意思。所以我们需要建立一个新的temp数组</span><br>    <span class="hljs-comment">// 来存储新的家庭，该家庭主要就是id最小的那个孩子。</span><br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;Family&gt; <span class="hljs-title">temp</span><span class="hljs-params">(numPerson)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">int</span> id = families[i].id;<br>        <span class="hljs-keyword">int</span> key = uf.find(id);<br>        temp[key].estate += families[i].estate;<br>        temp[key].area += families[i].area;<br>    &#125;<br>    <span class="hljs-built_in">vector</span>&lt;Family&gt; ans;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;:: iterator it = mp.begin(); it != mp.end(); it++) &#123;<br>        temp[it-&gt;first].num = it-&gt;second; <span class="hljs-comment">// 家庭人数</span><br>        temp[it-&gt;first].id = uid2int[it-&gt;first]; <span class="hljs-comment">// 转成原本的id</span><br>        temp[it-&gt;first].estate = temp[it-&gt;first].estate * <span class="hljs-number">1.0</span> / it-&gt;second;<br>        temp[it-&gt;first].area = temp[it-&gt;first].area * <span class="hljs-number">1.0</span> / it-&gt;second;<br>        ans.push_back(temp[it-&gt;first]);<br>    &#125;<br><br>    sort(ans.begin(), ans.end(), cmp);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ans.size(); i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%04d %d %.3lf %.3lf\n&quot;</span>, ans[i].id, ans[i].num,<br>               ans[i].estate, ans[i].area);<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>union-find</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1112 Stucked Keyboard (20分)</title>
    <link href="/2021/01/30/1112-Stucked-Keyboard-20%E5%88%86/"/>
    <url>/2021/01/30/1112-Stucked-Keyboard-20%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1112-Stucked-Keyboard-20分"><a href="#1112-Stucked-Keyboard-20分" class="headerlink" title="1112 Stucked Keyboard (20分)"></a>1112 Stucked Keyboard (20分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/yFLPf6.png" alt="yFLPf6"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>找到连续出现k次的字符，把它合并成一个字符</p><ul><li>使用一个128位的数组记录已经stuck的的字符</li><li>如何判断是否是一个stuck字符</li></ul><blockquote><p>其实还有一种情况，就是前面是正常的后面不正常。那么可以把不正常的给找出来吗？</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><blockquote><p>有一个用例没有通过</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-keyword">char</span> keys[<span class="hljs-number">1000</span>], ans[<span class="hljs-number">1000</span>], stuck[<span class="hljs-number">1000</span>];<br>    <span class="hljs-keyword">bool</span> visited[<span class="hljs-number">128</span>] = &#123;<span class="hljs-literal">false</span>&#125;, normal[<span class="hljs-number">128</span>] = &#123;<span class="hljs-literal">false</span>&#125;;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; keys;<br>    <span class="hljs-keyword">int</span> size = <span class="hljs-built_in">strlen</span>(keys);<br>    <span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>, ansIdx = <span class="hljs-number">0</span>, stuckIdx = <span class="hljs-number">0</span>; <span class="hljs-comment">// idx 当前查询的下标 ansIdx 正常字符下标 stuckIdx 坏的字符</span><br>    <span class="hljs-keyword">while</span> (idx &lt; size) &#123;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">char</span> pre = keys[idx];<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; n &amp;&amp; idx + i &lt; size; i++) &#123; <span class="hljs-comment">// 判断是否是连续n个，连续n个是坏的字符</span><br>            <span class="hljs-keyword">if</span> (pre != keys[idx + i]) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i &lt; n || normal[pre]) &#123; <span class="hljs-comment">// 正常键盘，进行字符拼接 ans += keys[idx, i];</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i &amp;&amp; idx + j &lt; size; j++) &#123;<br>                normal[keys[idx]] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 标记那些正常按键</span><br>                ans[ansIdx++] = keys[idx++];<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 非正常键盘，只需要存储当前的即可。</span><br>            ans[ansIdx++] = pre;<br>            idx += n;<br>            <span class="hljs-keyword">if</span> (!visited[pre]) &#123; <span class="hljs-comment">// 没有被记录是坏键,还需要判断是否</span><br>                stuck[stuckIdx++] = pre;<br>                visited[pre] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; stuckIdx; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, stuck[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ansIdx; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, ans[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1115 Counting Nodes in a BST (30分)</title>
    <link href="/2021/01/30/1115-Counting-Nodes-in-a-BST-30%E5%88%86/"/>
    <url>/2021/01/30/1115-Counting-Nodes-in-a-BST-30%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1115-Counting-Nodes-in-a-BST-30分"><a href="#1115-Counting-Nodes-in-a-BST-30分" class="headerlink" title="1115 Counting Nodes in a BST (30分)"></a>1115 Counting Nodes in a BST (30分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/gY0tAH.png" alt="gY0tAH"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题考察</p><ul><li><strong>二叉搜索树的建立</strong></li><li><strong>二叉树的层次遍历</strong></li></ul><p><strong>二叉搜索树的建立</strong></p><p>下面是二叉搜索树的建立模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">TreeNode* <span class="hljs-title">insert</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) &#123;<br>        root = <span class="hljs-keyword">new</span> TreeNode;<br>        root-&gt;val = val;<br>        root-&gt;left = root-&gt;right = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (root-&gt;val &gt;= val) &#123; <span class="hljs-comment">// 移动到左边</span><br>        root-&gt;left = insert(root-&gt;left, val);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        root-&gt;right = insert(root-&gt;right, val);<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><p>在二叉树插入的时候，计算出最大深度。</p><p><strong>使用bfs实现层次遍历</strong></p><p>bfs实现层次遍历的模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-built_in">queue</span>&lt;TreeNode*&gt; q;<br>    TreeNode* node;<br>    q.push(root);<br>    <span class="hljs-keyword">while</span> (!q.empty()) &#123;<br>        <span class="hljs-keyword">int</span> size = q.size();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            node = q.front();<br>            q.pop();<br>            <span class="hljs-keyword">if</span> (node-&gt;left) q.push(node-&gt;left);<br>            <span class="hljs-keyword">if</span> (node-&gt;right) q.push(node-&gt;right);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在使用<code>BFS</code>层次遍历二叉树，找到倒数两层结点的数量。</p><p>注意：<code>n1,n2</code>需要初始化为<code>0</code>。因为当只有一个结点的时候，<code>n2</code>为<code>0</code>。如果不设置值的话，系统会随机给一个值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>&#123;</span><br>    <span class="hljs-keyword">int</span> val;<br>    TreeNode *left, *right;<br>&#125;;<br><br><span class="hljs-keyword">int</span> maxDepth = <span class="hljs-number">0</span>;<br><span class="hljs-function">TreeNode* <span class="hljs-title">insert</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> val, <span class="hljs-keyword">int</span> depth)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) &#123;<br>        maxDepth = max(maxDepth,depth);<br>        root = <span class="hljs-keyword">new</span> TreeNode;<br>        root-&gt;val = val;<br>        root-&gt;left = root-&gt;right = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (root-&gt;val &gt;= val) &#123; <span class="hljs-comment">// 移动到左边</span><br>        root-&gt;left = insert(root-&gt;left, val, depth + <span class="hljs-number">1</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        root-&gt;right = insert(root-&gt;right, val, depth + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-built_in">queue</span>&lt;TreeNode*&gt; q;<br>    TreeNode* node;<br>    q.push(root);<br>    <span class="hljs-keyword">int</span> depth = <span class="hljs-number">0</span>, n1 = <span class="hljs-number">0</span>, n2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (!q.empty()) &#123;<br>        <span class="hljs-keyword">int</span> size = q.size();<br>        ++depth;<br>        <span class="hljs-keyword">if</span> (depth == maxDepth) n1 = size;<br>        <span class="hljs-keyword">if</span> (depth == maxDepth - <span class="hljs-number">1</span>) n2 = size;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            node = q.front();<br>            q.pop();<br>            <span class="hljs-keyword">if</span> (node-&gt;left) q.push(node-&gt;left);<br>            <span class="hljs-keyword">if</span> (node-&gt;right) q.push(node-&gt;right);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d + %d = %d\n&quot;</span>, n1, n2, n1 + n2);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, val;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    TreeNode* root = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; val;<br>        root = insert(root, val, <span class="hljs-number">1</span>);<br>    &#125;<br>    bfs(root);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>bfs</tag>
      
      <tag>bst</tag>
      
      <tag>二叉搜索树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1118 Birds in Forest (25分)</title>
    <link href="/2021/01/30/1118-Birds-in-Forest-25%E5%88%86/"/>
    <url>/2021/01/30/1118-Birds-in-Forest-25%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1118-Birds-in-Forest-25分"><a href="#1118-Birds-in-Forest-25分" class="headerlink" title="1118 Birds in Forest (25分)"></a>1118 Birds in Forest (25分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/xt9y1C.png" alt="xt9y1C"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>题目要求<strong>存在多少连通图，以及存在多少个结点，判断两个点是否连通</strong></p><p><strong>存在多少个结点</strong></p><p>题目中说鸟的编号是连续的，因此输入鸟的id中，最大值的就是该图存在的结点总数。</p><p>知道存在多少结点后，只需要使用并查集建立连通图求出连通分量，判断两点是否连通即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">10000</span>;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; pics[MAX];<br><span class="hljs-keyword">int</span> numBird = <span class="hljs-number">0</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span>&#123;</span><br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; parent;<br>    <span class="hljs-keyword">int</span> setCount;<br>    <span class="hljs-keyword">public</span>:<br>    UnionFind(<span class="hljs-keyword">int</span> n) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) parent.push_back(i);<br>        setCount = n;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n != parent[n]) parent[n] = find(parent[n]);<br>        <span class="hljs-keyword">return</span> parent[n];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> uRoot = find(u), vRoot = find(v);<br>        <span class="hljs-keyword">if</span> (uRoot == vRoot) <span class="hljs-keyword">return</span>;<br>        parent[uRoot] = vRoot;<br>        setCount--;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isConnected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v)</span> </span>&#123;<span class="hljs-keyword">return</span> find(u) == find(v);&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> setCount;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, q, id, num;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; num;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; num; j++) &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; id;<br>            numBird = max(numBird, id); <span class="hljs-comment">// 获取最大的结点数量</span><br>            pics[i].push_back(id);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function">UnionFind <span class="hljs-title">uf</span><span class="hljs-params">(numBird + <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">int</span> pre = pics[i][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; pics[i].size(); j++) &#123;<br>            <span class="hljs-keyword">int</span> now = pics[i][j];<br>            <span class="hljs-keyword">if</span> (!uf.isConnected(pre, now)) &#123;<br>                uf.unite(pre, now);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, uf.getCount() - <span class="hljs-number">1</span>, numBird);<br>    <span class="hljs-built_in">cin</span> &gt;&gt; q;<br>    <span class="hljs-keyword">int</span> u, v;<br>    <span class="hljs-keyword">while</span> (q--) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; u &gt;&gt; v;<br>        <span class="hljs-keyword">if</span> (uf.isConnected(u, v)) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Yes\n&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>union-find</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1119 Pre- and Post-order Traversals (30分)</title>
    <link href="/2021/01/30/1119-Pre-and-Post-order-Traversals-30%E5%88%86/"/>
    <url>/2021/01/30/1119-Pre-and-Post-order-Traversals-30%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1119-Pre-and-Post-order-Traversals-30分"><a href="#1119-Pre-and-Post-order-Traversals-30分" class="headerlink" title="1119 Pre- and Post-order Traversals (30分)"></a>1119 Pre- and Post-order Traversals (30分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/CbYu5o.png" alt="CbYu5o"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>通过<strong>前序和后续求中序</strong>,结果可能唯一可能不唯一。</p><div class="note note-success">            <p><strong>以后序的根结点的前面一个结点作为参考，寻找这个结点在前序的位置，就可以根据这个位置来划分左右孩子</strong></p>          </div><p>什么时候判断结果不唯一呢？</p><p>根据后续的根结点的前一个结点找到该结点在先序中的位置，若该结点的位置正好是先序中根结点的下一个结点，证明该结果不唯一。代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> pos = preL + <span class="hljs-number">1</span>; <span class="hljs-comment">// 找到左子树的根结点</span><br><span class="hljs-keyword">while</span> (preorder[pos] != postorder[postR - <span class="hljs-number">1</span>]) pos++; <span class="hljs-comment">// 在先序遍历中找到左子树的根结点，因为后续遍历倒数第二个就是左子树的根结点，因此可以若找到等于preorder[pos] == postorder[postR - 1] 即为根结点</span><br><span class="hljs-keyword">if</span> (pos == preL + <span class="hljs-number">1</span>) isUnique = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 若根结点就是整数第二个，那么无法判断唯一</span><br></code></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; preorder, inorder, postorder;<br><span class="hljs-keyword">bool</span> isUnique = <span class="hljs-literal">true</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">create</span><span class="hljs-params">(<span class="hljs-keyword">int</span> preL, <span class="hljs-keyword">int</span> preR, <span class="hljs-keyword">int</span> postL, <span class="hljs-keyword">int</span> postR)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (preL &gt; preR) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (preL == preR) &#123;<br>        inorder.push_back(preorder[preL]);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> pos = preL + <span class="hljs-number">1</span>; <span class="hljs-comment">// 找到左子树的根结点</span><br>    <span class="hljs-keyword">while</span> (preorder[pos] != postorder[postR - <span class="hljs-number">1</span>]) pos++; <span class="hljs-comment">// 在先序遍历中找到左子树的根结点，因为后续遍历倒数第二个就是左子树的根结点，因此可以若找到等于preorder[pos] == postorder[postR - 1] 即为根结点</span><br>    <span class="hljs-keyword">if</span> (pos == preL + <span class="hljs-number">1</span>) isUnique = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 若根结点就是整数第二个，那么无法判断唯一</span><br>    <span class="hljs-keyword">int</span> num = pos - preL - <span class="hljs-number">1</span>; <span class="hljs-comment">// 左子树的范围 -1 是去掉 perL 根结点</span><br>    create(preL + <span class="hljs-number">1</span>, pos - <span class="hljs-number">1</span>, postL, postL + num - <span class="hljs-number">1</span>); <span class="hljs-comment">// 遍历左边</span><br>    inorder.push_back(preorder[preL]); <span class="hljs-comment">// 中序遍历</span><br>    create(pos, preR, postL + num, postR - <span class="hljs-number">1</span>); <span class="hljs-comment">// 遍历右边</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, val;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    preorder.resize(n);<br>    postorder.resize(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; preorder[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; postorder[i];<br>    &#125;<br>    create(<span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, <span class="hljs-number">0</span> , n - <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, isUnique ? <span class="hljs-string">&quot;Yes&quot;</span> : <span class="hljs-string">&quot;No&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, inorder[i]);<br>        <span class="hljs-keyword">if</span> (i &lt; n - <span class="hljs-number">1</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.itread01.com/content/1557487205.html">【編程訓練-PAT】A1119 Pre- and Post-order Traversals （30 分）</a></li><li><a href="https://charjindev.github.io/2020/02/28/pat-A1119/">PAT A1119 Pre- and Post-order Traversals (30分) (前后序遍历序列建树)</a></li><li><a href="https://emhui.fun/2021/01/14/1020-Tree-Traversals/">1020 Tree Traversals01-14</a></li><li><a href="https://emhui.fun/2021/01/14/1086-Tree-Traversals-Again/">1086 Tree Traversals Again01-14</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>后序遍历</tag>
      
      <tag>二叉树</tag>
      
      <tag>前序遍历</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1116 Come on! Let&#39;s C (20分)</title>
    <link href="/2021/01/30/1116-Come-on-Let-s-C-20%E5%88%86/"/>
    <url>/2021/01/30/1116-Come-on-Let-s-C-20%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1116-Come-on-Let’s-C-20分"><a href="#1116-Come-on-Let’s-C-20分" class="headerlink" title="1116 Come on! Let’s C (20分)"></a>1116 Come on! Let’s C (20分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/BXzC5Q.png" alt="BXzC5Q"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>初始化一个大的数组，其中数组下标表示该用户id，数组值表示他的排名，排名从1开始，其中没有排名的用户值为-1.</p><p>在使用一个数组记录是否已经得过奖品，得过奖品就不给了。</p><p>其他的就是对素数，是否是冠军进行判断。</p><p>注意：这里排名是从1开始的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">10001</span>;<br><span class="hljs-keyword">int</span> ranklist[MAX] = &#123;<span class="hljs-number">-1</span>&#125;; <span class="hljs-comment">// 这种初始化方式无效 ~~所有人初始排名为-1;~~</span><br><span class="hljs-keyword">bool</span> visited[MAX] = &#123;<span class="hljs-literal">false</span>&#125;; <span class="hljs-comment">// 是否参与了排名</span><br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPrime</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i * i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    fill(ranklist, ranklist + MAX, <span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">int</span> n, k, id;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; id;<br>        ranklist[id] = i;<br>    &#125;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; k;<br>    <span class="hljs-keyword">while</span> (k--) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; id;<br>        <span class="hljs-keyword">if</span> (ranklist[id] == <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%04d: Are you kidding?\n&quot;</span>, id);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!visited[id]) &#123;<br>            <span class="hljs-keyword">if</span> (ranklist[id] == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%04d: Mystery Award\n&quot;</span>, id);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isPrime(ranklist[id])) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%04d: Minion\n&quot;</span>, id);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%04d: Chocolate\n&quot;</span>, id);<br>            &#125;<br>            visited[id] = <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%04d: Checked\n&quot;</span>, id);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>数组初始化操作，只能初始化为0，1.其他值不行</li></ul><p>下面这种方式是错误的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> ranklist[MAX] = &#123;<span class="hljs-number">-1</span>&#125;; <span class="hljs-comment">// 这种初始化方式无效 ~~所有人初始排名为-1;~~</span><br><br></code></pre></td></tr></table></figure><p>正确的应该是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">fill(ranklist, ranklist+MAX, <span class="hljs-number">-1</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>数学</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1113 Integer Set Partition (25分)</title>
    <link href="/2021/01/30/1113-Integer-Set-Partition-25%E5%88%86/"/>
    <url>/2021/01/30/1113-Integer-Set-Partition-25%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1113-Integer-Set-Partition-25分"><a href="#1113-Integer-Set-Partition-25分" class="headerlink" title="1113 Integer Set Partition (25分)"></a>1113 Integer Set Partition (25分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/h3KONX.png" alt="h3KONX"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>题目很简单，求出总和 sum(n)，再将数组排序，然后计算出前 n/2 个和。</p><p>答案就是 n % 2, sum(n) - 2 * sum(n/2)</p><p><del>把一组数字分成两组，其中两组的数量分别是 $n1, n2$。两组的和分别是$sum1, sum2$。需要满足 $min(n1,n2), max(sum1, sum2)$</del></p><p><del>进行排序，使用前缀和处理。需要保持$|n1-n2|$尽量小，那么就是两种情况</del></p><p><del>n为总数</del></p><p><del>- n为偶数，那么就是排序后，后面的直接减掉前面的</del><br><del>- n为奇数</del><br>    <del>- 左边数量 n / 2 + 1, 右边数量 n / 2</del><br>    <del>- 左边数量 n / 2, 右边数量 n / 2 + 1</del></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;numeric&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">arr</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; arr[i];<br>    &#125;<br>    sort(arr.begin(), arr.end());<br>    <span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 如果n是奇数，则有两种情况</span><br>        <span class="hljs-keyword">int</span> ans = max(<br>            <span class="hljs-built_in">abs</span>(accumulate(arr.begin() + n / <span class="hljs-number">2</span>, arr.end(), <span class="hljs-number">0</span>)<br>            - accumulate(arr.begin(), arr.begin() + n / <span class="hljs-number">2</span>, <span class="hljs-number">0</span>)),<br>            <span class="hljs-built_in">abs</span>(accumulate(arr.begin() + n / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, arr.end(), <span class="hljs-number">0</span>)<br>            - accumulate(arr.begin(), arr.begin() + n / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>))<br>        );<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1 %d\n&quot;</span>, ans);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">int</span> ans =<br>            accumulate(arr.begin() + n / <span class="hljs-number">2</span>, arr.end(), <span class="hljs-number">0</span>)<br>            - accumulate(arr.begin(), arr.begin() + n / <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0 %d\n&quot;</span>, ans);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, sum = <span class="hljs-number">0</span>, halfsum = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;v[i]);<br>        sum += v[i];<br>    &#125;<br>    sort(v.begin(), v.end());<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n / <span class="hljs-number">2</span>; i++)<br>        halfsum += v[i];<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, n % <span class="hljs-number">2</span>, sum - <span class="hljs-number">2</span> * halfsum);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>数学</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1110 Complete Binary Tree (25分)</title>
    <link href="/2021/01/30/1110-Complete-Binary-Tree-25%E5%88%86/"/>
    <url>/2021/01/30/1110-Complete-Binary-Tree-25%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1110-Complete-Binary-Tree-25分"><a href="#1110-Complete-Binary-Tree-25分" class="headerlink" title="1110 Complete Binary Tree (25分)"></a>1110 Complete Binary Tree (25分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/ZwnLjP.png" alt="ZwnLjP"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题需要解决两个问题</p><ol><li>找到根结点</li><li>判断是否是完全二叉树</li></ol><p><strong>找根结点</strong></p><p>可以根据根结点的入度为0来寻找根结点。</p><p><strong>判断一颗二叉树树是否为完全二叉树</strong></p><p>完全二叉树除了最后一层，每一层从左到右边都是一颗满的。最后一层中，结点也是从左到右边，若中间存在结点丢失，那么该树就不是完全二叉树。</p><p>在层次遍历中，当遍历到某个结点的子结点不存在时候，设置一个<code>missing</code>标记当前结点的子结点丢失。若该结点的后面结点的子结点存在，那么就证明当前层的下一层中间出现了断层。证明是非完全二叉树。代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++">isComplete = <span class="hljs-literal">true</span>, missing = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">if</span> (tree[node].left != <span class="hljs-number">-1</span>) &#123; <span class="hljs-comment">// 假如左边结点存在</span><br><span class="hljs-keyword">if</span> (missing) isComplete = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 子结点层出现不存在结点的情况</span><br>q.push(tree[node].left);<br>&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 该层的左结点不存在</span><br>missing = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (tree[node].right != <span class="hljs-number">-1</span>) &#123; <span class="hljs-comment">// 右边结点存在</span><br><span class="hljs-keyword">if</span> (missing) isComplete = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 子结点层不存在的现象</span><br>q.push(tree[node].right);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>missing = <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：之前一直出现三个示例超出内存和答案错误，后来发现自己的结点输入使用的是<code>char</code>.</p><p>这里的输入要使用<code>string</code>,如果使用<code>char</code>的话，只能表示<code>10</code>以内的数字。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span><br>    <span class="hljs-keyword">int</span> left, right;<br>    node(): left(<span class="hljs-number">-1</span>), right(<span class="hljs-number">-1</span>) &#123;&#125;<br>&#125;tree[<span class="hljs-number">20</span>];<br><br><span class="hljs-keyword">int</span> inDegree[<span class="hljs-number">20</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> root)</span> </span>&#123;<br>    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q;<br>    <span class="hljs-keyword">int</span> lastnode = root;<br>    <span class="hljs-keyword">bool</span> isComplete = <span class="hljs-literal">true</span>, missing = <span class="hljs-literal">false</span>;<br>    q.push(root);<br>    <span class="hljs-keyword">while</span> (!q.empty()) &#123;<br>        <span class="hljs-keyword">int</span> size = q.size();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            <span class="hljs-keyword">int</span> node = q.front();<br>            lastnode = node;<br>            q.pop();<br>            <span class="hljs-keyword">if</span> (tree[node].left != <span class="hljs-number">-1</span>) &#123; <span class="hljs-comment">// 假如左边结点存在</span><br>                <span class="hljs-keyword">if</span> (missing) isComplete = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 子结点层出现不存在结点的情况</span><br>                q.push(tree[node].left);<br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 该层的左结点不存在</span><br>                missing = <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (tree[node].right != <span class="hljs-number">-1</span>) &#123; <span class="hljs-comment">// 右边结点存在</span><br>                <span class="hljs-keyword">if</span> (missing) isComplete = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 子结点层不存在的现象</span><br>                q.push(tree[node].right);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                missing = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s %d\n&quot;</span>, isComplete ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>, !isComplete ? root : lastnode);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">string</span> s1, s2;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; s1 &gt;&gt; s2; <span class="hljs-comment">// 这里不能使用字符，字符只能读10以内数字</span><br><br>        <span class="hljs-keyword">if</span> (s1 != <span class="hljs-string">&quot;-&quot;</span>) &#123;<br>            inDegree[stoi(s1)]++;<br>            tree[i].left = stoi(s1);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (s2 != <span class="hljs-string">&quot;-&quot;</span>) &#123;<br>            inDegree[stoi(s2)]++;<br>            tree[i].right = stoi(s2);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">int</span> root = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (inDegree[i] == <span class="hljs-number">0</span>) &#123;<br>            root = i;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    bfs(root);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><ul><li><a href="https://emhui.fun/2021/01/29/1123-Is-It-a-Complete-AVL-Tree-30%E5%88%86/">1123 Is It a Complete AVL Tree (30分)</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
      <tag>完全二叉树</tag>
      
      <tag>层次遍历</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>778. 水位上升的泳池中游泳</title>
    <link href="/2021/01/30/778-%E6%B0%B4%E4%BD%8D%E4%B8%8A%E5%8D%87%E7%9A%84%E6%B3%B3%E6%B1%A0%E4%B8%AD%E6%B8%B8%E6%B3%B3/"/>
    <url>/2021/01/30/778-%E6%B0%B4%E4%BD%8D%E4%B8%8A%E5%8D%87%E7%9A%84%E6%B3%B3%E6%B1%A0%E4%B8%AD%E6%B8%B8%E6%B3%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="778-水位上升的泳池中游泳"><a href="#778-水位上升的泳池中游泳" class="headerlink" title="778. 水位上升的泳池中游泳"></a><a href="https://leetcode-cn.com/problems/swim-in-rising-water/">778. 水位上升的泳池中游泳</a></h1><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/MYmJYZ.png" alt="MYmJYZ"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>Dijsktra</li><li>并查集</li><li>二分搜索</li></ul><h3 id="Dijsktra"><a href="#Dijsktra" class="headerlink" title="Dijsktra"></a>Dijsktra</h3><p>以网格中的值作为距离。</p><p>Dijsktra的步骤</p><ol><li>初始化参数</li><li>依次找到$n*n$个结点的最短距离<ol><li>找到最小的距离点</li><li>将该点的visited标记为已访问</li><li>判断是否到达了终点，若到了终点就返回该距离</li><li><strong>更新最短距离</strong></li></ol></li></ol><p>其中上面有两点需要注意</p><ul><li><code>dis[0,0] = grid[0][0]</code>，dis表示的达到降水的最大高度</li><li>更新最短距离需要选择 <code>dis[newX][newY] = max(dis[u][v], grid[newX][newY])</code></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">int</span> move[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;&#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">swimInWater</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-comment">// 找到一条权值点最小的路径，其中权值点最大的是答案</span><br>        <span class="hljs-comment">// 计算到达每个点的最小距离，结点值作为距离</span><br>        <span class="hljs-keyword">int</span> m = grid.size(), n = grid.size();<br>        <span class="hljs-keyword">int</span> INF = <span class="hljs-number">98764321</span>;<br>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&gt; <span class="hljs-title">visited</span><span class="hljs-params">(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;(n, <span class="hljs-literal">false</span>))</span></span>;<br>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dis</span><span class="hljs-params">(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n, INF))</span></span>;<br>        dis[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-comment">// 找到范围內最小的点</span><br>                <span class="hljs-keyword">int</span> u = <span class="hljs-number">-1</span>, v = <span class="hljs-number">-1</span>, minDis = INF;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; m; x++) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>; y &lt; n; y++) &#123;<br>                        <span class="hljs-keyword">if</span> (!visited[x][y] &amp;&amp; dis[x][y] &lt; minDis) &#123;<br>                            u = x;<br>                            v = y;<br>                            minDis = dis[x][y];<br>                        &#125;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-built_in">cout</span> &lt;&lt; u &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; v &lt;&lt; <span class="hljs-built_in">endl</span>;<br>                <span class="hljs-keyword">if</span> (u == <span class="hljs-number">-1</span> &amp;&amp; v == <span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>;<br>                visited[u][v] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 访问最小值</span><br>                <span class="hljs-keyword">if</span> (u == m - <span class="hljs-number">1</span> &amp;&amp; v == n - <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">return</span> dis[u][v];<br>                &#125;<br>                <span class="hljs-comment">// 开始优化四个角落</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; k++) &#123;<br>                    <span class="hljs-keyword">int</span> newX = u + move[k][<span class="hljs-number">0</span>];<br>                    <span class="hljs-keyword">int</span> newY = v + move[k][<span class="hljs-number">1</span>];<br>                    <span class="hljs-keyword">if</span> (newX &lt; <span class="hljs-number">0</span> || newX &gt;= m || newY &lt; <span class="hljs-number">0</span> || newY &gt;= n) <span class="hljs-keyword">continue</span>;<br>                    <span class="hljs-comment">// 更新距离,这一步如何实现</span><br>                    <span class="hljs-keyword">if</span> (!visited[newX][newY] &amp;&amp; max(dis[u][v], grid[newX][newY]) &lt; dis[newX][newY]) &#123;<br>                        dis[newX][newY] = max(dis[u][v], grid[newX][newY]);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>使用 <code>priority_queue</code>实现<code>Dijkstra</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 优先队列中的数据结构。其中 (i,j) 代表坐标，val 代表水位。</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Entry</span> &#123;</span><br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">int</span> j;<br>    <span class="hljs-keyword">int</span> val;<br>    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-keyword">const</span> Entry&amp; other) <span class="hljs-keyword">const</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;val &gt; other.val;<br>    &#125;<br>    Entry(<span class="hljs-keyword">int</span> ii, <span class="hljs-keyword">int</span> jj, <span class="hljs-keyword">int</span> val): i(ii), j(jj), val(val) &#123;&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">swimInWater</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = grid.size();<br>        priority_queue&lt;Entry, vector&lt;Entry&gt;, function&lt;bool(const Entry&amp; x, const Entry&amp; other)&gt;&gt; pq(&amp;Entry::operator&lt;);<br>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">visited</span><span class="hljs-params">(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n, <span class="hljs-number">0</span>))</span></span>;<br><br>        pq.push(Entry(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]));<br>        <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt; directions&#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;&#125;;<br>        <span class="hljs-keyword">while</span> (!pq.empty()) &#123;<br>            Entry x = pq.top();<br>            pq.pop();<br>            <span class="hljs-keyword">if</span> (visited[x.i][x.j] == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            visited[x.i][x.j] = <span class="hljs-number">1</span>;<br>            ret = max(ret, grid[x.i][x.j]);<br>            <span class="hljs-keyword">if</span> (x.i == n - <span class="hljs-number">1</span> &amp;&amp; x.j == n - <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> [di, dj]: directions) &#123;<br>                <span class="hljs-keyword">int</span> ni = x.i + di, nj = x.j + dj;<br>                <span class="hljs-keyword">if</span> (ni &gt;= <span class="hljs-number">0</span> &amp;&amp; ni &lt; n &amp;&amp; nj &gt;= <span class="hljs-number">0</span> &amp;&amp; nj &lt; n) &#123;<br>                    <span class="hljs-keyword">if</span> (visited[ni][nj] == <span class="hljs-number">0</span>) &#123;<br>                        pq.push(Entry(ni, nj, grid[ni][nj]));<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>Dijkstra</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1121 Damn Single (25分)</title>
    <link href="/2021/01/29/1121-Damn-Single-25%E5%88%86/"/>
    <url>/2021/01/29/1121-Damn-Single-25%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1121-Damn-Single-25分"><a href="#1121-Damn-Single-25分" class="headerlink" title="1121 Damn Single (25分)"></a>1121 Damn Single (25分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/KBBFxB.png" alt="KBBFxB"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>设置两个数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">100000</span>;<br><span class="hljs-keyword">int</span> couples[MAX];<span class="hljs-comment">// 存储下标为i对应的对象</span><br><span class="hljs-keyword">bool</span> party[MAX] = &#123;<span class="hljs-literal">false</span>&#125;; <span class="hljs-comment">// 下标为i的人是否参加聚会</span><br></code></pre></td></tr></table></figure><p>接下来使用<code>couples</code>建立映射后，判断一个人是否能参加派对，有下面两个准则</p><ul><li>如果没有伴侣或有对象，但对象没有参加，自己就参加。</li><li>如果对象参加了，叫对象退出派对。</li></ul><p>代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 如果没有伴侣或有对象，但对象没有参加，自己就参加</span><br><span class="hljs-keyword">if</span> (couples[u] == <span class="hljs-number">-1</span> || party[couples[u]] == <span class="hljs-literal">false</span>) &#123;<br>party[u] = <span class="hljs-literal">true</span>;<br>cnt++; <span class="hljs-comment">// 参加派对人数+1</span><br>&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 对象参加了，叫对象退出聚会</span><br>party[couples[u]] = <span class="hljs-literal">false</span>;<br>cnt--; <span class="hljs-comment">// 同时参加派对人数-1</span><br>&#125;<br></code></pre></td></tr></table></figure><p>最后对<code>party</code>从小到大判断是否参加了派对，并输出下标。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">100000</span>;<br><span class="hljs-keyword">int</span> couples[MAX];<span class="hljs-comment">// 哈希表，配对使用</span><br><span class="hljs-keyword">bool</span> party[MAX] = &#123;<span class="hljs-literal">false</span>&#125;; <span class="hljs-comment">// 若是单身的则参加，不是单身的就退出。</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, m, u, v;<br>    fill(couples, couples + MAX, <span class="hljs-number">-1</span>);<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; u &gt;&gt; v;<br>        couples[u] = v;<br>        couples[v] = u;<br>    &#125;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; m;<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>; <span class="hljs-comment">// 单身人数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; u;<br>        <span class="hljs-comment">// 如果没有伴侣或有对象，但对象没有参加，自己就参加</span><br>        <span class="hljs-keyword">if</span> (couples[u] == <span class="hljs-number">-1</span> || party[couples[u]] == <span class="hljs-literal">false</span>) &#123;<br>            party[u] = <span class="hljs-literal">true</span>;<br>            cnt++;<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 对象参加了，叫对象退出聚会</span><br>            party[couples[u]] = <span class="hljs-literal">false</span>;<br>            cnt--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, cnt);<br>    <span class="hljs-keyword">if</span> (cnt == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 需要考虑为0的情况。</span><br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX; i++) &#123;<br>        <span class="hljs-keyword">if</span> (party[i]) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d&quot;</span>, i); <span class="hljs-comment">// 因为编号是5位数字，范围 00000 - 99999</span><br>            <span class="hljs-keyword">if</span> (++count &lt; cnt) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
      <tag>哈希表</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1123 Is It a Complete AVL Tree (30分)</title>
    <link href="/2021/01/29/1123-Is-It-a-Complete-AVL-Tree-30%E5%88%86/"/>
    <url>/2021/01/29/1123-Is-It-a-Complete-AVL-Tree-30%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1123-Is-It-a-Complete-AVL-Tree-30分"><a href="#1123-Is-It-a-Complete-AVL-Tree-30分" class="headerlink" title="1123 Is It a Complete AVL Tree (30分)"></a>1123 Is It a Complete AVL Tree (30分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/Y8O0QN.png" alt="Y8O0QN"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题主要考察两个知识点：</p><ul><li>构建平衡二叉树</li><li>判断是否是完全二叉树</li></ul><p>构建一个平衡二叉树</p><blockquote><p>参考<a href="https://emhui.fun/2021/01/20/1066-Root-of-AVL-Tree/">1066 Root of AVL Tree</a></p></blockquote><p>判断是否是完全二叉树</p><blockquote><p>判断是不是完全二叉树，就看在出现了一个孩子为空的结点之后是否还会出现孩子结点不为空的结点，如果出现了就不是完全二叉树。</p></blockquote><p>代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">bool</span> isComplete = <span class="hljs-literal">true</span>, missing = <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">// 左结点不存在，右结点存在 ｜｜ 存在丢失结点且后面子结点还存在</span><br><span class="hljs-keyword">if</span> ((!node-&gt;left &amp;&amp; node-&gt;right) || (missing &amp;&amp; (node-&gt;left || node-&gt;right))) &#123;<br>    isComplete = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 若一个存在，则存在丢失结点</span><br><span class="hljs-keyword">if</span> (!root-&gt;left || !root-&gt;right) &#123;<br>    missing = <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span> &#123;</span><br>    <span class="hljs-keyword">int</span> val, height;<br>    TreeNode *left, *right;<br>&#125; *root;<br><br><span class="hljs-function">TreeNode* <span class="hljs-title">newNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>    TreeNode *node = <span class="hljs-keyword">new</span> TreeNode;<br>    node-&gt;val = val;<br>    node-&gt;height = <span class="hljs-number">1</span>;<br>    node-&gt;left = node-&gt;right = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getHeight</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> root-&gt;height;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">updateHeight</span><span class="hljs-params">(TreeNode* &amp;root)</span> </span>&#123;<br>    root-&gt;height = max(getHeight(root-&gt;left), getHeight(root-&gt;right)) + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getBalanceFactor</span><span class="hljs-params">(TreeNode* &amp;root)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> getHeight(root-&gt;left) - getHeight(root-&gt;right);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">R</span><span class="hljs-params">(TreeNode* &amp;root)</span> </span>&#123;<br>    TreeNode* temp = root-&gt;left;<br>    root-&gt;left = temp-&gt;right;<br>    temp-&gt;right = root;<br>    updateHeight(root);<br>    updateHeight(temp);<br>    root = temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">L</span><span class="hljs-params">(TreeNode* &amp;root)</span> </span>&#123;<br>    TreeNode* temp = root-&gt;right;<br>    root-&gt;right = temp-&gt;left;<br>    temp-&gt;left = root;<br>    updateHeight(root);<br>    updateHeight(temp);<br>    root = temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(TreeNode* &amp;root, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) &#123;<br>        root = newNode(val);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (root-&gt;val &gt; val) &#123; <span class="hljs-comment">// 插入到左边</span><br>        insert(root-&gt;left, val);<br>        updateHeight(root); <span class="hljs-comment">// 插入后看看树的高度是否满足要求</span><br>        <span class="hljs-comment">// 开始处理平衡问题</span><br>        <span class="hljs-keyword">if</span> (getBalanceFactor(root) == <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">if</span> (getBalanceFactor(root-&gt;left) == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// LL</span><br>                R(root);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (getBalanceFactor(root-&gt;left) == <span class="hljs-number">-1</span>) &#123; <span class="hljs-comment">// LR</span><br>                L(root-&gt;left);<br>                R(root);<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        insert(root-&gt;right, val);<br>        updateHeight(root);<br>        <span class="hljs-keyword">if</span> (getBalanceFactor(root) == <span class="hljs-number">-2</span>) &#123;<br>            <span class="hljs-keyword">if</span> (getBalanceFactor(root-&gt;right) == <span class="hljs-number">-1</span>) &#123;<br>                L(root);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (getBalanceFactor(root-&gt;right) == <span class="hljs-number">1</span>) &#123;<br>                R(root-&gt;right);<br>                L(root);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">int</span> isComplete = <span class="hljs-number">1</span>, after = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-built_in">queue</span>&lt;TreeNode*&gt; q;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans;<br>    q.push(root);<br>    TreeNode* node;<br>    <span class="hljs-keyword">while</span> (!q.empty()) &#123;<br>        <span class="hljs-keyword">int</span> size = q.size();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            node = q.front();<br>            q.pop();<br>            ans.push_back(node-&gt;val);<br>            <span class="hljs-keyword">if</span> (node-&gt;left) &#123;<br>                <span class="hljs-keyword">if</span> (after) isComplete = <span class="hljs-number">0</span>;<br>                q.push(node-&gt;left);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                after = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (node-&gt;right) &#123;<br>                <span class="hljs-keyword">if</span> (after) isComplete = <span class="hljs-number">0</span>; <span class="hljs-comment">// 若左边存在，右边不存在，则不是完全二叉树</span><br>                q.push(node-&gt;right);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                after = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ans.size(); i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ans[i]);<br>        <span class="hljs-keyword">if</span> (i &lt; ans.size() - <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, val;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;val);<br>        insert(root, val);<br>    &#125;<br>    bfs(root);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, isComplete ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="平衡二叉树建立模板"><a href="#平衡二叉树建立模板" class="headerlink" title="平衡二叉树建立模板"></a>平衡二叉树建立模板</h2><p>记住下面关键几点</p><ul><li>一个获取高度的函数</li><li>两个旋转函数R,L</li><li>四种树形结构<ul><li>LL: 根结点R</li><li>LR: 根结点左子树L,根结点R</li><li>RR: 根结点L</li><li>RL: 根结点右子树R,根结点L</li></ul></li><li>判断当前结点属于上面哪种树形结构<ul><li>LL: getH(root-&gt;left) - getH(root-&gt;right) == 2</li><li>LR: getH(root-&gt;left) - getH(root-&gt;right) == 2 &amp;&amp; root-&gt;left-&gt;val &lt; val</li><li>RR: getH(root-&gt;left) - getH(root-&gt;right) == -2</li><li>RL: getH(root-&gt;left) - getH(root-&gt;right) == -2 &amp;&amp; root-&gt;right-&gt;val &gt; val</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span> &#123;</span><br>    <span class="hljs-keyword">int</span> val;<br>    TreeNode *left, *right;<br>&#125; *root;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">R</span><span class="hljs-params">(TreeNode* &amp;root)</span> </span>&#123;<br>    TreeNode* temp = root-&gt;left;<br>    root-&gt;left = temp-&gt;right;<br>    temp-&gt;right = root;<br>    root = temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">L</span><span class="hljs-params">(TreeNode* &amp;root)</span> </span>&#123;<br>    TreeNode* temp = root-&gt;right;<br>    root-&gt;right = temp-&gt;left;<br>    temp-&gt;left = root;<br>    root = temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getHeight</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> max(getHeight(root-&gt;left), getHeight(root-&gt;right)) + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(TreeNode* &amp;root, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) &#123;<br>        root = <span class="hljs-keyword">new</span> TreeNode;<br>        root-&gt;val = val;<br>        root-&gt;left = root-&gt;right = <span class="hljs-literal">NULL</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root-&gt;val &gt; val) &#123; <span class="hljs-comment">// 左子树</span><br>        insert(root-&gt;left, val);<br>        <span class="hljs-keyword">int</span> l = getHeight(root-&gt;left), r = getHeight(root-&gt;right);<br>        <span class="hljs-keyword">if</span> (l - r == <span class="hljs-number">2</span>) &#123; <span class="hljs-comment">// l</span><br>            <span class="hljs-keyword">if</span> (root-&gt;left-&gt;val &lt; val) &#123; <span class="hljs-comment">// LR 新的结点被插入左边结点的右子树</span><br>                L(root-&gt;left);<br>            &#125;<br>            R(root);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        insert(root-&gt;right,val);<br>        <span class="hljs-keyword">int</span> l = getHeight(root-&gt;left), r = getHeight(root-&gt;right);<br>        <span class="hljs-keyword">if</span> (l - r == <span class="hljs-number">-2</span>) &#123; <span class="hljs-comment">// R</span><br>            <span class="hljs-keyword">if</span> (root-&gt;right-&gt;val &gt; val) &#123; <span class="hljs-comment">// RL 新的结点插入到右子树的左边</span><br>                R(root-&gt;right);<br>            &#125;<br>            L(root);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, val;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;val);<br>        insert(root, val);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, root-&gt;val);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><ul><li><a href="https://emhui.fun/2021/01/20/1066-Root-of-AVL-Tree/">1066 Root of AVL Tree</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
      <tag>完全二叉树</tag>
      
      <tag>平衡二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1122 Hamiltonian Cycle (25分)</title>
    <link href="/2021/01/29/1122-Hamiltonian-Cycle-25%E5%88%86/"/>
    <url>/2021/01/29/1122-Hamiltonian-Cycle-25%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1122-Hamiltonian-Cycle-25分"><a href="#1122-Hamiltonian-Cycle-25分" class="headerlink" title="1122 Hamiltonian Cycle (25分)"></a>1122 Hamiltonian Cycle (25分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/OpU7ZA.png" alt="OpU7ZA"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>判断是否是<strong>Hamiltonian Cycle</strong></p><ol><li>首尾元素要一样</li><li>必须遍历所有点</li><li>不存在环，即边的个数为点的个数-1.</li><li>连续两个顶点之间直接连通</li></ol><blockquote><p>可以使用并查集来做,但是题目没有这么难，代码二是使用并查集做的，其中有一个用例没有通过，原因应该是无法判断第4点是否满足，有连续两点没有直接连通，但是并查集并做不到查询两个点是否属于直接连通的。</p></blockquote><p>根据上面四条依据，我们可以作出下面判断</p><blockquote><p>存在多个环的依据是什么？如果只有一个简单环，那么顶点个数和边的个数一样，否则可能存在多个环。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">bool</span> flag1 = <span class="hljs-literal">true</span>, flag2 = <span class="hljs-literal">true</span>;<br><br><span class="hljs-keyword">if</span> (没有遍历所有点 || 首位元素不一致 || 存在多个环) &#123;<br>flag1 = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">for</span> (遍历给出的顶点) &#123;<br><span class="hljs-keyword">if</span> (两个顶点不可达) flag2 = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, flag1 &amp;&amp; flag2 ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">210</span>;<br><span class="hljs-keyword">int</span> G[MAX][MAX] = &#123;<span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, m, k, num, val, u, v;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; u &gt;&gt; v;<br>        G[u][v] = G[v][u] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; k;<br>    <span class="hljs-keyword">while</span> (k--) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; num;<br>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(num)</span></span>;<br>        <span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt; s;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++) &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; ans[i];<br>            s.insert(ans[i]);<br>        &#125;<br>        <span class="hljs-keyword">bool</span> flag1 = <span class="hljs-literal">true</span>, flag2 = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// if (没有遍历所有点 || 首位元素不一致 || 存在多个环 )</span><br>        <span class="hljs-keyword">if</span> (s.size() != n || ans[<span class="hljs-number">0</span>] != ans[num - <span class="hljs-number">1</span>] || num - <span class="hljs-number">1</span> != n) &#123;<br>            flag1 = <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 判断连续两点是否连通</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (G[ans[i]][ans[i+<span class="hljs-number">1</span>]] == <span class="hljs-number">0</span>) &#123;<br>                flag2 = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, flag1 &amp;&amp; flag2 ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span>&#123;</span><br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; parent;<br>    <span class="hljs-keyword">int</span> setCount;<br>    <span class="hljs-keyword">public</span>:<br>    UnionFind(<span class="hljs-keyword">int</span> n) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) parent.push_back(i);<br>        setCount = n;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n != parent[n]) parent[n] = find(parent[n]);<br>        <span class="hljs-keyword">return</span> parent[n];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> uRoot = find(u), vRoot = find(v);<br>        <span class="hljs-keyword">if</span> (uRoot == vRoot) <span class="hljs-keyword">return</span>;<br>        parent[uRoot] = vRoot;<br>        setCount--;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> setCount;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isConnected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v)</span> </span>&#123;<span class="hljs-keyword">return</span> find(u) == find(v);&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, m, k, u, v, cnt;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; node;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-function">UnionFind <span class="hljs-title">uf</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; u &gt;&gt; v;<br>        <span class="hljs-keyword">if</span> (!uf.isConnected(u, v)) &#123;<br>            uf.unite(u, v);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; k;<br>    <span class="hljs-keyword">while</span> (k--) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; cnt;<br>        node.resize(cnt);<br>        fill(visited.begin(), visited.end(), <span class="hljs-literal">false</span>);<br>        <span class="hljs-comment">// visited.resize(cnt + 1); // 记录1-n是否被访问过</span><br>        <span class="hljs-keyword">bool</span> hasvisited = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 是否重复访问过</span><br>        <span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt; s;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cnt; i++) &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;node[i]);<br>            s.insert(node[i]);<br>        &#125;<br>        <span class="hljs-comment">// printf(&quot;%d\n&quot;, node[0] != node[n - 1]);</span><br>        <span class="hljs-keyword">if</span> ((cnt - <span class="hljs-number">1</span> != n) || (s.size() != n) || (node[<span class="hljs-number">0</span>] != node[cnt - <span class="hljs-number">1</span>]) || (uf.getCount() &gt; <span class="hljs-number">2</span>)) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NO\n&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;YES\n&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
      <tag>图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1124 Raffle for Weibo Followers (20分)</title>
    <link href="/2021/01/29/1124-Raffle-for-Weibo-Followers-20%E5%88%86/"/>
    <url>/2021/01/29/1124-Raffle-for-Weibo-Followers-20%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1124-Raffle-for-Weibo-Followers-20分"><a href="#1124-Raffle-for-Weibo-Followers-20分" class="headerlink" title="1124 Raffle for Weibo Followers (20分)"></a>1124 Raffle for Weibo Followers (20分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/FOiX1w.png" alt="FOiX1w"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><strong>分析</strong></p><p>使用<code>unordered_map</code>记录已经抽过奖的人。</p><p>在使用<code>cnt</code>记录当前参加的人数，从第n个人开始，每一轮转发<code>cnt++</code>,当<code>cnt % n == 0</code>,即每第n个人成为获奖者，但是如果这个人已经获奖了，那么<code>cnt--</code>，将他的中奖名额给下一个人。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">string</span> name;<br>    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt; winners;<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>, m, n, s;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; m &gt;&gt; n &gt;&gt; s;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; name;<br>        <span class="hljs-keyword">if</span> (i &gt;= s) &#123;<br>            <span class="hljs-keyword">if</span> (cnt % n == <span class="hljs-number">0</span> &amp;&amp; winners.find(name) == winners.end()) &#123;<br>                winners[name] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 添加到winner中</span><br>                <span class="hljs-built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="hljs-built_in">endl</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cnt % n == <span class="hljs-number">0</span> &amp;&amp; winners.find(name) != winners.end()) &#123;<br>                cnt--; <span class="hljs-comment">// 如果遇到相同的，就后退一步，下一步才是获胜者。</span><br>            &#125;<br>            cnt++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (s &gt; m) <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Keep going...\n&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1126 Eulerian Path</title>
    <link href="/2021/01/28/1126-Eulerian-Path/"/>
    <url>/2021/01/28/1126-Eulerian-Path/</url>
    
    <content type="html"><![CDATA[<h1 id="1126-Eulerian-Path-25分"><a href="#1126-Eulerian-Path-25分" class="headerlink" title="1126 Eulerian Path (25分)"></a>1126 Eulerian Path (25分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/tBt70U.png" alt="tBt70U"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><strong>题目要求</strong></p><p><del>给定一个图</del></p><p><del>1. 以顶点索引，以为升序方式输出按每个顶点的度。</del></p><p><del>2. 判断该图是否是以下三种类型的图</del></p><p><del>- Eulerian: 从起点出发，一条路径可以遍历每条边，则<strong>每条边访问1次</strong>，并最终回到起点</del><br><del>- semi-Eulerian:从起点出发，一条路径可以遍历每条边，则每条边访问1次，但是无法回到起点。</del><br><del>- non-Eulerian: 不存在连通所有顶点的路径。</del></p><p><strong>分析</strong></p><blockquote><p><del>转化成连通图问题，若n个顶点，没有连通，则是<code>non</code>,若n个顶点，连通，且边的个数为n-1。那么就是<code>semi-eulerian</code>如何判断每条边被访问过一次呢</del></p></blockquote><p>分析个🔨，😠</p><p>题目都没看明白。其实本题很简单，重点是下面这句话</p><blockquote><p>It has been proven that connected graphs with all vertices of even degree have an Eulerian circuit, and such graphs are called Eulerian. If there are exactly two vertices of odd degree, all Eulerian paths start at one of them and end at the other. A graph that has an Eulerian path but not an Eulerian circuit is called semi-Eulerian.</p></blockquote><p>翻译过来就是</p><ul><li>所有顶点的度为偶数就是<code>Eulerian</code></li><li>仅有两个顶点的度为奇数，其他度为偶数就是<code>semi-Eulerian</code></li><li>其他条件下就是<code>non-Eulerian</code></li></ul><p>还有一个前提，就是判断该图是否连通所有顶点，若没有连通，则也属于<code>non-Eulerian</code>。判断是否全部连通，可以使用并查集来实现。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 如果一个连通图的所有结点的度都是偶数，那么它就是Eulerian</span><br><span class="hljs-comment">// 如果除了两个结点的度是奇数其他都是偶数，那么它就是Semi-Eulerian</span><br><span class="hljs-comment">// 否则就是Non-Eulerian</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span>&#123;</span><br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; parent;<br>    <span class="hljs-keyword">int</span> cnt; <span class="hljs-comment">// 连通分量</span><br>    <span class="hljs-keyword">public</span>:<br>    UnionFind(<span class="hljs-keyword">int</span> n) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;parent.push_back(i);&#125;<br>        cnt = n;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n != parent[n]) &#123;<br>            parent[n] = find(parent[n]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> parent[n];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> uRoot = find(u), vRoot = find(v);<br>        <span class="hljs-keyword">if</span> (uRoot == vRoot) <span class="hljs-keyword">return</span>;<br>        parent[uRoot] = vRoot;<br>        cnt--;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isConnected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> find(u) == find(v);<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, m, u, v;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">inDegree</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-function">UnionFind <span class="hljs-title">uf</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; u &gt;&gt; v;<br>        inDegree[u]++;<br>        inDegree[v]++;<br>        <span class="hljs-keyword">if</span> (!uf.isConnected(u, v)) &#123;<br>            uf.merge(u, v);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>; <span class="hljs-comment">// 入度为奇数的个数。</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (inDegree[i] &amp; <span class="hljs-number">1</span>) &#123;cnt++;&#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, inDegree[i]);<br>        <span class="hljs-keyword">if</span> (i &lt; n) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-keyword">if</span> (uf.getCount() - <span class="hljs-number">1</span> &gt; <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 所有点没有连通肯定是Non</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Non-Eulerian\n&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cnt == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Eulerian\n&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cnt == <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Semi-Eulerian\n&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Non-Eulerian\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
      <tag>图</tag>
      
      <tag>union-find</tag>
      
      <tag>欧拉图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1125 Chain the Ropes</title>
    <link href="/2021/01/28/1125-Chain-the-Ropes/"/>
    <url>/2021/01/28/1125-Chain-the-Ropes/</url>
    
    <content type="html"><![CDATA[<h1 id="1125-Chain-the-Ropes-25分"><a href="#1125-Chain-the-Ropes-25分" class="headerlink" title="1125 Chain the Ropes (25分)"></a>1125 Chain the Ropes (25分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/aGJWm3.png" alt="aGJWm3"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>题目意思</strong></p><p>题目要求<strong>将所有绳子连接起来</strong>，组成的最大长度是多少。求最后绳子的最大长度。</p><p>Given some segments of rope, you are supposed to <strong>chain them into one rope</strong>。</p><p><strong>分析</strong></p><p>因为每次俩俩折叠长度就会减半，所以最长的绳子应该放到最后再折叠。先将绳子进行排序，然后按长度从小到进行连接和折叠。</p><p><strong>问题</strong></p><p>题目中最后输出有一句话</p><blockquote><p> The result must be rounded to the nearest integer that is no greater than the maximum length.</p></blockquote><p>这句话不是说结果需要四舍五入吗？但是使用四舍五入的话，最后用例无法通过。奇怪…</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<span class="hljs-built_in">cin</span> &gt;&gt; ans[i];&#125;<br>    sort(ans.begin(), ans.end());<br>    sum = ans[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        sum = (sum + ans[i]) / <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, sum);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>数学</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1127 ZigZagging on a Tree</title>
    <link href="/2021/01/28/1127-ZigZagging-on-a-Tree/"/>
    <url>/2021/01/28/1127-ZigZagging-on-a-Tree/</url>
    
    <content type="html"><![CDATA[<h1 id="1127-ZigZagging-on-a-Tree-30分"><a href="#1127-ZigZagging-on-a-Tree-30分" class="headerlink" title="1127 ZigZagging on a Tree (30分)"></a>1127 ZigZagging on a Tree (30分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/QNkta0.png" alt="QNkta0"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><strong>题目要求</strong></p><p>本题题目比较简单，就是<strong>根据中序后续建立树</strong>和<strong>树的层次遍历</strong></p><ul><li><p>给出中序和后序，建立二叉树</p></li><li><p>层次遍历，左右来回输出</p></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>&#123;</span><br>    <span class="hljs-keyword">int</span> val;<br>    TreeNode *left, *right;<br>&#125;;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; inorder, postorder;<br><br><span class="hljs-function">TreeNode* <span class="hljs-title">create</span><span class="hljs-params">(<span class="hljs-keyword">int</span> inL, <span class="hljs-keyword">int</span> inR, <span class="hljs-keyword">int</span> postL, <span class="hljs-keyword">int</span> postR)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (postL &gt; postR) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    TreeNode* root = <span class="hljs-keyword">new</span> TreeNode;<br>    root-&gt;val = postorder[postR]; <span class="hljs-comment">// 根结点</span><br>    <span class="hljs-keyword">int</span> mid = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (mid = inL; mid &lt;= inR; mid++) &#123;<br>        <span class="hljs-keyword">if</span> (postorder[postR] == inorder[mid]) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">int</span> num = mid - inL; <span class="hljs-comment">// inorder左子树的数量</span><br>    root-&gt;left = create(inL, mid - <span class="hljs-number">1</span>, postL, postL + num - <span class="hljs-number">1</span>);<br>    root-&gt;right = create(mid + <span class="hljs-number">1</span>, inR, postL + num, postR - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-built_in">queue</span>&lt;TreeNode*&gt; q;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans, temp;<br>    <span class="hljs-keyword">int</span> level = <span class="hljs-number">0</span>;<br>    q.push(root);<br>    <span class="hljs-comment">//ans.push_back(root-&gt;val);</span><br>    <span class="hljs-keyword">while</span> (!q.empty()) &#123;<br>        <span class="hljs-keyword">int</span> size = q.size();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            TreeNode* node = q.front();<br>            temp.push_back(node-&gt;val);<br>            q.pop();<br>            <span class="hljs-keyword">if</span> (node-&gt;left) q.push(node-&gt;left);<br>            <span class="hljs-keyword">if</span> (node-&gt;right) q.push(node-&gt;right);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (++level &amp; <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 如果是奇数层，否则逆序输出（层数从0开始）</span><br>            reverse(temp.begin(), temp.end());<br>        &#125;<br>        ans.insert(ans.end(), temp.begin(), temp.end());<br>        temp.clear();<br>    &#125;<br>    <span class="hljs-keyword">int</span> n = ans.size();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ans[i]);<br>        <span class="hljs-keyword">if</span> (i &lt; n - <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    inorder.resize(n);<br>    postorder.resize(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<span class="hljs-built_in">cin</span> &gt;&gt; inorder[i];&#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<span class="hljs-built_in">cin</span> &gt;&gt; postorder[i];&#125;<br>    TreeNode* root = create(<span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>);<br>    bfs(root);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
      <tag>bfs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1129 Recommendation System</title>
    <link href="/2021/01/28/1129-Recommendation-System/"/>
    <url>/2021/01/28/1129-Recommendation-System/</url>
    
    <content type="html"><![CDATA[<h1 id="1129-Recommendation-System-25分"><a href="#1129-Recommendation-System-25分" class="headerlink" title="1129 Recommendation System (25分)"></a>1129 Recommendation System (25分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/Y2QMHY.png" alt="Y2QMHY"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><strong>题目意思</strong></p><p>本题要求制作一个推荐系统，输出一系列的值，从第二个值开始，预测用户接下来可能会输出的值。</p><p>用户可能输出的值是<strong>根据之前的输入</strong>（所以输入第一个值的时候是没有输出的），按照某个树的输入频率进行排序，若输入频率一致，则根据该值升序输出。推荐的数字数量不能超过K.</p><p><strong>分析</strong></p><blockquote><p>一开始没看懂题目意思，直接放弃了，后来看别人解析才看懂。</p></blockquote><p>首先需要思考如何存储之前输入的值，且需要将之前的值和出现的频率绑定在一起并排序。</p><p>这里使用<code>pair&lt;int, int&gt;</code>将<code>出现频率</code>和<code>货品ID</code>绑定到一起。即<code>pair&lt;出现频率, 货品ID&gt;</code>。</p><p>但是在输入的时候，如果输入的ID是之前出现过的东西，如何更新<code>pair&lt;int, int&gt;</code>呢？</p><p>先考虑如何找到之前已经存在的<code>pair&lt;int,int&gt;</code>。使用<code>set</code>集合，<code>set</code>中的<code>find</code>方法可以查找到之前插入的值。同时也要设置一个变量<code>vector&lt;int&gt; visited(n)</code>。记录每个货品出现的次数。这样当输入之前出现过的商品，对商品更新可以使用下面方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">auto</span> it = recommends.find(<span class="hljs-built_in">make_pair</span>(visited[itemId], itemId));<br><span class="hljs-keyword">if</span> (it != recommends.end()) &#123;recommends.erase(it);&#125; <span class="hljs-comment">// 删除之前的记录</span><br>visited[itemId]++; <span class="hljs-comment">// 更新货品的出现频率</span><br>recommends.insert(<span class="hljs-built_in">make_pair</span>(visited[itemId], itemId));<br></code></pre></td></tr></table></figure><p>最后一个问题就是，<code>set</code>如何根据<strong>货品出现频率降序，货品id升序</strong>。由于<code>set</code>使用红黑树实现，本身就有序，不能通过<code>sort</code>排序。最后参考<a href="https://blog.csdn.net/lv1224/article/details/79789638">C++ set自定义排序</a><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="C++ set自定义排序">[1]</span></a></sup>.方法如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&amp; a, <span class="hljs-keyword">const</span> <span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&amp; b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (a.first != b.first) <span class="hljs-keyword">return</span> a.first &gt; b.first;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> a.second &lt; b.second;<br>&#125;<br><br>set&lt;pair&lt;int, int&gt;, decltype(cmp)*&gt; recommends(cmp); // 每次插入新的元素的时候，会根据第一个降序，第二个升序排序。<br><br></code></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 用一个visited[n]存储每个点数量</span><br><span class="hljs-comment">// 用一个集合更新推荐列表 set&lt;pair&lt;int,int&gt;&gt; 第一个是数量，第二个是item</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;utility&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&amp; a, <span class="hljs-keyword">const</span> <span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&amp; b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (a.first != b.first) <span class="hljs-keyword">return</span> a.first &gt; b.first;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> a.second &lt; b.second;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, k, val;<br>    set&lt;pair&lt;int, int&gt;, decltype(cmp)*&gt; recommends(cmp); // 推荐列表，先前是访问次数，后面是货品ID<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; k &gt;&gt; val; <span class="hljs-comment">// val 第一件被访问的东西</span><br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// 每个货品被访问次数</span><br>    visited[val]++;<br>    recommends.insert(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1</span>, val)); <span class="hljs-comment">// ID为val的东西被访问1次</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; val;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d:&quot;</span>, val);<br>        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = recommends.begin(); cnt &lt; k &amp;&amp; it != recommends.end(); it++) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d&quot;</span>, it-&gt;second);<br>            cnt++;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>        <span class="hljs-comment">// 开始插入或更新推荐列表</span><br>        <span class="hljs-keyword">auto</span> it = recommends.find(<span class="hljs-built_in">make_pair</span>(visited[val], val));<br>        <span class="hljs-keyword">if</span> (it != recommends.end()) recommends.erase(it);<br>        visited[val]++;<br>        recommends.insert(<span class="hljs-built_in">make_pair</span>(visited[val], val));<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><section class="footnotes"><h2>参考</h2><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://blog.csdn.net/lv1224/article/details/79789638">C++ set自定义排序</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
      <tag>set</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1130 Infix Expression</title>
    <link href="/2021/01/28/1130-Infix-Expression/"/>
    <url>/2021/01/28/1130-Infix-Expression/</url>
    
    <content type="html"><![CDATA[<h1 id="1130-Infix-Expression-25分"><a href="#1130-Infix-Expression-25分" class="headerlink" title="1130 Infix Expression (25分)"></a>1130 Infix Expression (25分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/b0uWgX.png" alt="b0uWgX"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>给一个表达式的树，输出正确表达</p><p>两个问题</p><ol><li>如何找到根结点？</li></ol><p>根据入度，根结点的入度为0<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="PAT 1130 Infix Expression">[1]</span></a></sup>，其他结点的入度为1或2.</p><ol start="2"><li>根据什么规则添加括号</li></ol><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/MSe3Ss.png" alt="MSe3Ss"></p><p>通过对上图分析，根结点一定是操作符，而叶子结点是值。添加括号的规则如下</p><ol><li>若当前结点存在左右结点，则需要添加如下格式括号</li></ol><p><code>&quot;(&quot; + t[root].left + t[root].val + t[root].right + &quot;)&quot;</code></p><p>图一中的<code>+,*</code>就是这种情况</p><ol start="2"><li><p>若当前结点为叶子结点，可直接返回结点值。 图一中<code>a,b,c,d</code>就是这种情况</p></li><li><p>若当前结点的左子树不存在，右子树存在，则添加下面格式括号</p></li></ol><p><code>&quot;(&quot; + t[root].val + t[root].right + &quot;)&quot;</code></p><p>图一中，<code>(-d)</code>就是这种情况</p><ol start="4"><li>若当前结点左子树存在，右子树不存在。规则是否是下面这种呢？</li></ol><p><code>&quot;(&quot; + t[root].left + t[root].val + &quot;)&quot;</code></p><p>不可能是这种情况，因为根结点是运算符，运算符后面必须有值。</p><p>把图一中的<code>(-d)</code>来举例，假如<code>d</code>在<code>-</code>的左边，那么会出现 <code>(d-)</code>。显然不存在这种算式。</p><p>综上所述，递归有三种情况<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote">&lt;span class=”hint–top hint–rounded” aria-label=”PAT 1130. Infix Expression (25)-甲级</p><p>“&gt;[2]</span></a></sup>：</p><ol><li>左右子树都空 返回 “(” + 根 + “)”</li><li>左空右不空 返回 “(” + 根 + 右子树 + “)”</li><li>左右都不空 返回 “(” + 左子树 + 根 + 右子树 + “)”</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">21</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>&#123;</span><br>    <span class="hljs-built_in">string</span> val;<br>    <span class="hljs-keyword">int</span> left, right;<br>&#125;tree[MAX];<br><span class="hljs-keyword">int</span> inDegree[MAX] = &#123;<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// 计算每个结点的入度，根结点的入度为0；</span><br><br><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (tree[root].left == <span class="hljs-number">-1</span> &amp;&amp; tree[root].right == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> tree[root].val;<br>    <span class="hljs-keyword">if</span> (tree[root].left != <span class="hljs-number">-1</span> &amp;&amp; tree[root].right != <span class="hljs-number">-1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;(&quot;</span> + dfs(tree[root].left) + tree[root].val + dfs(tree[root].right) + <span class="hljs-string">&quot;)&quot;</span>;<br>    <span class="hljs-comment">// (-d)这种情况，不可能出现 (d-)这种情况，运算符后面一定是需要内容的，即存在右结点</span><br>    <span class="hljs-keyword">if</span> (tree[root].left == <span class="hljs-number">-1</span> &amp;&amp; tree[root].right != <span class="hljs-number">-1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;(&quot;</span> + tree[root].val + dfs(tree[root].right) + <span class="hljs-string">&quot;)&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; tree[i].val &gt;&gt; tree[i].left &gt;&gt; tree[i].right;<br>        <span class="hljs-keyword">if</span> (tree[i].left != <span class="hljs-number">-1</span>) inDegree[tree[i].left]++; <span class="hljs-comment">// 入度+1</span><br>        <span class="hljs-keyword">if</span> (tree[i].right != <span class="hljs-number">-1</span>) inDegree[tree[i].right]++; <span class="hljs-comment">// 入度+1</span><br>    &#125;<br>    <span class="hljs-keyword">int</span> root = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (inDegree[i] == <span class="hljs-number">0</span>) &#123;<br>            root = i;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">string</span> ans = dfs(root);<br>    <span class="hljs-keyword">if</span> (ans[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;(&#x27;</span>) ans = ans.substr(<span class="hljs-number">1</span>, ans.size() - <span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="hljs-built_in">endl</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><section class="footnotes"><h2>参考</h2><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://blog.csdn.net/cwtnice/article/details/107025779">PAT 1130 Infix Expression</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://www.liuchuo.net/archives/3798">PAT 1130. Infix Expression (25)-甲级</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>数学</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前缀和</title>
    <link href="/2021/01/28/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    <url>/2021/01/28/%E5%89%8D%E7%BC%80%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><h2 id="前缀和概念"><a href="#前缀和概念" class="headerlink" title="前缀和概念"></a>前缀和概念</h2><p><strong>作用</strong></p><p>前缀和一般用于求$sum[i, j]$ 范围i,j之间的和。</p><p><strong>原理</strong></p><p>使用一个数组记录前n个的结果。比如</p><p>$P[i] = n[0] + n[1] + … + n[i-1]$</p><p>而$[i,j]$范围內的和等于</p><p>$$<br>sum[i,j] = P[j + 1] - P[i] \ =  n[j] + n[j - 1] + n[i] + n]i - 1] + … n[0] \ - n[i - 1] - n[i - 2] … n[0] \= n[j] + n[j - 1] + .. n[i]<br>$$</p><p>根据上面可以推断出前缀和算法模板为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> n; <span class="hljs-comment">// 元素个数</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nums;<br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">pre</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">// n 表示前 n-1个和，所以 n + 1 表示前n个数之和</span><br><br>pre[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 第一个数默认为0. [i,0] 之和 为 pre[i + 1]. 所以 i = 0时， sum[0] = pre[1]</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>pre[i + <span class="hljs-number">1</span>] = pre[i] + nums[i];<br>&#125;<br><br><span class="hljs-comment">// [i,j]之间的和</span><br>sum[i,j] = pre[j + <span class="hljs-number">1</span>] - pre[i];<br></code></pre></td></tr></table></figure><hr><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><p><a href="https://leetcode-cn.com/problems/find-pivot-index/">724. 寻找数组的中心索引</a></p><p>题目</p><blockquote><p>给定一个整数类型的数组 nums，请编写一个能够返回数组 “中心索引” 的方法。</p><p>我们是这样定义数组 中心索引 的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。</p><p>如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。</p></blockquote><p>示例</p><blockquote><p>输入：<br>nums = [1, 7, 3, 6, 5, 6]</p><p>输出：3</p><p>解释：<br>索引 3 (nums[3] = 6) 的左侧数之和 (1 + 7 + 3 = 11)，与右侧数之和 (5 + 6 = 11) 相等。<br>同时, 3 也是第一个符合要求的中心索引。</p></blockquote><p><strong>分析</strong></p><p>计算该数组的前缀和，假设当前元素索引为$i$,</p><p>则左侧和范围是</p><p>$0 \sim i - 1$,</p><p>左侧和为 $sum[0, i - 1] = pre[i]$,</p><p>右侧和范围是</p><p>$i + 1 \sim n - 1$,</p><p>则右侧和为</p><p>$sum[i + 1, n - 1] = pre[n] - pre[i + 1] = pre[n] - pre[i] - nums[i]$.</p><p>所以本题需要找到一个<code>i</code>，满足<code>pre[i] == pre[n] - pre[i] - nums[i]</code></p><p>代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pivotIndex</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.size();<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">pre</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            pre[i] = pre[i - <span class="hljs-number">1</span>] + nums[i - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (pre[i] == pre[n] - pre[i] - nums[i]) &#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>优化</strong></p><p>本题中，中心索引需要满足</p><p>$pre[i] == pre[n] - pre[i] - nums[i]$.</p><p>可以令$sum = pre[i], total = pre[n]$，那么上面方程则变成</p><p>$$<br>sum = total - sum - nums[i] \<br>2 * sum + nums[i] = total<br>$$</p><p>因此代码优化成一遍遍历即可找到结果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pivotIndex</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.size();<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">int</span> total = accumulate(nums.begin(), nums.end(), <span class="hljs-number">0</span>); <span class="hljs-comment">// 第三个是累加初始值，初始值为0</span><br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> * sum + nums[i] == total) &#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>            sum += nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>leetcode</tag>
      
      <tag>数组</tag>
      
      <tag>前缀和</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1135 Is It A Red-Black Tree</title>
    <link href="/2021/01/27/1135-Is-It-A-Red-Black-Tree/"/>
    <url>/2021/01/27/1135-Is-It-A-Red-Black-Tree/</url>
    
    <content type="html"><![CDATA[<h1 id="1135-Is-It-A-Red-Black-Tree-30分"><a href="#1135-Is-It-A-Red-Black-Tree-30分" class="headerlink" title="1135 Is It A Red-Black Tree (30分)"></a>1135 Is It A Red-Black Tree (30分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/o8nR6T.png" alt="o8nR6T"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>红黑树的几个条件</p><ul><li>结点要么是黑要么是红</li><li>根结点一定是黑</li><li>叶子结点是黑</li><li>结点是红，那么子结点一定是黑。==每条路径不存在连续的红颜色==</li><li>所有任一结点到叶子的路径，==黑结点的数量相同==。</li></ul><p>建立一个结点结构体</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>&#123;</span><br><span class="hljs-keyword">int</span> val;<br>TreeNode *left, *right;<br>&#125;<br></code></pre></td></tr></table></figure><p>建立二叉树，这里有两个方法，因为已知是二叉搜索树，所以可以直接使用<code>insert</code>或者排序得到中序遍历，通过前序和中序遍历建立二叉树。二者都可以，后者对于所有二叉树都适用，下面是两种算法的写法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 方法一：根据二叉搜索树的特性使用插入法，记住传入的是结点的地址</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(TreeNode* &amp;root, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) &#123;<br>        root = <span class="hljs-keyword">new</span> TreeNode;<br>        root-&gt;val = val;<br>        root-&gt;left = root-&gt;right = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(val) &lt; <span class="hljs-built_in">abs</span>(root-&gt;val)) &#123;<br>            insert(root-&gt;left, val);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            insert(root-&gt;right, val);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 方法二：适用于所有给出前序和中序遍历的二叉树</span><br><span class="hljs-function">TreeNode* <span class="hljs-title">create</span><span class="hljs-params">(<span class="hljs-keyword">int</span> preL, <span class="hljs-keyword">int</span> preR, <span class="hljs-keyword">int</span> inL, <span class="hljs-keyword">int</span> inR)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (preL &gt; preR) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    TreeNode* root = <span class="hljs-keyword">new</span> TreeNode;<br>    root-&gt;val = preorder[preL];<br>    <span class="hljs-keyword">int</span> mid = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (mid = inL; mid &lt;= inR; mid++) &#123; <span class="hljs-comment">// 在中序遍历中找到根结点</span><br>        <span class="hljs-keyword">if</span> (preorder[preL] == inorder[mid]) <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> num = mid - inL; <span class="hljs-comment">// 找到左边结点的数量</span><br>    root-&gt;left = create(preL + <span class="hljs-number">1</span>, preL + num, inL, mid - <span class="hljs-number">1</span>);<br>    root-&gt;right = create(preL + num + <span class="hljs-number">1</span>, preR, mid + <span class="hljs-number">1</span>, inR);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><p>红黑树判断参考<a href="https://blog.csdn.net/Scenlyf/article/details/51692551">【数据结构】红黑树（如何实现及怎样判断）</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">bool</span> _check(TreeNode* parent, TreeNode* root, <span class="hljs-keyword">int</span> blackNum, <span class="hljs-keyword">int</span> curBlackNum) &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (parent-&gt;val &lt; <span class="hljs-number">0</span> &amp;&amp; root-&gt;val &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 如果父结点和子结点都是红色,不满足</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (root-&gt;val &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 如果当前结点是黑色，则黑色++</span><br>        curBlackNum++;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (root-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">// 到达叶子结点，判断黑色数量是否相同</span><br>        <span class="hljs-keyword">if</span> (blackNum == curBlackNum) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> _check(root, root-&gt;left, blackNum, curBlackNum) &amp;&amp; _check(root, root-&gt;right, blackNum, curBlackNum);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root-&gt;val &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 如果根结点是红色，则不是红黑树</span><br>    <span class="hljs-keyword">int</span> blackNum = <span class="hljs-number">0</span>; <span class="hljs-comment">// 黑色结点数量</span><br>    <span class="hljs-keyword">int</span> num = <span class="hljs-number">1</span>; <span class="hljs-comment">// 路径中结点的数量，默认从根结点的子结点出发。所以当前根结点的黑色数量是1</span><br>    TreeNode* temp = root;<br>    <span class="hljs-keyword">while</span> (temp != <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">// 统计其中一条路径的黑色结点数量，然后和其他路径比较</span><br>        <span class="hljs-keyword">if</span> (temp-&gt;val &gt; <span class="hljs-number">0</span>) blackNum++;<br>        temp = temp-&gt;left;<br>    &#125;<br>    <span class="hljs-keyword">return</span> _check(root, root-&gt;left, blackNum, num) &amp;&amp; _check(root, root-&gt;right, blackNum, num);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><blockquote><p>2，3用例没有通过，得分21分</p></blockquote><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/vdGdQr.png" alt="vdGdQr"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>&#123;</span><br><span class="hljs-keyword">int</span> val;<br>TreeNode *left, *right;<br>&#125;;<br><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; preorder, inorder;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(a) &lt; <span class="hljs-built_in">abs</span>(b);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">getInorder</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; order)</span> </span>&#123;<br>    sort(order.begin(), order.end(), cmp); <span class="hljs-comment">// 注意是比较绝对值的大小</span><br>    <span class="hljs-keyword">return</span> order;<br>&#125;<br><br><span class="hljs-function">TreeNode* <span class="hljs-title">create</span><span class="hljs-params">(<span class="hljs-keyword">int</span> preL, <span class="hljs-keyword">int</span> preR, <span class="hljs-keyword">int</span> inL, <span class="hljs-keyword">int</span> inR)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (preL &gt; preR) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    TreeNode* root = <span class="hljs-keyword">new</span> TreeNode;<br>    root-&gt;val = preorder[preL];<br>    <span class="hljs-keyword">int</span> mid = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (mid = inL; mid &lt;= inR; mid++) &#123; <span class="hljs-comment">// 在中序遍历中找到根结点</span><br>        <span class="hljs-keyword">if</span> (preorder[preL] == inorder[mid]) <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> num = mid - inL; <span class="hljs-comment">// 找到左边结点的数量</span><br>    root-&gt;left = create(preL + <span class="hljs-number">1</span>, preL + num, inL, mid - <span class="hljs-number">1</span>);<br>    root-&gt;right = create(preL + num + <span class="hljs-number">1</span>, preR, mid + <span class="hljs-number">1</span>, inR);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, root-&gt;val);<br>    dfs(root-&gt;left);<br>    dfs(root-&gt;right);<br>&#125;<br><br><span class="hljs-keyword">bool</span> _check(TreeNode* parent, TreeNode* root, <span class="hljs-keyword">int</span> blackNum, <span class="hljs-keyword">int</span> curBlackNum) &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (parent-&gt;val &lt; <span class="hljs-number">0</span> &amp;&amp; root-&gt;val &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 如果父结点和子结点都是红色,不满足</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (root-&gt;val &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 如果当前结点是黑色，则黑色++</span><br>        curBlackNum++;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (root-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">// 到达叶子结点，判断黑色数量是否相同</span><br>        <span class="hljs-keyword">if</span> (blackNum == curBlackNum) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> _check(root, root-&gt;left, blackNum, curBlackNum) &amp;&amp; _check(root, root-&gt;right, blackNum, curBlackNum);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root-&gt;val &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 如果根结点是红色，则不是红黑树</span><br>    <span class="hljs-keyword">int</span> blackNum = <span class="hljs-number">0</span>; <span class="hljs-comment">// 黑色结点数量</span><br>    <span class="hljs-keyword">int</span> num = <span class="hljs-number">1</span>; <span class="hljs-comment">// 路径中结点的数量，默认从根结点的子结点出发。所以当前根结点的黑色数量是1</span><br>    TreeNode* temp = root;<br>    <span class="hljs-keyword">while</span> (temp != <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">// 统计其中一条路径的黑色结点数量，然后和其他路径比较</span><br>        <span class="hljs-keyword">if</span> (temp-&gt;val &gt; <span class="hljs-number">0</span>) blackNum++;<br>        temp = temp-&gt;left;<br>    &#125;<br>    <span class="hljs-keyword">return</span> _check(root, root-&gt;left, blackNum, num) &amp;&amp; _check(root, root-&gt;right, blackNum, num);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> k, n;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; k;<br>    <span class="hljs-keyword">while</span> (k--) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>        preorder.resize(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;preorder[i]);<br>        &#125;<br>        inorder = getInorder(preorder);<br>        TreeNode* root = create(<span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// dfs(root); // 打印出来看看,验证是否建立成功</span><br>        <span class="hljs-keyword">if</span> (check(root)) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Yes\n&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法二：改进黑结点计算方法</p><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/Xmt4Ti.png" alt="Xmt4Ti"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root-&gt;val &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 如果根结点是红色，则不是红黑树</span><br>    <span class="hljs-keyword">int</span> blackNum = <span class="hljs-number">1</span>; <span class="hljs-comment">// 黑色结点数量</span><br>    <span class="hljs-keyword">int</span> num = <span class="hljs-number">1</span>; <span class="hljs-comment">// 路径中结点的数量，默认从根结点的子结点出发。所以当前根结点的黑色数量是1</span><br>    TreeNode* temp = root;<br>    <span class="hljs-keyword">while</span> (temp-&gt;left != <span class="hljs-literal">NULL</span> || temp-&gt;right != <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">// 统计其中一条路径的黑色结点数量，然后和其他路径比较</span><br>        <span class="hljs-keyword">if</span> (temp-&gt;val &gt; <span class="hljs-number">0</span>) blackNum++; <span class="hljs-comment">// 这里的数量统计应该错了</span><br>        <span class="hljs-keyword">if</span> (temp-&gt;left != <span class="hljs-literal">NULL</span>) temp = temp-&gt;left;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (temp-&gt;right != <span class="hljs-literal">NULL</span>) temp = temp-&gt;right;<br>    &#125;<br>    <span class="hljs-keyword">return</span> _check(root, root-&gt;left, blackNum, num) &amp;&amp; _check(root, root-&gt;right, blackNum, num);<br>&#125;<br></code></pre></td></tr></table></figure><p>方法三：改进遍历黑色结点方法</p><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/pyd1uI.png" alt="pyd1uI"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++">TreeNode* temp = root;<br><span class="hljs-keyword">while</span> (temp != <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">// 统计其中一条路径的黑色结点数量，然后和其他路径比较</span><br><span class="hljs-keyword">if</span> (temp-&gt;val &gt; <span class="hljs-number">0</span>) blackNum++; <span class="hljs-comment">// 这里的数量统计应该错了</span><br><span class="hljs-keyword">if</span> (temp-&gt;left != <span class="hljs-literal">NULL</span>) temp = temp-&gt;left;<br><span class="hljs-keyword">else</span> temp = temp-&gt;right;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法三，改变建立树的方法</p><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/K0C1Ae.png" alt="K0C1Ae"></p><p>注意<code>insert</code>传入的<code>root</code>是地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(TreeNode* &amp;root, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) &#123;<br>        root = <span class="hljs-keyword">new</span> TreeNode;<br>        root-&gt;val = val;<br>        root-&gt;left = root-&gt;right = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(val) &lt; <span class="hljs-built_in">abs</span>(root-&gt;val)) &#123;<br>            insert(root-&gt;left, val);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            insert(root-&gt;right, val);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h2><blockquote><p>还是有两个用例没有通过,得分21分</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>&#123;</span><br><span class="hljs-keyword">int</span> val;<br>TreeNode *left, *right;<br>&#125;;<br><br><span class="hljs-keyword">bool</span> _check(TreeNode* parent, TreeNode* root, <span class="hljs-keyword">int</span> blackNum, <span class="hljs-keyword">int</span> curBlackNum) &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (parent-&gt;val &lt; <span class="hljs-number">0</span> &amp;&amp; root-&gt;val &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 如果父结点和子结点都是红色,不满足</span><br>        <span class="hljs-comment">// cout &lt;&lt; parent-&gt;val &lt;&lt; &quot; &quot; &lt;&lt; root-&gt;val &lt;&lt; endl;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (root-&gt;val &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 如果当前结点是黑色，则黑色++</span><br>        curBlackNum++;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (root-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">// 到达叶子结点，判断黑色数量是否相同</span><br>        <span class="hljs-comment">// cout &lt;&lt; blackNum &lt;&lt; &quot; &quot; &lt;&lt; curBlackNum &lt;&lt; endl;</span><br>        <span class="hljs-keyword">if</span> (blackNum == curBlackNum) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> _check(root, root-&gt;left, blackNum, curBlackNum) &amp;&amp; _check(root, root-&gt;right, blackNum, curBlackNum);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root-&gt;val &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 如果根结点是红色，则不是红黑树</span><br>    <span class="hljs-keyword">int</span> blackNum = <span class="hljs-number">0</span>; <span class="hljs-comment">// 黑色结点数量</span><br>    <span class="hljs-keyword">int</span> num = <span class="hljs-number">1</span>; <span class="hljs-comment">// 路径中结点的数量，默认从根结点的子结点出发。所以当前根结点的黑色数量是1</span><br>    TreeNode* temp = root;<br>    <span class="hljs-keyword">while</span> (temp != <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">// 统计其中一条路径的黑色结点数量，然后和其他路径比较</span><br>        <span class="hljs-keyword">if</span> (temp-&gt;val &gt; <span class="hljs-number">0</span>) blackNum++; <span class="hljs-comment">// 这里的数量统计应该错了</span><br>        <span class="hljs-keyword">if</span> (temp-&gt;left != <span class="hljs-literal">NULL</span>) temp = temp-&gt;left;<br>        <span class="hljs-keyword">else</span> temp = temp-&gt;right;<br>    &#125;<br>    <span class="hljs-keyword">return</span> _check(root, root-&gt;left, blackNum, num) &amp;&amp; _check(root, root-&gt;right, blackNum, num);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(TreeNode* &amp;root, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) &#123;<br>        root = <span class="hljs-keyword">new</span> TreeNode;<br>        root-&gt;val = val;<br>        root-&gt;left = root-&gt;right = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(val) &lt;= <span class="hljs-built_in">abs</span>(root-&gt;val)) &#123;<br>            insert(root-&gt;left, val);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            insert(root-&gt;right, val);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> k, n, val;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; k;<br>    <span class="hljs-keyword">while</span> (k--) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>        TreeNode* root = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; val;<br>            insert(root, val);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (check(root)) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Yes\n&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
      <tag>二叉搜索树</tag>
      
      <tag>红黑树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1134 Vertex Cover</title>
    <link href="/2021/01/27/1134-Vertex-Cover/"/>
    <url>/2021/01/27/1134-Vertex-Cover/</url>
    
    <content type="html"><![CDATA[<h1 id="1134-Vertex-Cover-25分"><a href="#1134-Vertex-Cover-25分" class="headerlink" title="1134 Vertex Cover (25分)"></a>1134 Vertex Cover (25分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/ZLQp2s.png" alt="ZLQp2s"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>题目意思</p><p><strong>vertex cover</strong>是一个顶点集合，并且图中的每条边都和顶点集中的至少一个顶点关联。</p><p>现在给出一个图，和几组顶点集合，判断这几组顶点集合是否是<strong>vertex cover</strong></p><p>思路</p><ol><li>使用一个<code>map&lt;pair&lt;int, int&gt;, bool&gt; edges</code>存储每组边，其中将顶点作为<code>key</code>。在初始化的时候，设置<code>edges[&#123;u,v&#125;] = false</code>，注意<code>u&lt;v</code>.</li><li>使用邻接表存储图.</li><li>对于给定的顶点集，设置一个<code>visited = edges</code>变量，判断是否每条边都被访问过，遍历邻接表，将每个个顶点能访问的边都设置为<code>visited[&#123;u, v&#125;] = true</code>.（注意需要满足<code>u&lt;v</code>）</li><li>最后判断是否所有边都被访问了，若都被访问了则证明是<strong>vertex cover</strong></li></ol><p>下图是题目示例中给定的邻接图</p><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/5Swo66.png" alt="5Swo66"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 题目要求一个点的集合，能够访问到所有的边</span><br><span class="hljs-comment">// 目前如何判断该边访问过。可是使用 pair来实现</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;utility&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">10001</span>;<br><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; G[MAX]; <span class="hljs-comment">// 邻接表</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, m, k, u, v, cnt;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;, <span class="hljs-keyword">bool</span>&gt; edges; <span class="hljs-comment">// 使用 unorder_map 无法使用</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; u &gt;&gt; v;<br>        <span class="hljs-keyword">if</span> (u &gt; v) swap(u, v); <span class="hljs-comment">// 小的在前面</span><br>        edges[<span class="hljs-built_in">make_pair</span>(u, v)] = <span class="hljs-literal">false</span>;<br>        G[u].push_back(v);<br>        G[v].push_back(u);<br>    &#125;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; k;<br>    <span class="hljs-keyword">while</span> (k--) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; cnt;<br>        <span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;, <span class="hljs-keyword">bool</span>&gt; visited = edges;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cnt; i++) &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; u;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v: G[u]) &#123;<br>                <span class="hljs-keyword">int</span> i = u, j = v;<br>                <span class="hljs-keyword">if</span> (i &gt; j) swap(i, j);<br>                visited[<span class="hljs-built_in">make_pair</span>(i, j)] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-comment">// cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl;</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; it: visited) &#123;<br>            <span class="hljs-comment">// cout &lt;&lt; it.second &lt;&lt; endl;</span><br>            <span class="hljs-keyword">if</span> (it.second == <span class="hljs-literal">false</span>) &#123;<br>                flag = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (flag) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Yes\n&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No\n&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>为什么不用<code>unordered_map</code>，而是用<code>map</code>?</p><ul><li><code>unordered_map</code>在这里不适用，因为<code>unordered_map</code>是哈希表，无法存储<code>pair</code>类型。</li></ul>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
      <tag>图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1133 Splitting A Linked List</title>
    <link href="/2021/01/27/1133-Splitting-A-Linked-List/"/>
    <url>/2021/01/27/1133-Splitting-A-Linked-List/</url>
    
    <content type="html"><![CDATA[<h1 id="1133-Splitting-A-Linked-List-25分"><a href="#1133-Splitting-A-Linked-List-25分" class="headerlink" title="1133 Splitting A Linked List (25分)"></a>1133 Splitting A Linked List (25分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/bTEawP.png" alt="bTEawP"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本题目不要想太复杂了</p><p>题目意思</p><p>给定一个链表和一个k。在不打乱相对链表顺序的情况下，满足下面三个条件。</p><ul><li>A: 小于0的结点按相对顺序排在前面。</li><li>B: 小于等于k大于等于0的结点按原来相对顺序排在A的后面</li><li>C: 大于k的结点排在B的后面。</li></ul><p>本题的链表需要使用数组存储，因此可以建立一个结点<code>vector&lt;Node&gt; ans</code>。分三次分别遍历原来的链表，依次将<code>node.val &lt; 0, node.val &gt;= 0 and node.val &lt;= k, node.avl &gt; k</code>添加到<code>ans</code>中。</p><p>相似题目<a href="https://leetcode-cn.com/problems/partition-list/">86. 分隔链表</a>，这道题目由于给出的是指针，因此可以直接设置两个链表，分别存储小于等于k的结点和大于k的结点，再将小于k的结点尾结点连接到大于k的首结点即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 先建立一个链表，使用树状结构</span><br><span class="hljs-comment">// 1. 负数按照原来顺序在前. 2.</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">100001</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>&#123;</span><br>    <span class="hljs-keyword">int</span> address, val, next = <span class="hljs-number">-1</span>;<br>&#125;node[MAX];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> begin, n, address, next, val, k;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;begin, &amp;n, &amp;k);<br>    <span class="hljs-keyword">while</span> (n--) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;address, &amp;val, &amp;next);<br>        node[address] = &#123;address, val, next&#125;;<br>    &#125;<br>    <span class="hljs-keyword">int</span> nn = <span class="hljs-number">-1</span>, prenn, ns = <span class="hljs-number">-1</span>, prens, nl = <span class="hljs-number">-1</span>, prenl;<br>    <span class="hljs-built_in">vector</span>&lt;Node&gt; ans;<br>    <span class="hljs-keyword">int</span> head = begin;<br>    <span class="hljs-keyword">while</span> (head != <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (node[head].val &lt; <span class="hljs-number">0</span>) &#123;ans.push_back(node[head]);&#125;<br>        head = node[head].next;<br>    &#125;<br>    head = begin;<br>    <span class="hljs-keyword">while</span> (head != <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (node[head].val &lt;= k &amp;&amp; node[head].val &gt;= <span class="hljs-number">0</span>) &#123; ans.push_back(node[head]);&#125;<br>        head = node[head].next;<br>    &#125;<br>    head = begin;<br>    <span class="hljs-keyword">while</span> (head != <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (node[head].val &gt; k) &#123; ans.push_back(node[head]);&#125;<br>        head = node[head].next;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ans.size(); i++) &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; ans.size() - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d %d %05d\n&quot;</span>, ans[i].address, ans[i].val, ans[i + <span class="hljs-number">1</span>].address);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d %d -1\n&quot;</span>, ans[i].address, ans[i].val);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1132 Cut Integer</title>
    <link href="/2021/01/27/1132-Cut-Integer/"/>
    <url>/2021/01/27/1132-Cut-Integer/</url>
    
    <content type="html"><![CDATA[<h1 id="1132-Cut-Integer-20分"><a href="#1132-Cut-Integer-20分" class="headerlink" title="1132 Cut Integer (20分)"></a>1132 Cut Integer (20分)</h1><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/ycx7UH.png" alt="ycx7UH"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>题目意思</p><p>本题将一个数组分成两段，题目已保证它的该数字的位数是偶数位，然后判断是否可是被分成两端的数组乘积整除。</p><p>思路</p><p>一开始使用char字符数组来实现，但是转化成数字这些步骤比较繁琐。可以直接使用<code>string, stoi()</code>等实现数组分割，字符串转数字。这样代码会简洁很多。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 分析: 数字使用字符数组进行输入，然后分别分割成 Z, A, B。 若Z是奇数，则直接输入NO</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">string</span> s;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">while</span> (n--) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; s;<br>        <span class="hljs-keyword">int</span> size = s.size();<br>        <span class="hljs-keyword">int</span> Z =  stoi(s);<br>        <span class="hljs-keyword">int</span> A = stoi(s.substr(<span class="hljs-number">0</span>, size / <span class="hljs-number">2</span>));<br>        <span class="hljs-keyword">int</span> B = stoi(s.substr(size / <span class="hljs-number">2</span>));<br>        <span class="hljs-keyword">if</span> ((A * B != <span class="hljs-number">0</span>) &amp;&amp; (Z % (A * B) == <span class="hljs-number">0</span>)) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Yes\n&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No\n&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>段错误</li></ul><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/Jk7X8h.png" alt="Jk7X8h"></p><p>段错误可能是分母为0，所以需要注意分母为0的情况。</p><ul><li>** It is guaranteed that the number of digits of Z is an even number.** 经常会出现这种** It is guaranteed that xxxx**</li></ul><p>这句话的意思是题目本身输入的数据就保存有效性，所以对于这句话中的条件不需要去判断。</p>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1579. 保证图可完全遍历</title>
    <link href="/2021/01/27/1579-%E4%BF%9D%E8%AF%81%E5%9B%BE%E5%8F%AF%E5%AE%8C%E5%85%A8%E9%81%8D%E5%8E%86/"/>
    <url>/2021/01/27/1579-%E4%BF%9D%E8%AF%81%E5%9B%BE%E5%8F%AF%E5%AE%8C%E5%85%A8%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1579-保证图可完全遍历"><a href="#1579-保证图可完全遍历" class="headerlink" title="1579. 保证图可完全遍历"></a><a href="https://leetcode-cn.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/">1579. 保证图可完全遍历</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/Xesr5M.png" alt="Xesr5M"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>参考<a href="https://leetcode-cn.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/solution/python-dong-hua-xian-kan-alicezai-kan-bo-kavo/">[Python] [动画] 先看Alice再看Bob</a></p><p>步骤</p><ol><li>分别设置两个图，在设置一个变量<code>ans</code>存储无效边（被删除边）</li><li>先连接他们公共边，若改边已经存在，证明它是无效边，可以删除。同时<code>ans++</code></li><li>在分别连接各自的边，若边存在，则是无效边，进行<code>ans++</code>，若不存在，则进行合并。并计算连通分量</li><li>最后输出结果的时候，需要判断连通分量是否大于1，若大于1，证明无法遍历所有的点，输出<code>-1</code>，否则输出<code>ans</code>。</li></ol><p>注意</p><ul><li>这里顶点的编号是<code>1-n</code>,因此在初始化并查集的时候，parent的大小是<code>n+1</code>,不要忘记最后输出连通分量的时候记得<code>-1</code>，把<code>0</code>这个分量删除。</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span> &#123;</span><br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; parent;<br>    <span class="hljs-keyword">int</span> countCon;<br>    <span class="hljs-keyword">public</span>:<br>    UnionFind(<span class="hljs-keyword">int</span> n) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) parent.push_back(i);<br>        countCon = n;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n != parent[n]) parent[n] = find(parent[n]);<br>        <span class="hljs-keyword">return</span> parent[n];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> uRoot = find(u), vRoot = find(v);<br>        <span class="hljs-keyword">if</span> (uRoot == vRoot) <span class="hljs-keyword">return</span>;<br>        parent[uRoot] = vRoot;<br>        countCon--;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> countCon;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">connection</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> find(u) == find(v);<br>    &#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxNumEdgesToRemove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        UnionFind ufBob(n + 1), ufAlice(n + 1); // n的范围1-n<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; e: edges) &#123;<br>            <span class="hljs-keyword">if</span> (e[<span class="hljs-number">0</span>] == <span class="hljs-number">3</span>) &#123;<br>                <span class="hljs-keyword">if</span> (!ufBob.connection(e[<span class="hljs-number">1</span>], e[<span class="hljs-number">2</span>])) &#123;<br>                    ufBob.merge(e[<span class="hljs-number">1</span>], e[<span class="hljs-number">2</span>]);<br>                    ufAlice.merge(e[<span class="hljs-number">1</span>], e[<span class="hljs-number">2</span>]);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    ans++; <span class="hljs-comment">// 已经连接，则证明这条边是没有用的</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; e: edges) &#123;<br>            <span class="hljs-keyword">if</span> (e[<span class="hljs-number">0</span>] == <span class="hljs-number">2</span>) &#123;<br>                <span class="hljs-keyword">if</span> (!ufBob.connection(e[<span class="hljs-number">1</span>], e[<span class="hljs-number">2</span>])) &#123;<br>                    ufBob.merge(e[<span class="hljs-number">1</span>], e[<span class="hljs-number">2</span>]);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    ans++; <span class="hljs-comment">// 已经连接，则证明这条边是没有用的</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; e: edges) &#123;<br>            <span class="hljs-keyword">if</span> (e[<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">if</span> (!ufAlice.connection(e[<span class="hljs-number">1</span>], e[<span class="hljs-number">2</span>])) &#123;<br>                    ufAlice.merge(e[<span class="hljs-number">1</span>], e[<span class="hljs-number">2</span>]);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    ans++; <span class="hljs-comment">// 已经连接，则证明这条边是没有用的</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 最后判断是否存在多个连通分量，若存在证明无法形成一个完全遍历的图</span><br>        <span class="hljs-keyword">return</span> (ufBob.getCount() - <span class="hljs-number">1</span>) * (ufAlice.getCount() - <span class="hljs-number">1</span>) &gt; <span class="hljs-number">1</span> ? <span class="hljs-number">-1</span> : ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>union-find</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1139 First Contact</title>
    <link href="/2021/01/26/1139-First-Contact/"/>
    <url>/2021/01/26/1139-First-Contact/</url>
    
    <content type="html"><![CDATA[<h1 id="1139-First-Contact-30分"><a href="#1139-First-Contact-30分" class="headerlink" title="1139 First Contact (30分)"></a>1139 First Contact (30分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/fHCX2m.png" alt="fHCX2m"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题题目较难理解，主要参考<a href="https://blog.csdn.net/richenyunqi/article/details/79595547">pat甲级1139. First Contact (30)</a>写法。以下内容摘抄自该链接。</p><p>题意分析<br>可以把整个题目描述表示成一个图，每个人都是其中一个结点，两个人如果是朋友则在两个人之间有一条边。题目要求的就是给定一个起始结点，一个末尾结点，能不能找到两个结点，使得从起始结点出发经过这两个结点之后到达末尾结点。当然，题目要求比这个稍微复杂，每个节点有男、女两种性别，而且要求经过的两个节点中，第一个节点的性别和起始结点一致，第二个结点的性别和末尾结点一致。</p><p>算法设计<br>由于最后要先按第一个结点从小到大排序，再按第二个节点从小到大排序，可以直接使用c++标准库中的pair类型保存这两个节点，因为pair类型自定义的&lt;运算符恰好就是先按第一个元素从小到大排序，再按第二个元素从小到大排序。由于只要求首尾结点之间有两个结点，且结点总数最多才300个，可以直接采取暴力搜索的方法，在搜索过程中，注意保证第一个节点和首结点性别相同，第二个节点和末尾结点性别相同，此外要避免过早达到头结点或返回首节点的情况出现。具体实现可见代码，非常简洁易懂哦~~</p><p>注意点<br>（1）有一个大坑，题目按给定的4位数字前有无‘-’号作为区别男女的标志，有一个测试点包含了-0000这样的数据，如果用int读入，是不会认为它是一个负数的，于是程序自然把其代表的人视作了女性，导致了错误。所以为了保证正确，最好用char数组或者string读入，以确保前面的’-‘ 号不会丢失。</p><p>（2）输出结点值时要按”%04d”的形式输出，以保证输出数字有4位，不足在高位补0</p><p>（3）形成的图为无向图，边为无向边</p><p>（4）搜索过程中避免过早达到头结点或返回首节点的情况出现，即保证搜索的两个结点既不等于首节点，也不等于尾结点</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-number">1001</span> <span class="hljs-number">-2001</span><br><span class="hljs-number">-2003</span> <span class="hljs-number">1001</span> <span class="hljs-comment">// AB异性，先找</span><br><span class="hljs-number">1005</span> <span class="hljs-number">-2001</span> <span class="hljs-comment">// 没有男性朋友可以帮助他们，只有一个女性朋友，所以也是0</span><br><span class="hljs-number">-2002</span> <span class="hljs-number">-2004</span> <span class="hljs-comment">// AB同性，同性朋友只有-2002</span><br><span class="hljs-number">1111</span> <span class="hljs-number">-2003</span> <span class="hljs-comment">// 没有1111这个人，所以输出0</span><br></code></pre></td></tr></table></figure><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;utility&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">10001</span>;<br><span class="hljs-keyword">bool</span> gender[MAX]; <span class="hljs-comment">// 判断是什么性别，ture代表男性，false代表女性</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; friends[MAX]; <span class="hljs-comment">// 邻接表，存储所有对象的关系</span><br><span class="hljs-keyword">int</span> n, m, k;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">string</span> s1, s2;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d\n&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123; <span class="hljs-comment">// 输入m个关系</span><br>        <span class="hljs-built_in">cin</span> &gt;&gt; s1 &gt;&gt; s2;<br>        friends[<span class="hljs-built_in">abs</span>(stoi(s1))].push_back(<span class="hljs-built_in">abs</span>(stoi(s2))); <span class="hljs-comment">// 将朋友添加到邻接表中</span><br>        friends[<span class="hljs-built_in">abs</span>(stoi(s2))].push_back(<span class="hljs-built_in">abs</span>(stoi(s1)));<br>        gender[<span class="hljs-built_in">abs</span>(stoi(s1))] = s1[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;-&#x27;</span>; <span class="hljs-comment">// 判断s1,s2的性别</span><br>        gender[<span class="hljs-built_in">abs</span>(stoi(s2))] = s2[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;-&#x27;</span>;<br>    &#125;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;k);<br>    <span class="hljs-keyword">while</span> (k--) &#123;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt; ans;<br>        <span class="hljs-keyword">int</span> start, end;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;start, &amp;end);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> f: friends[<span class="hljs-built_in">abs</span>(start)]) &#123; <span class="hljs-comment">// 先从最开始的朋友开始找</span><br>            <span class="hljs-keyword">if</span> (f != <span class="hljs-built_in">abs</span>(start) &amp;&amp; f != <span class="hljs-built_in">abs</span>(end) &amp;&amp;<br>               gender[<span class="hljs-built_in">abs</span>(f)] == gender[<span class="hljs-built_in">abs</span>(start)]) &#123;<br>                <span class="hljs-comment">// 重要:找到和start性别相同的朋友，然后再从f这个朋友继续寻找和end性别相同的朋友</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> f2: friends[f]) &#123;<br>                    <span class="hljs-keyword">if</span> (f2 != <span class="hljs-built_in">abs</span>(start) &amp;&amp; f2 != <span class="hljs-built_in">abs</span>(end) &amp;&amp; gender[f2] == gender[<span class="hljs-built_in">abs</span>(end)]) &#123;<br>                        <span class="hljs-comment">// 重要:找到了性别和end相同的朋友，再判断该f2朋友能否到达end</span><br>                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> f3: friends[f2]) &#123;<br>                            <span class="hljs-keyword">if</span> (f3 == <span class="hljs-built_in">abs</span>(end)) &#123;<br>                                ans.push_back(&#123;f, f2&#125;);<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans.size());<br>        sort(ans.begin(), ans.end());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; it: ans)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%04d %04d\n&quot;</span>, it.first, it.second);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
      <tag>图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1138 Postorder Traversal</title>
    <link href="/2021/01/26/1138-Postorder-Traversal/"/>
    <url>/2021/01/26/1138-Postorder-Traversal/</url>
    
    <content type="html"><![CDATA[<h1 id="1138-Postorder-Traversal-25分"><a href="#1138-Postorder-Traversal-25分" class="headerlink" title="1138 Postorder Traversal (25分)"></a>1138 Postorder Traversal (25分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/42Tetc.png" alt="42Tetc"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本题是<strong>前序和中序构建二叉树</strong>和<strong>二叉树后序遍历</strong>结合。</p><ul><li><strong>前序和中序遍历二叉树</strong>可以参考<a href="https://emhui.fun/2021/01/14/1086-Tree-Traversals-Again/">1086 Tree Traversals Again</a>, <a href="https://emhui.fun/2021/01/14/1020-Tree-Traversals/">1020 Tree Traversals</a></li><li><strong>二叉树后序遍历</strong>。由于本题只需要求后续遍历第一个结点。先访问根结点的最左边结点，若不存在最左边结点，则访问最右边结点，再访问右边结点的左结点，直到找到叶子结点。该结点为后续遍历第一个结点。实现代码如下。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">while</span> (root-&gt;left != <span class="hljs-literal">NULL</span> || root-&gt;right != <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-keyword">if</span> (root-&gt;left != <span class="hljs-literal">NULL</span>) &#123;<br>root = root-&gt;left;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root-&gt;right != <span class="hljs-literal">NULL</span>)&#123;<br>root = root-&gt;right;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span> &#123;</span><br>    <span class="hljs-keyword">int</span> val;<br>    TreeNode *left, *right;<br>&#125;;<br><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; preorder, inorder;<br><span class="hljs-keyword">int</span> n;<br><br><span class="hljs-function">TreeNode* <span class="hljs-title">create</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pl, <span class="hljs-keyword">int</span> pr, <span class="hljs-keyword">int</span> il, <span class="hljs-keyword">int</span> ir)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (pl &gt; pr) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    TreeNode* root = <span class="hljs-keyword">new</span> TreeNode;<br>    root-&gt;val = preorder[pl];<br>    <span class="hljs-keyword">int</span> mid = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (mid = il; mid &lt;= ir; mid++) &#123;<br>        <span class="hljs-keyword">if</span> (preorder[pl] == inorder[mid]) <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> left = mid - il;<br>    root-&gt;left = create(pl + <span class="hljs-number">1</span>, pl + left, il, mid - <span class="hljs-number">1</span>);<br>    root-&gt;right = create(pl + left + <span class="hljs-number">1</span>, pr, mid + <span class="hljs-number">1</span>, ir);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    preorder.resize(n), inorder.resize(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;preorder[i]);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;inorder[i]);<br>    &#125;<br>    TreeNode* root = create(<span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 找到最左边的结点</span><br>    <span class="hljs-keyword">while</span> (root-&gt;left != <span class="hljs-literal">NULL</span> || root-&gt;right != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">if</span> (root-&gt;left != <span class="hljs-literal">NULL</span>) &#123;<br>            root = root-&gt;left;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root-&gt;right != <span class="hljs-literal">NULL</span>)&#123;<br>            root = root-&gt;right;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, root-&gt;val);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法二，更换了找到根结点的方法，刚刚那个方法的确有问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span> &#123;</span><br>    <span class="hljs-keyword">int</span> val;<br>    TreeNode *left, *right;<br>&#125;;<br><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; preorder, inorder;<br><span class="hljs-keyword">int</span> n;<br><br><span class="hljs-function">TreeNode* <span class="hljs-title">create</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pl, <span class="hljs-keyword">int</span> pr, <span class="hljs-keyword">int</span> il, <span class="hljs-keyword">int</span> ir)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (pl &gt; pr) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    TreeNode* root = <span class="hljs-keyword">new</span> TreeNode;<br>    root-&gt;val = preorder[pl];<br>    <span class="hljs-keyword">int</span> mid = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (mid = il; mid &lt;= ir; mid++) &#123;<br>        <span class="hljs-keyword">if</span> (preorder[pl] == inorder[mid]) <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> left = mid - il;<br>    root-&gt;left = create(pl + <span class="hljs-number">1</span>, pl + left, il, mid - <span class="hljs-number">1</span>);<br>    root-&gt;right = create(pl + left + <span class="hljs-number">1</span>, pr, mid + <span class="hljs-number">1</span>, ir);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">posttravel</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    posttravel(root-&gt;left);<br>    posttravel(root-&gt;right);<br>    <span class="hljs-keyword">if</span> (num++ == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, root-&gt;val);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    preorder.resize(n), inorder.resize(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;preorder[i]);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;inorder[i]);<br>    &#125;<br>    TreeNode* root = create(<span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//while (root-&gt;left != NULL) &#123;root = root-&gt;left;&#125;</span><br>    <span class="hljs-comment">//while (root-&gt;right != NULL) &#123;root = root-&gt;right;&#125;</span><br>    <span class="hljs-comment">//printf(&quot;%d\n&quot;, root-&gt;val);</span><br>    posttravel(root);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>方法一进行改进</p><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/MjiCMq.png" alt="MjiCMq"></p><p>方法一进行改进</p><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/MAtlF8.png" alt="MAtlF8"></p><p>使用方法二可以通过</p><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/Mdqjxt.png" alt="Mdqjxt"></p>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
      <tag>后序遍历</tag>
      
      <tag>中序遍历</tag>
      
      <tag>二叉树</tag>
      
      <tag>前序遍历</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1137 Final Grading</title>
    <link href="/2021/01/26/1137-Final-Grading/"/>
    <url>/2021/01/26/1137-Final-Grading/</url>
    
    <content type="html"><![CDATA[<h1 id="1137-Final-Grading-25分"><a href="#1137-Final-Grading-25分" class="headerlink" title="1137 Final Grading (25分)"></a>1137 Final Grading (25分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/h30Mfq.png" alt="h30Mfq"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目要求：给上数据结构这门课的同学发合格整数。其中合格证书需要满足，在线课程完成<strong>大于等于200个任务点</strong>并且<strong>最后成绩G在60到100之间</strong>。</p><p>本题是一个<strong>构造结构体</strong>和<strong>数组排序</strong>相结合的题目。但是需要注意过滤无效的数据。</p><p>具体步骤</p><ol><li>构建一个结构体，该结构如下</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span>&#123;</span><br>    <span class="hljs-built_in">string</span> studentID;<br>    <span class="hljs-keyword">int</span> Gp, Gm = <span class="hljs-number">-1</span>, Gf = <span class="hljs-number">-1</span>, G;<br>&#125;stu[MAX];<br></code></pre></td></tr></table></figure><ol start="2"><li>使用<code>map</code>建立一个<strong>姓名-uid</strong>的映射</li><li>统计<code>Gp &gt;= 200</code>的学生的<code>Gp, Gm, Gf</code>成绩，然后计算出<code>G</code>这个成绩。</li><li>最后按照下面排序函数，对G和姓名进行排序,然后输出<code>G &gt;= 60</code>的学生。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Student a, Student b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (a.G != b.G) <span class="hljs-keyword">return</span> a.G &gt; b.G;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> a.studentID &lt; b.studentID;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，题目中写了，考试点通过200以上的才记录。</p><ol><li>建立姓名id的映射</li><li>结构体</li></ol><p>注意</p><ol><li>题目中要求的输出<strong>G成绩在60-100之间</strong>。这里的<strong>G</strong>不是<strong>Gf</strong>。即<code>Gp &gt;= 200, G &gt;&gt; 60 and G &lt;= 100</code>。</li><li>过滤<strong>Gp &lt; 200</strong>的学生。</li><li>在<code>Gm, Gf</code>输入的过程中，部分学生是不存<code>Gp</code>成绩，所以这部分学生也要进行过滤。</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">10001</span>;<br><span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt; studentID2Uid;<br><span class="hljs-keyword">int</span> vaildNum = <span class="hljs-number">0</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span>&#123;</span><br>    <span class="hljs-built_in">string</span> studentID;<br>    <span class="hljs-keyword">int</span> Gp, Gm = <span class="hljs-number">-1</span>, Gf = <span class="hljs-number">-1</span>, G;<br>&#125;stu[MAX];<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Student a, Student b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (a.G != b.G) <span class="hljs-keyword">return</span> a.G &gt; b.G;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> a.studentID &lt; b.studentID;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getUid</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (studentID2Uid.find(s) == studentID2Uid.end()) &#123;<br>        studentID2Uid[s] = vaildNum;<br>        <span class="hljs-keyword">return</span> vaildNum++;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> studentID2Uid[s];<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> p, m, n, val;<br>    <span class="hljs-built_in">string</span> s;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;p, &amp;m, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; p; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; s &gt;&gt; val;<br>        <span class="hljs-keyword">if</span> (val &gt;= <span class="hljs-number">200</span>) &#123;<br>            <span class="hljs-keyword">int</span> uid = getUid(s);<br>            stu[uid].Gp = val;<br>            stu[uid].studentID = s;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; s &gt;&gt; val;<br>        <span class="hljs-keyword">if</span> (studentID2Uid.find(s) == studentID2Uid.end()) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">int</span> uid = getUid(s);<br>        stu[uid].Gm = val;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; s &gt;&gt; val;<br>        <span class="hljs-keyword">if</span> (studentID2Uid.find(s) == studentID2Uid.end()) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">int</span> uid = getUid(s);<br>        stu[uid].Gf = val;<br>    &#125;<br>    <span class="hljs-comment">// 处理G</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; vaildNum; i++)&#123;<br>        <span class="hljs-keyword">if</span> (stu[i].Gm &gt; stu[i].Gf) &#123;<br>            stu[i].G = round(stu[i].Gm * <span class="hljs-number">0.4</span> + stu[i].Gf * <span class="hljs-number">0.6</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            stu[i].G = stu[i].Gf;<br>        &#125;<br>    &#125;<br>    sort(stu, stu + vaildNum, cmp);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; vaildNum; i++) &#123;<br>        <span class="hljs-keyword">if</span> (stu[i].G &gt;= <span class="hljs-number">60</span>)<br>        <span class="hljs-built_in">cout</span> &lt;&lt; stu[i].studentID &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; stu[i].Gp &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; stu[i].Gm &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; stu[i].Gf &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; stu[i].G &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1141 PAT Ranking of Institutions</title>
    <link href="/2021/01/25/1141-PAT-Ranking-of-Institutions/"/>
    <url>/2021/01/25/1141-PAT-Ranking-of-Institutions/</url>
    
    <content type="html"><![CDATA[<h1 id="1141-PAT-Ranking-of-Institutions-25分"><a href="#1141-PAT-Ranking-of-Institutions-25分" class="headerlink" title="1141 PAT Ranking of Institutions (25分)"></a>1141 PAT Ranking of Institutions (25分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/CdtzyK.png" alt="CdtzyK"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><del>题目意思，可以使用<code>map&lt;strint,Node&gt;</code>来实现</del></p><ol><li>使用一个<code>map</code>建立<code>school -&gt; int</code>的映射。</li><li>然后使用结构体存储数据，然后建立一个这样的数组</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>&#123;</span><br><span class="hljs-keyword">int</span> scoreA, scoreB, scoreC, ns, tws, rank; <span class="hljs-comment">// ns是该学校有多少人。每次遍历到该学校就进行ns++。tws取整, schoolID 等会输出的时候进行比较</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>根据题目要求，求完TWS，最后就是常规的排序函数了。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Node a, Node b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (a.tws != b.tws) &#123;<br>        <span class="hljs-keyword">return</span> a.tws &gt; b.tws;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a.ns != b.ns) &#123;<br>        <span class="hljs-keyword">return</span> a.ns &lt; b.ns;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> a.schoolName &lt; b.schoolName;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">100001</span>;<br><br><span class="hljs-keyword">int</span> numInstitutions = <span class="hljs-number">0</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>&#123;</span><br>    <span class="hljs-keyword">int</span> scoreA, scoreB, scoreT, ns, tws, rank;<br>    <span class="hljs-built_in">string</span> schoolName;<br>&#125;schools[MAX];<br><br><span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt; str2int;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getIntID</span><span class="hljs-params">(<span class="hljs-built_in">string</span> schoolName)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (str2int.find(schoolName) == str2int.end()) &#123;<span class="hljs-comment">// 如果没有该元素</span><br>            str2int[schoolName] = numInstitutions;<br>            <span class="hljs-keyword">return</span> numInstitutions++;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> str2int[schoolName];<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Node a, Node b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (a.tws != b.tws) &#123;<br>        <span class="hljs-keyword">return</span> a.tws &gt; b.tws;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a.ns != b.ns) &#123;<br>        <span class="hljs-keyword">return</span> a.ns &lt; b.ns;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> a.schoolName &lt; b.schoolName;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, score;<br>    <span class="hljs-built_in">string</span> ID, schoolName;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; ID &gt;&gt; score &gt;&gt; schoolName;<br>        transform(schoolName.begin(),schoolName.end(),schoolName.begin(),::<span class="hljs-built_in">tolower</span>);<br>        <span class="hljs-keyword">int</span> uid = getIntID(schoolName);<br>        schools[uid].schoolName = schoolName;<br>        schools[uid].ns++;<br>        <span class="hljs-keyword">if</span> (ID[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;A&#x27;</span>) schools[uid].scoreA += score;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ID[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;B&#x27;</span>) schools[uid].scoreB += score;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ID[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;T&#x27;</span>) schools[uid].scoreT += score;<br>    &#125;<br>    <span class="hljs-comment">// 处理tws</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numInstitutions; i++) &#123;<br>        schools[i].tws = (<span class="hljs-keyword">int</span>)(schools[i].scoreA + schools[i].scoreB * <span class="hljs-number">1.0</span> / <span class="hljs-number">1.5</span> + schools[i].scoreT * <span class="hljs-number">1.5</span>);<br>    &#125;<br>    <br>    sort(schools, schools + numInstitutions, cmp);<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, numInstitutions);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numInstitutions; i++) &#123;<br>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; schools[i].tws == schools[i - <span class="hljs-number">1</span>].tws) &#123;<br>            schools[i].rank = schools[i - <span class="hljs-number">1</span>].rank;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            schools[i].rank = i + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; schools[i].rank &lt;&lt; <span class="hljs-string">&quot; &quot;</span>&lt;&lt; schools[i].schoolName &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; schools[i].tws &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; schools[i].ns &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1136 A Delayed Palindrome (20分)</title>
    <link href="/2021/01/25/1136-A-Delayed-Palindrome-20%E5%88%86/"/>
    <url>/2021/01/25/1136-A-Delayed-Palindrome-20%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1136-A-Delayed-Palindrome-20分"><a href="#1136-A-Delayed-Palindrome-20分" class="headerlink" title="1136 A Delayed Palindrome (20分)"></a>1136 A Delayed Palindrome (20分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/1vFF7v.png" alt="1vFF7v"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题主要考察的是<strong>较大的数组相加</strong>和<strong>判断是否是回文字符串</strong></p><ul><li><strong>判断较大数组相加</strong>：可以使用字符数组或者字符串来实现，使用字符数组的话，有一个缺点，数组从左到右，分别是低位到高位。在输出结果的时候，可能需要反过来输入。而字符串只需要在前面加上进位。例如进位1<code>s = &quot;1&quot; + s;</code></li><li><strong>判断回文字符串</strong>：可以使用双指针判断或者使用<code>reverse</code>来判断。</li></ul><p>下面代码中，方法一是使用字符数组的方法，写得比较乱，且3个有用例没有通过，最终得分16分。</p><p>方法二是参考<a href="https://www.liuchuo.net/archives/4204">PAT 1136. A Delayed Palindrome (20)-PAT甲级真题</a>。使用<code>string, reverse</code>方法。比较好理解。</p><p>注意：</p><ul><li>看到方法二的代码，发现输入的字符串一开始就需要进行回文判断。</li><li>使用<code>rev</code>方法返回一个新的字符串，而不更改原来的字符串。方法一中因为<code>char</code>限制，所以只能不断的来回赋值。结果变得很乱，所以推荐方法二。</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>方法一</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">10100</span>;<br><span class="hljs-keyword">char</span> A[MAX], B[MAX], C[MAX], T[MAX];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">computeC</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = <span class="hljs-built_in">strlen</span>(A);<br>    <span class="hljs-keyword">int</span> remain = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">int</span> s = (A[i] - <span class="hljs-string">&#x27;0&#x27;</span>) + (B[i] - <span class="hljs-string">&#x27;0&#x27;</span>) + remain; <span class="hljs-comment">// 转成数字计算</span><br>        C[i] = s % <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;0&#x27;</span>; <span class="hljs-comment">// 转成字符</span><br>        remain = s / <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (remain &gt; <span class="hljs-number">0</span>) C[n++] = remain + <span class="hljs-string">&#x27;0&#x27;</span>;<br>    C[n] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = <span class="hljs-built_in">strlen</span>(C);<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = n - <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 2 5 5 5 5 2</span><br>    <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; C[i] == C[j]) &#123;<br>        i++;<br>        j--;<br>    &#125;<br>    <span class="hljs-keyword">return</span> C[i] == C[j] ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">copyReverse</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* origin, <span class="hljs-keyword">char</span>* target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = <span class="hljs-built_in">strlen</span>(origin);<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = n - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= j) &#123;<br>        target[i] = origin[j];<br>        target[j] = origin[i];<br>        i++, j--;<br>    &#125;<br>    target[n] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, A);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++) &#123;<br>        copyReverse(A, B);<br>        computeC();<br>        copyReverse(C, T);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s + %s = %s\n&quot;</span>, A, B, T);<br>        <span class="hljs-keyword">if</span> (isPalindrome()) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s is a palindromic number.\n&quot;</span>,  T);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            copyReverse(C, A);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Not found in 10 iterations.\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法二</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">rev</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123; <span class="hljs-comment">// 返回一个新的string对象</span><br>    reverse(s.begin(), s.end());<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s1, <span class="hljs-built_in">string</span> s2)</span> </span>&#123;<br>    <span class="hljs-built_in">string</span> s = s1;<br>    <span class="hljs-keyword">int</span> remain = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = s1.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">int</span> num = (s1[i] - <span class="hljs-string">&#x27;0&#x27;</span>) + (s2[i] - <span class="hljs-string">&#x27;0&#x27;</span>) + remain;<br>        s[i] = num % <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;0&#x27;</span>;<br>        remain = num / <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (remain &gt; <span class="hljs-number">0</span>) s = <span class="hljs-string">&quot;1&quot;</span> + s;<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">string</span> s, sum;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; s;<br>    <span class="hljs-keyword">if</span> (s == rev(s)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s is a palindromic number.\n&quot;</span>, s.c_str());<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> n = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">while</span> (n--) &#123;<br>        sum = add(s, rev(s));<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s + %s = %s\n&quot;</span>, s.c_str(), rev(s).c_str(), sum.c_str());<br>        <span class="hljs-keyword">if</span> (sum == rev(sum)) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s is a palindromic number.\n&quot;</span>, sum.c_str());<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        s = sum;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Not found in 10 iterations.\n&quot;</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树的最近公共祖先</title>
    <link href="/2021/01/25/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <url>/2021/01/25/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    
    <content type="html"><![CDATA[<h1 id="最近公共祖先"><a href="#最近公共祖先" class="headerlink" title="最近公共祖先"></a>最近公共祖先</h1><blockquote><p>本文章记录两个模板，具体题目可以参考最后的相关题目</p></blockquote><p>该题目主要有两种类型</p><ul><li>普通的二叉树最近公共祖先</li><li>二叉搜索树的最近公共祖先</li></ul><h2 id="普通二叉树的最近公共祖先"><a href="#普通二叉树的最近公共祖先" class="headerlink" title="普通二叉树的最近公共祖先"></a>普通二叉树的最近公共祖先</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">if</span> (root == p || root == q) <span class="hljs-keyword">return</span> root;<br>        TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q);<br>        TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q);<br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> right;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> left;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a>二叉搜索树的最近公共祖先</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-comment">// u,v at root&#x27;s right</span><br>        <span class="hljs-keyword">if</span> (root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val) &#123;<br>            <span class="hljs-keyword">return</span> lowestCommonAncestor(root-&gt;right, p, q);<br>        &#125;<br>        <span class="hljs-comment">// u,v at root&#x27;s left</span><br>        <span class="hljs-keyword">if</span> (root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val) &#123;<br>            <span class="hljs-keyword">return</span> lowestCommonAncestor(root-&gt;left, p, q);<br>        &#125;<br>        <span class="hljs-keyword">return</span> root; <span class="hljs-comment">// u, v on both sides of root</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><ul><li><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先</a></li><li><a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/">剑指 Offer 68 - II. 二叉树的最近公共祖先</a></li><li><a href="https://emhui.fun/2021/01/24/1143-Lowest-Common-Ancestor/">1143 Lowest Common Ancestor (30分)</a></li><li><a href="https://emhui.fun/2021/01/23/1151-LCA-in-a-Binary-Tree/">1151 LCA in a Binary Tree (30分)</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>leetcode</tag>
      
      <tag>二叉树</tag>
      
      <tag>LCA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>959. 由斜杠划分区域</title>
    <link href="/2021/01/25/959-%E7%94%B1%E6%96%9C%E6%9D%A0%E5%88%92%E5%88%86%E5%8C%BA%E5%9F%9F/"/>
    <url>/2021/01/25/959-%E7%94%B1%E6%96%9C%E6%9D%A0%E5%88%92%E5%88%86%E5%8C%BA%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="959-由斜杠划分区域"><a href="#959-由斜杠划分区域" class="headerlink" title="959. 由斜杠划分区域"></a><a href="https://leetcode-cn.com/problems/regions-cut-by-slashes/">959. 由斜杠划分区域</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/pCQINx.png" alt="pCQINx"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本题参考<a href="https://leetcode-cn.com/problems/regions-cut-by-slashes/solution/you-xie-gang-hua-fen-qu-yu-by-leetcode-67xb/">🎦 由斜杠划分区域</a></p><p>首先是将<strong>单元格內划分为四个部分</strong>，因为<code>/,\\, &#39; &#39;</code>在单元格內只能将分成下面三种情况</p><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/EAG0KQ.png" alt="单元内连通"></p><p>然后分成三种情况，对单元格內的区域进行连通</p><ul><li>空格：连通所有区域</li><li>斜杠：分别连通03，12区域</li><li>反斜杠：分别连通01，23区域</li></ul><p>对单元格內区域连通完成后，考虑对<strong>单元格之间</strong>进行连通。如下图</p><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/r2ZEwN.png" alt="r2ZEwN"></p><p>经过发现</p><ul><li>左右相邻的单元格中，左单元格1区域和右单元格3区域一定连通</li><li>上下相邻的单元格中，上单元格2区域和下单元格0区域一定连通</li></ul><p>即单元格之间的连通关系如下图所示</p><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/SeXPgr.png" alt="单元格之间连通"></p><p>知道连通情况后，就可以使用<strong>并查集</strong>计算连通分量个数。</p><p>这里需要计算每个单元格的下标。由于是一个<code>N*N</code>的单元格，每个单元格分成4个区域，因此单元格总数应该是<code>4*N*N</code>.而每个单元格的起始下标应该是<code>4 * (i * N + j)</code>.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span> &#123;</span><br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; parent;<br>    <span class="hljs-keyword">int</span> countConnections;<br>    <span class="hljs-keyword">public</span>:<br>    UnionFind(<span class="hljs-keyword">int</span> n) &#123;<br>        countConnections = n;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) parent.push_back(i);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (x != parent[x]) &#123;<br>            parent[x] = find(parent[x]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> parent[x];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quick_union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> w)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> vRoot = find(v), wRoot = find(w);<br>        <span class="hljs-keyword">if</span> (vRoot == wRoot) <span class="hljs-keyword">return</span>;<br>        parent[find(v)] = find(w);<br>        countConnections--;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getCountConnections</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> countConnections;<br>    &#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">regionsBySlashes</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> size = grid.size();<br>        <span class="hljs-function">UnionFind <span class="hljs-title">uf</span><span class="hljs-params">(size * size * <span class="hljs-number">4</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; size; j++) &#123;<br>                <span class="hljs-comment">// 判断每个单元格內连通情况</span><br>                <span class="hljs-keyword">int</span> idx = <span class="hljs-number">4</span> * (i * size + j); <span class="hljs-comment">// 当前位于第几个单元格</span><br>                <span class="hljs-keyword">char</span> c = grid[i][j];<br>                <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;/&#x27;</span>) &#123; <span class="hljs-comment">// 连通0-3,1-2</span><br>                    uf.quick_union(idx, idx + <span class="hljs-number">3</span>);<br>                    uf.quick_union(idx + <span class="hljs-number">1</span>, idx + <span class="hljs-number">2</span>);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;\\&#x27;</span>) &#123; <span class="hljs-comment">// union 0-1,2-3</span><br>                    uf.quick_union(idx, idx + <span class="hljs-number">1</span>);<br>                    uf.quick_union(idx + <span class="hljs-number">2</span>, idx + <span class="hljs-number">3</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// union all</span><br>                    uf.quick_union(idx, idx + <span class="hljs-number">1</span>);<br>                    uf.quick_union(idx + <span class="hljs-number">1</span>, idx + <span class="hljs-number">2</span>);<br>                    uf.quick_union(idx + <span class="hljs-number">2</span>, idx + <span class="hljs-number">3</span>);<br>                &#125;<br><br>                <span class="hljs-comment">// 连通相邻单元格，单元格是一定可以实现连通的，画图出来就可以知道了。</span><br>                <span class="hljs-keyword">if</span> (j &lt; size - <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// union left:1-right:3</span><br>                    uf.quick_union(idx + <span class="hljs-number">1</span>, <span class="hljs-number">4</span> * (i * size + j + <span class="hljs-number">1</span>) + <span class="hljs-number">3</span>);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (i &lt; size - <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// union bottom:2-top:0</span><br>                    uf.quick_union(idx + <span class="hljs-number">2</span>, <span class="hljs-number">4</span> * ((i + <span class="hljs-number">1</span>) * size + j));<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> uf.getCountConnections();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>union-find</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1143 Lowest Common Ancestor</title>
    <link href="/2021/01/24/1143-Lowest-Common-Ancestor/"/>
    <url>/2021/01/24/1143-Lowest-Common-Ancestor/</url>
    
    <content type="html"><![CDATA[<h1 id="1143-Lowest-Common-Ancestor-30分"><a href="#1143-Lowest-Common-Ancestor-30分" class="headerlink" title="1143 Lowest Common Ancestor (30分)"></a>1143 Lowest Common Ancestor (30分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/h3PwWE.png" alt="h3PwWE"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本题和<a href="https://emhui.fun/2021/01/23/1151-LCA-in-a-Binary-Tree/">1151 LCA in a Binary Tree (30分)</a>几乎完全一致的思路。这题是只告诉了你前序遍历，但是指明了树是一颗<strong>二叉搜索树</strong>。已知二叉搜索树的中序遍历就是一个递增序列，因此将前序遍历排序就得到了该树的中序遍历。然后和<a href="https://emhui.fun/2021/01/23/1151-LCA-in-a-Binary-Tree/">1151 LCA in a Binary Tree (30分)</a>就是一个题目了。</p><div class="note note-warning">            <p>本题由于给出的是二叉搜索树，对于二叉搜索树的最近公共祖先有专门LCA算法，该算法补充到下列代码的<code>dfs2</code>中</p>          </div><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span> &#123;</span><br>    <span class="hljs-keyword">int</span> val;<br>    TreeNode *left, *right;<br>&#125;;<br><br><span class="hljs-function">TreeNode* <span class="hljs-title">createTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> preL, <span class="hljs-keyword">int</span> preR, <span class="hljs-keyword">int</span> inL, <span class="hljs-keyword">int</span> inR, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; preorder, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (preL &gt; preR) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    TreeNode *root = <span class="hljs-keyword">new</span> TreeNode;<br>    root-&gt;val = preorder[preL];<br>    <span class="hljs-keyword">int</span> mid = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (mid = inL; mid &lt;= inR; mid++) &#123;<br>        <span class="hljs-keyword">if</span> (inorder[mid] == preorder[preL]) <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> leftNum = mid - inL;<br>    root-&gt;left = createTree(preL + <span class="hljs-number">1</span>, preL + leftNum, inL, mid - <span class="hljs-number">1</span>, preorder, inorder);<br>    root-&gt;right = createTree(preL + leftNum + <span class="hljs-number">1</span>, preR, mid + <span class="hljs-number">1</span>, inR, preorder, inorder);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><br><span class="hljs-function">TreeNode* <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> root;<br>    <span class="hljs-keyword">if</span> (root-&gt;val == u || root-&gt;val == v) &#123;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    TreeNode* left = dfs(root-&gt;left, u, v);<br>    TreeNode* right = dfs(root-&gt;right, u, v);<br>    <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> right;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> left;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> root;<br>&#125;<br><br><span class="hljs-comment">// 增加对平衡二叉树的判断最小公共祖先。</span><br><span class="hljs-function">TreeNode* <span class="hljs-title">dfs2</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> (root-&gt;val &lt; u &amp;&amp; root-&gt;val &lt; v) &#123; <span class="hljs-comment">// uv在右则对右子树访问即可</span><br>        <span class="hljs-keyword">return</span> dfs(root-&gt;right, u, v);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (root-&gt;val &gt; u &amp;&amp; root-&gt;val &gt; v) <span class="hljs-comment">// uv在左侧，则直接访问左侧</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> dfs(root-&gt;left, u, v);<br>    &#125;<br>    <span class="hljs-keyword">return</span> root; <span class="hljs-comment">// 否则在两端，则该结点就是根结点</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isExit</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; vs, <span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; vs.size(); i++) &#123;<br>        <span class="hljs-keyword">if</span> (vs[i] == x) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, m;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;m, &amp;n);<br>    vector&lt;int&gt; preorder(n), inorder(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;preorder[i]);<br>    &#125;<br>    inorder = preorder;<br>    sort(inorder.begin(), inorder.end()); <span class="hljs-comment">// 二叉搜索树的中序遍历就是从小到达的顺序。</span><br>    TreeNode* root = createTree(<span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, preorder, inorder);<br><br>    <span class="hljs-keyword">int</span> u, v;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);<br>        <span class="hljs-keyword">if</span> (!isExit(inorder, u) &amp;&amp; !isExit(inorder, v)) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ERROR: %d and %d are not found.\n&quot;</span>, u, v);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!isExit(inorder, u)) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ERROR: %d is not found.\n&quot;</span>, u);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!isExit(inorder, v)) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ERROR: %d is not found.\n&quot;</span>, v);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            TreeNode* ans = dfs2(root, u, v);<br>            <span class="hljs-keyword">if</span> (ans == <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">// 在这里加一个判断，判断ans是否存在</span><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ERROR: %d and %d are not found.\n&quot;</span>, u, v);<br>            &#125; <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">if</span> (ans-&gt;val != u &amp;&amp; ans-&gt;val != v) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;LCA of %d and %d is %d.\n&quot;</span>, u, v, ans-&gt;val);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ans-&gt;val == u) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d is an ancestor of %d.\n&quot;</span>, u, v);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ans-&gt;val == v) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d is an ancestor of %d.\n&quot;</span>, v, u);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
      <tag>LCA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1147 Heaps</title>
    <link href="/2021/01/24/1147-Heaps/"/>
    <url>/2021/01/24/1147-Heaps/</url>
    
    <content type="html"><![CDATA[<h1 id="1147-Heaps-30分"><a href="#1147-Heaps-30分" class="headerlink" title="1147 Heaps (30分)"></a>1147 Heaps (30分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><div class="note note-warning">            <ul><li>为了防止时间超时，能使用数组就不用<code>vector</code></li></ul>          </div><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/CnmiXY.png" alt="CnmiXY"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本题主要考察<strong>判断大小堆</strong>，<strong>遍历完全二叉树</strong></p><ul><li>判断大小堆使用下面方法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> h[MAX], m; <span class="hljs-comment">// h数组表示堆结构，m为堆的数量。</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">isWhatHeap</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 大堆返回1，小堆返回-1，不是堆返回0</span><br>    <span class="hljs-keyword">bool</span> isMax = <span class="hljs-literal">true</span>, isMin = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-keyword">if</span> (h[i] &gt; h[i / <span class="hljs-number">2</span>]) isMax = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (h[i] &lt; h[i / <span class="hljs-number">2</span>]) isMin = <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (isMax) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Max Heap\n&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isMin) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Min Heap\n&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Not Heap\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>完全二叉树的后续遍历</li></ul><p>后序遍历</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">postTravel</span><span class="hljs-params">(<span class="hljs-keyword">int</span> idx)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (idx &gt; m) &#123;<span class="hljs-keyword">return</span>;&#125;<br>    postTravel(idx * <span class="hljs-number">2</span>);<br>    postTravel(idx * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, h[idx]);<br>    <span class="hljs-keyword">if</span> (idx == <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">1001</span>;<br><span class="hljs-keyword">int</span> h[MAX], n, m;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">isWhatHeap</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 大堆返回1，小堆返回-1，不是堆返回0</span><br>    <span class="hljs-keyword">bool</span> isMax = <span class="hljs-literal">true</span>, isMin = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-keyword">if</span> (h[i] &gt; h[i / <span class="hljs-number">2</span>]) isMax = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (h[i] &lt; h[i / <span class="hljs-number">2</span>]) isMin = <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (isMax) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Max Heap\n&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isMin) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Min Heap\n&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Not Heap\n&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">postTravel</span><span class="hljs-params">(<span class="hljs-keyword">int</span> idx)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (idx &gt; m) &#123;<span class="hljs-keyword">return</span>;&#125;<br>    postTravel(idx * <span class="hljs-number">2</span>);<br>    postTravel(idx * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, h[idx]);<br>    <span class="hljs-keyword">if</span> (idx == <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-keyword">while</span> (n--) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;h[i]);<br>        &#125;<br>        isWhatHeap();<br>        postTravel(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">int</span> m, n; <span class="hljs-comment">// m:tests, n:keys;</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; cbt;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">posttravel</span><span class="hljs-params">(<span class="hljs-keyword">int</span> root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root &gt; n) <span class="hljs-keyword">return</span>;<br>    posttravel(root * <span class="hljs-number">2</span>);<br>    posttravel(root * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, cbt[root]);<br>    <span class="hljs-keyword">if</span> (root != <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; m &gt;&gt; n;<br>    <span class="hljs-keyword">bool</span> isMaxHeap, isMinHeap;<br>    cbt.resize(n + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        cbt.clear();<br>        isMaxHeap = isMinHeap = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-built_in">cin</span> &gt;&gt; cbt[i];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n; i &gt;= <span class="hljs-number">2</span>; i--) &#123;<br>            <span class="hljs-keyword">if</span> (cbt[i] &gt; cbt[i / <span class="hljs-number">2</span>]) isMaxHeap = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span> (cbt[i] &lt; cbt[i / <span class="hljs-number">2</span>]) isMinHeap = <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (isMaxHeap) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Max Heap\n&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isMinHeap) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Min Heap\n&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Not Heap\n&quot;</span>);<br>        posttravel(<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>类似题目</p><ul><li><a href="https://emhui.fun/2021/01/23/1155-Heap-Paths-30%E5%88%86/">1155 Heap Paths (30分)</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>堆</tag>
      
      <tag>完全二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>207. 课程表</title>
    <link href="/2021/01/24/207-%E8%AF%BE%E7%A8%8B%E8%A1%A8/"/>
    <url>/2021/01/24/207-%E8%AF%BE%E7%A8%8B%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207. 课程表"></a><a href="https://leetcode-cn.com/problems/course-schedule/">207. 课程表</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/4qORtC.png" alt="4qORtC"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>简单的拓扑排序，但是⚠️这题需要自己重建一个邻接表来存储图。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">canFinish</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numCourses, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">inDegree</span><span class="hljs-params">(numCourses, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">G</span><span class="hljs-params">(numCourses)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; prerequisites.size(); i++) &#123;<br>            inDegree[prerequisites[i][<span class="hljs-number">1</span>]]++;<br>            G[prerequisites[i][<span class="hljs-number">0</span>]].push_back(prerequisites[i][<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numCourses; i++) &#123;<br>            <span class="hljs-keyword">if</span> (inDegree[i] == <span class="hljs-number">0</span>) &#123;<br>                q.push(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (q.empty()) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<br>        <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!q.empty()) &#123;<br>            <span class="hljs-keyword">int</span> top = q.front();<br>            q.pop();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; G[top].size(); i++) &#123;<br>                <span class="hljs-keyword">int</span> v = G[top][i];<br>                inDegree[v]--;<br>                <span class="hljs-keyword">if</span> (inDegree[v] == <span class="hljs-number">0</span>) &#123;q.push(v);&#125;<br>            &#125;<br>            num++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (num == numCourses) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>leetcode</tag>
      
      <tag>拓扑排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1146 Topological Order (25分)</title>
    <link href="/2021/01/24/1146-Topological-Order-25%E5%88%86/"/>
    <url>/2021/01/24/1146-Topological-Order-25%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1146-Topological-Order-25分"><a href="#1146-Topological-Order-25分" class="headerlink" title="1146 Topological Order (25分)"></a>1146 Topological Order (25分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>This is a problem given in the Graduate Entrance Exam in 2018: Which of the following is NOT a topological order obtained from the given directed graph? Now you are supposed to write a program to test each of the options.</p><p><img src="https://images.ptausercontent.com/5d35ed2a-4d19-4f13-bf3f-35ed59cebf05.jpg" alt="图"></p><p><strong>Input Specification:</strong></p><p>Each input file contains one test case. For each case, the first line gives two positive integers N (≤ 1,000), the number of vertices in the graph, and M (≤ 10,000), the number of directed edges. Then M lines follow, each gives the start and the end vertices of an edge. The vertices are numbered from 1 to N. After the graph, there is another positive integer K (≤ 100). Then K lines of query follow, each gives a permutation of all the vertices. All the numbers in a line are separated by a space.</p><p><strong>Output Specification:</strong></p><p>Print in a line all the indices of queries which correspond to “NOT a topological order”. The indices start from zero. All the numbers are separated by a space, and there must no extra space at the beginning or the end of the line. It is graranteed that there is at least one answer.</p><p><strong>Sample Input:</strong></p><blockquote><p>6 8</p><p>1 2</p><p>1 3</p><p>5 2</p><p>5 4</p><p>2 3</p><p>2 6</p><p>3 4</p><p>6 4</p><p>5</p><p>1 5 2 3 6 4</p><p>5 1 2 6 3 4</p><p>5 1 2 3 6 4</p><p>5 2 1 6 3 4</p><p>1 2 3 4 5 6</p></blockquote><p><strong>Sample Output:</strong></p><blockquote><p>3 4</p></blockquote><hr><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本题是给出多个序列，判断是否是拓扑排序。</p><p>使用邻接表建立一个有向图。同时计算每个点的入度。</p><p>将给出序列依次放进一个队列中，然后依次判断当前队首元素的入度是否为0，若为0，将其相连的顶点的入度都-1.若不是0，证明该序列非拓扑排序。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 判断是否是拓扑序列</span><br><span class="hljs-comment">// 把序列放到队列中，一个个判断，若队首元素的入度为0，把该元素设计到的所有顶点入度-1.</span><br><span class="hljs-comment">// 若队首的元素入度不为0，则证明不是拓扑排序</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">1001</span>;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; G[MAX];<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isTopologicalOrder</span><span class="hljs-params">(<span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; q, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; inDegree)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (!q.empty()) &#123;<br>        <span class="hljs-keyword">int</span> top = q.front();<br>        <span class="hljs-keyword">if</span> (inDegree[top] != <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<br>        q.pop();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; G[top].size(); i++) &#123; <span class="hljs-comment">// 将该点设计到的所有顶点入度-1</span><br>            inDegree[G[top][i]]--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, m, start, end, k, val;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">inDegree</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// 记住编号是1开始的。</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;start, &amp;end);<br>        G[start].push_back(end);<br>        inDegree[end]++;<br>    &#125;<br><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans;<br>    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;k);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; tempInDegree = inDegree;<br>        <span class="hljs-keyword">while</span> (!q.empty()) q.pop(); <span class="hljs-comment">// 清空队列</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;val);<br>            q.push(val);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!isTopologicalOrder(q, tempInDegree)) &#123;<br>            ans.push_back(i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ans.size(); i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ans[i]);<br>        <span class="hljs-keyword">if</span> (i &lt; ans.size() - <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><input disabled="" type="checkbox"> 拓扑排序知识点</li></ul>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
      <tag>拓扑排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1144 The Missing Number</title>
    <link href="/2021/01/24/1144-The-Missing-Number/"/>
    <url>/2021/01/24/1144-The-Missing-Number/</url>
    
    <content type="html"><![CDATA[<h1 id="1144-The-Missing-Number-20分"><a href="#1144-The-Missing-Number-20分" class="headerlink" title="1144 The Missing Number (20分)"></a>1144 The Missing Number (20分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/R7nlwN.png" alt="R7nlwN"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>使用一个<code>set</code>记录大于0的值，由于<code>set</code>默认排序，因此不需要使用<code>sort</code>.然后依次判断<code>1 ~ size+1</code>范围內的值是否在<code>set</code>內，若不在则是缺失的值</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 找到最小的且没有出现在里面的数字</span><br>    <span class="hljs-keyword">int</span> n, val;<br>    <span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt; s;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; val;<br>        s.insert(val);<br>    &#125;<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;num: s) &#123;<br>        <span class="hljs-keyword">if</span> (num &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">// 如果这个数大于0，且没有出现在输入中</span><br>        <span class="hljs-keyword">if</span> (s.count(ans) == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">else</span> ans = num + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><code>set</code>默认从小到大排序</li></ul>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
      <tag>set</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1151 LCA in a Binary Tree</title>
    <link href="/2021/01/23/1151-LCA-in-a-Binary-Tree/"/>
    <url>/2021/01/23/1151-LCA-in-a-Binary-Tree/</url>
    
    <content type="html"><![CDATA[<h1 id="1151-LCA-in-a-Binary-Tree-30分"><a href="#1151-LCA-in-a-Binary-Tree-30分" class="headerlink" title="1151 LCA in a Binary Tree (30分)"></a>1151 LCA in a Binary Tree (30分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/Dqy4px.png" alt="Dqy4px"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本题很常规，建树+求公共祖先。</p><p>将已知两个遍历，建立一个树，然后在给出两个子结点，求公共根结点。</p><ul><li><a href="https://emhui.fun/2021/01/14/1086-Tree-Traversals-Again/">已知前序和中序建树</a></li><li><a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/solution/er-cha-shu-de-zui-jin-gong-gong-zu-xian-6fdt7/">剑指 Offer 68 - II. 二叉树的最近公共祖先</a></li></ul><p>下图为例子中给出的树</p><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/AvDyHA.png" alt="AvDyHA"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><blockquote><p><del>本题还有一个测试用例没有通过，那个测试用例占1分，暂时没有找到具体原因</del><br>已解决，是之前的LCA算法有问题</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span> &#123;</span><br>    <span class="hljs-keyword">int</span> val;<br>    TreeNode *left, *right;<br>&#125;;<br><br><span class="hljs-function">TreeNode* <span class="hljs-title">createTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> preL, <span class="hljs-keyword">int</span> preR, <span class="hljs-keyword">int</span> inL, <span class="hljs-keyword">int</span> inR, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; preorder, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (preL &gt; preR) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    TreeNode *root = <span class="hljs-keyword">new</span> TreeNode;<br>    root-&gt;val = preorder[preL];<br>    <span class="hljs-keyword">int</span> mid = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (mid = inL; mid &lt;= inR; mid++) &#123;<br>        <span class="hljs-keyword">if</span> (inorder[mid] == preorder[preL]) <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> leftNum = mid - inL;<br>    root-&gt;left = createTree(preL + <span class="hljs-number">1</span>, preL + leftNum, inL, mid - <span class="hljs-number">1</span>, preorder, inorder);<br>    root-&gt;right = createTree(preL + leftNum + <span class="hljs-number">1</span>, preR, mid + <span class="hljs-number">1</span>, inR, preorder, inorder);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><br><br><br><span class="hljs-function">TreeNode* <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> root;<br>    <span class="hljs-keyword">if</span> (root-&gt;val == u || root-&gt;val == v) &#123;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    TreeNode* left = dfs(root-&gt;left, u, v);<br>    TreeNode* right = dfs(root-&gt;right, u, v);<br>    <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> right;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> left;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> root;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isExit</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; vs, <span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; vs.size(); i++) &#123;<br>        <span class="hljs-keyword">if</span> (vs[i] == x) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, m;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;m, &amp;n);<br>    vector&lt;int&gt; preorder(n), inorder(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;inorder[i]);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;preorder[i]);<br>    &#125;<br>    TreeNode* root = createTree(<span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, preorder, inorder);<br>    <span class="hljs-keyword">int</span> u, v;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);<br>        <span class="hljs-keyword">if</span> (!isExit(inorder, u) &amp;&amp; !isExit(inorder, v)) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ERROR: %d and %d are not found.\n&quot;</span>, u, v);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!isExit(inorder, u)) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ERROR: %d is not found.\n&quot;</span>, u);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!isExit(inorder, v)) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ERROR: %d is not found.\n&quot;</span>, v);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            TreeNode* ans = dfs(root, u, v);<br>            <span class="hljs-keyword">if</span> (ans == <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">// 在这里加一个判断，判断ans是否存在</span><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ERROR: %d and %d are not found.\n&quot;</span>, u, v);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ans-&gt;val != u &amp;&amp; ans-&gt;val != v) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;LCA of %d and %d is %d.\n&quot;</span>, u, v, ans-&gt;val);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ans-&gt;val == u) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d is an ancestor of %d.\n&quot;</span>, u, v);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ans-&gt;val == v) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d is an ancestor of %d.\n&quot;</span>, v, u);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1150 Travelling Salesman Problem</title>
    <link href="/2021/01/23/1150-Travelling-Salesman-Problem/"/>
    <url>/2021/01/23/1150-Travelling-Salesman-Problem/</url>
    
    <content type="html"><![CDATA[<h1 id="1150-Travelling-Salesman-Problem-25分"><a href="#1150-Travelling-Salesman-Problem-25分" class="headerlink" title="1150 Travelling Salesman Problem (25分)"></a>1150 Travelling Salesman Problem (25分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/FcJdwU.png" alt="FcJdwU"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本题给定一个带路径无向图，在给出一系列的路径。让你计算出路径属于哪一类，路径的总长度。</p><p>上述示例中的无向图如下图所示</p><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/vdd6GA.png" alt="vdd6GA"></p><p>图中有三种路径类型，如何对三种路径判断是关键，同时还包括一种无法到达的路径。</p><ul><li>首先需要判断无法到达的路径，题中示例$7-6-3- 2- 5- 4- 1- 6$中，$3-2$无法到达，令无法到达为<code>INF</code>，若最后<code>cnt &gt; INF</code>证明无法到达该路径，输出<code>NA</code>.</li><li>接下来判断<code>Not a TS cycle</code>, 根据示例<code>4:1-2-5-1</code>和<code>7:6-1-2-5-4-3-1</code>可以知道，当<strong>路径上没有所有城市</strong>或<strong>路径的起点城市和最终城市不一样</strong>，属于<code>Not a TS cycle</code></li><li>接下来是对<code>TS cycle</code>的判断，该类型是指部分城市访问过多次，所以必须满足<code>pn &gt; n + 1</code>,即路径上的城市都访问到了，且不知访问依次</li><li>最后剩下的就是<code>TS simple cycle</code>类型</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">210</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">987654321</span>;<br><br><span class="hljs-keyword">int</span> G[MAX][MAX], path[MAX];<br><span class="hljs-keyword">bool</span> visited[MAX];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, m, k, c1, c2, dis, pn, minDis = INF, minPathId = INF;<br>    fill(G[<span class="hljs-number">0</span>], G[<span class="hljs-number">0</span>] + MAX * MAX, INF);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;c1, &amp;c2, &amp;dis);<br>        G[c1][c2] = G[c2][c1] = dis;<br>    &#125;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;k);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; i++) &#123;<br>        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">bool</span> isAllVisited = <span class="hljs-literal">true</span>;<br>        <span class="hljs-built_in">memset</span>(visited, <span class="hljs-literal">false</span>, <span class="hljs-keyword">sizeof</span>(visited));<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;pn);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; pn; j++) &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;path[j]);<br>            visited[path[j]] = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; pn - <span class="hljs-number">1</span>; j++) &#123;<br>            cnt += G[path[j]][path[j + <span class="hljs-number">1</span>]];<br>        &#125;<br>        <span class="hljs-comment">// 判断是否每个点都访问到了</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (!visited[j]) &#123;<br>                isAllVisited = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (cnt &gt; INF) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Path %d: NA (Not a TS cycle)\n&quot;</span>, i);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!isAllVisited || path[<span class="hljs-number">0</span>] != path[pn - <span class="hljs-number">1</span>])&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Path %d: %d (Not a TS cycle)\n&quot;</span>, i, cnt);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pn &gt; n + <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// printf(&quot;Path %d: %d (TS simple cycle)\n&quot;, i, cnt);</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Path %d: %d (TS cycle)\n&quot;</span>, i, cnt);<br>            <span class="hljs-keyword">if</span> (cnt &lt; minDis) &#123;<br>                minDis = cnt;<br>                minPathId = i;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Path %d: %d (TS simple cycle)\n&quot;</span>, i, cnt);<br>             <span class="hljs-keyword">if</span> (cnt &lt; minDis) &#123;<br>                minDis = cnt;<br>                minPathId = i;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Shortest Dist(%d) = %d\n&quot;</span>, minPathId, minDis);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1149 Dangerous Goods Packaging</title>
    <link href="/2021/01/23/1149-Dangerous-Goods-Packaging/"/>
    <url>/2021/01/23/1149-Dangerous-Goods-Packaging/</url>
    
    <content type="html"><![CDATA[<h1 id="1149-Dangerous-Goods-Packaging-25分"><a href="#1149-Dangerous-Goods-Packaging-25分" class="headerlink" title="1149 Dangerous Goods Packaging (25分)"></a>1149 Dangerous Goods Packaging (25分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/jgZKfU.png" alt="jgZKfU"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本题给定多个危险对，每队包含两个商品ID，再给出一些已购商品清单。判断是否该清单中是否存在危险对，若存在则输出<code>No</code>，否则<code>Yes</code>。</p><p>可以使用邻接表把危险对存储起来，然后再设置一个<code>visited</code>数组。</p><p>在输入已购货品清单的时候，逐个判断当前货品，将当前货品以及相关的危险货品<code>visited[i] = true</code>。若某个货品已经被访问过，证明它和之前的货品是危险对。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">100000</span>;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; a[MAX];<br><span class="hljs-keyword">bool</span> visited[MAX];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, m, k, u, v, g;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);<br>        a[u].push_back(v);<br>        a[v].push_back(u);<br>    &#125;<br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        <span class="hljs-built_in">memset</span>(visited, <span class="hljs-literal">false</span>, <span class="hljs-keyword">sizeof</span>(visited));<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;k);<br>        <span class="hljs-keyword">bool</span> isSafe = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;g);<br>            <span class="hljs-keyword">if</span> (!visited[g]) &#123; <span class="hljs-comment">// 如果没有访问，则访问该结点的所有结点</span><br>                visited[g] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; a[g].size(); j++) &#123;visited[a[g][j]] = <span class="hljs-literal">true</span>;&#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                isSafe = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (isSafe) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Yes\n&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1155 Heap Paths</title>
    <link href="/2021/01/23/1155-Heap-Paths-30%E5%88%86/"/>
    <url>/2021/01/23/1155-Heap-Paths-30%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1155-Heap-Paths-30分"><a href="#1155-Heap-Paths-30分" class="headerlink" title="1155 Heap Paths (30分)"></a>1155 Heap Paths (30分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/Zsw7lc.png" alt="Zsw7lc"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>重点：如何判断是否是叶子结点</p><p>堆是一个完全二叉树，由堆顶往叶子结点的路径中，结点的值总是递增（小堆）或者递减（小堆）。</p><p>给定一个层次遍历的堆，打印出从堆顶到叶子结点的所有路径，要求先打印右边再打印左边。最后判断该堆是否是大堆或者是小堆，或者不是堆。</p><p>本题可以通过<code>DFS</code>对二叉树进行遍历，先遍历右子树，再遍历左子树。遍历开始前先把根结点压入路径中，遍历完左右后弹出路径。这里需要注意以下几点</p><ul><li>完全二叉树中，根结点下标是从<code>1</code>开始</li><li>在完全二叉树中，若当前结点下标为<code>x</code>，则其左子树结点下标为<code>2*x</code>，右子树下标为<code>2*x+1</code>.</li><li>如何判断完全二叉树的叶子结点。</li></ul><p>一般来说满足条件<code>2*x &gt; n</code>则一定是叶子结点，但是下面这种情况特殊。下标为<code>4</code>的结点，它存在左子树为<code>8</code>的结点。该情况判断在代码中。</p><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/yjdxvz.png" alt="yjdxvz"></p><ul><li>如何判断是最小堆还是最大堆，设置两个变量，<code>isMaxHeap = true, isMinHeap = false</code>. 然后在遍历路径的过程中对<code>i,i+1</code>值判断.判断如下</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span> (path[i] - path[i + <span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span>) &#123;<br>isMaxHeap = <span class="hljs-literal">true</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (path[i] - path[i + <span class="hljs-number">1</span>] &lt; <span class="hljs-number">0</span>) &#123;<br>isMinHeap = <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后如果两个值同时为<code>True</code>，证明无法形成堆。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">int</span> n;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; path;<br><span class="hljs-keyword">bool</span> isMaxHeap = <span class="hljs-literal">false</span>, isMinHeap = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 假设默认是heap</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; cbt, <span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>   <span class="hljs-comment">//  printf(&quot;%d\n&quot;, x * 2);</span><br>    <span class="hljs-keyword">if</span> (x * <span class="hljs-number">2</span> &gt;= n) &#123; <span class="hljs-comment">// 如果没</span><br>        path.push_back(cbt[x]);<br>        <span class="hljs-keyword">if</span> (x * <span class="hljs-number">2</span> == n) &#123;path.push_back(cbt[x*<span class="hljs-number">2</span>]);&#125;<br>        <span class="hljs-keyword">int</span> size = path.size();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, path[i]);<br>            <span class="hljs-keyword">if</span> (i &lt; size - <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">if</span> (path[i] - path[i + <span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span>) &#123;<br>                    isMaxHeap = <span class="hljs-literal">true</span>;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (path[i] - path[i + <span class="hljs-number">1</span>] &lt; <span class="hljs-number">0</span>) &#123;<br>                    isMinHeap = <span class="hljs-literal">true</span>;<br>                &#125;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>        <span class="hljs-keyword">if</span> (x * <span class="hljs-number">2</span> == n) &#123;path.pop_back();&#125;<br>        path.pop_back();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    path.push_back(cbt[x]);<br>    dfs(cbt, x * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>    dfs(cbt, x * <span class="hljs-number">2</span>);<br>    path.pop_back();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">cbt</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">// 建立一颗完全二叉树</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;cbt[i]);<br>    &#125;<br>    dfs(cbt, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (isMaxHeap &amp;&amp; isMinHeap) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Not Heap\n&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isMaxHeap) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Max Heap\n&quot;</span>);&#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isMinHeap) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Min Heap\n&quot;</span>);&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
      <tag>堆</tag>
      
      <tag>完全二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1154 Vertex Coloring</title>
    <link href="/2021/01/23/1154-Vertex-Coloring/"/>
    <url>/2021/01/23/1154-Vertex-Coloring/</url>
    
    <content type="html"><![CDATA[<h1 id="1154-Vertex-Coloring-25分"><a href="#1154-Vertex-Coloring-25分" class="headerlink" title="1154 Vertex Coloring (25分)"></a>1154 Vertex Coloring (25分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><div class="note note-warning">            <p>有些题目很简单，不要想太复杂了。</p>          </div><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/hjDrpN.png" alt="hjDrpN"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本题就是求在一个图中，若相邻的两个点为相同颜色，则输出<code>No</code>,否则输出颜色个数。</p><p>可以建立一个邻接表，然后对每个顶点分别和他邻接的顶点去比较颜色，若颜色一致，则直接退出比较。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">bool</span> hasSameEdge = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> node: graphic[j]) &#123;<br><span class="hljs-keyword">if</span> (color[j] == color[node])&#123;<br>hasSameEdge = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (hasSameEdge) <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 只要相邻的边存在颜色一样，就输出No</span><br><span class="hljs-comment">// 如果没有发现，那么就是输出使用了颜色的数量</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, m, k, u, v;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m); <span class="hljs-comment">// n:顶点数量，m:边的数量</span><br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">graphic</span><span class="hljs-params">(n)</span></span>; <span class="hljs-comment">// 使用邻接表存储</span><br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">color</span><span class="hljs-params">(n)</span></span>; <span class="hljs-comment">// 存储颜色</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);<br>        graphic[u].push_back(v);<br>        graphic[v].push_back(u);<br>    &#125;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;k);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;color[j]);<br>        &#125;<br>        <span class="hljs-keyword">bool</span> hasSameEdge = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> node: graphic[j]) &#123;<br>                <span class="hljs-keyword">if</span> (color[j] == color[node])&#123;<br>                    hasSameEdge = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (hasSameEdge) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (hasSameEdge) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No\n&quot;</span>);<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt; st(color.begin(), color.end());<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d-coloring\n&quot;</span>, st.size());<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法， 邻接表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1153 Decode Registration Card of PAT</title>
    <link href="/2021/01/23/1153-Decode-Registration-Card-of-PAT/"/>
    <url>/2021/01/23/1153-Decode-Registration-Card-of-PAT/</url>
    
    <content type="html"><![CDATA[<h1 id="1153-Decode-Registration-Card-of-PAT-25分"><a href="#1153-Decode-Registration-Card-of-PAT-25分" class="headerlink" title="1153 Decode Registration Card of PAT (25分)"></a>1153 Decode Registration Card of PAT (25分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><div class="note note-warning">            <ol><li>将输入改成printf可以防止部分用例超时</li><li>在循环的时候输出当前是第几次循环，尽量使用下标i，而不是单独设置一个变量进行++。</li></ol>          </div><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/ORG4bt.png" alt="ORG4bt"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本题参考<a href="https://blog.csdn.net/liuchuo/article/details/84973049">PAT 1153 Decode Registration Card of PAT （25 分）- 甲级</a>.</p><p>⚠️ 主要注意一下超时问题，经过测试发现得出下面几条提升效率的方法。</p><ol><li>使用<code>printf</code>输出。</li><li><code>num++</code>操作尽量不使用，能用下标就使用下标，比如本题的<code>Case #: ...</code>, 其中<code>#</code>用<code>i</code>表示。</li><li>函数传参数的时候传递地址过去。</li><li>对于<code>map</code>和<code>unordered_map</code>,在要求时间优先的情况下，使用<code>unordered_map</code>.二者区别可参考<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="c++ map与unordered_map区别及使用">[1]</span></a></sup></li></ol><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>&#123;</span><br>    <span class="hljs-built_in">string</span> s;<br>    <span class="hljs-keyword">int</span> val;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, m;<br>    <span class="hljs-built_in">string</span> str;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;Node&gt; <span class="hljs-title">vn</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; vn[i].s &gt;&gt; vn[i].val;<br>    &#125;<br>    <span class="hljs-keyword">int</span> caseId = <span class="hljs-number">1</span>, queryId; <span class="hljs-comment">// 这里caseId最好不要使用，直接使用下标i坐标当前示例</span><br>    <span class="hljs-built_in">string</span> sq;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; queryId &gt;&gt; sq;<br>       <span class="hljs-comment">// cout &lt;&lt; &quot;Case &quot; &lt;&lt; caseId++ &lt;&lt; &quot;: &quot;&lt;&lt; queryId &lt;&lt; &quot; &quot; &lt;&lt; sq &lt;&lt; endl;</span><br>       <span class="hljs-comment">// printf(&quot;Case %d: %d %s\n&quot;, caseId++, queryId, sq.c_str());</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Case %d: %d %s\n&quot;</span>, i, queryId, sq.c_str());<br>        <span class="hljs-built_in">vector</span>&lt;Node&gt; ans;<br>        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>, allScore = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (queryId == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                <span class="hljs-keyword">if</span> (vn[i].s[<span class="hljs-number">0</span>] == sq[<span class="hljs-number">0</span>]) &#123;ans.push_back(vn[i]);&#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (queryId == <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                <span class="hljs-keyword">if</span> (vn[i].s.substr(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>) == sq) &#123;cnt++, allScore += vn[i].val;&#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cnt &gt; <span class="hljs-number">0</span>)<br>                <span class="hljs-comment">// cout &lt;&lt; cnt &lt;&lt; &quot; &quot; &lt;&lt; allScore &lt;&lt; endl;</span><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, cnt, allScore);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (queryId == <span class="hljs-number">3</span>) &#123;<br>            <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt; um;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                <span class="hljs-keyword">if</span> (vn[i].s.substr(<span class="hljs-number">4</span>, <span class="hljs-number">6</span>) == sq) &#123;um[vn[i].s.substr(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)]++;&#125; <span class="hljs-comment">// 把班级号作为key,人数作为val</span><br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; m: um) &#123;ans.push_back(&#123;m.first, m.second&#125;);&#125;<br>        &#125;<br>        sort(ans.begin(), ans.end(), [](<span class="hljs-keyword">auto</span>&amp; a, <span class="hljs-keyword">auto</span>&amp; b)&#123;<br>            <span class="hljs-keyword">if</span> (a.val != b.val) &#123;<span class="hljs-keyword">return</span> a.val &gt; b.val;&#125;<br>            <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> a.s &lt; b.s;&#125;<br>        &#125;);<br>        <span class="hljs-keyword">if</span> (((queryId == <span class="hljs-number">1</span> || queryId == <span class="hljs-number">3</span>) &amp;&amp; ans.size() == <span class="hljs-number">0</span>) || (queryId == <span class="hljs-number">2</span> &amp;&amp; cnt == <span class="hljs-number">0</span>)) &#123;<br>            <span class="hljs-comment">// cout &lt;&lt; &quot;NA\n&quot;;</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NA\n&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; a: ans) &#123;<br>                <span class="hljs-comment">// cout &lt;&lt; a.s &lt;&lt; &quot; &quot; &lt;&lt; a.val &lt;&lt; endl;</span><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s %d\n&quot;</span>, a.s.c_str(), a.val); <span class="hljs-comment">// 将输入改成printf可以提升效率</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><section class="footnotes"><h2>参考</h2><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://blog.csdn.net/qq_21997625/article/details/84672775">c++ map与unordered_map区别及使用</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1319. 连通网络的操作次数</title>
    <link href="/2021/01/23/1319-%E8%BF%9E%E9%80%9A%E7%BD%91%E7%BB%9C%E7%9A%84%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0/"/>
    <url>/2021/01/23/1319-%E8%BF%9E%E9%80%9A%E7%BD%91%E7%BB%9C%E7%9A%84%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="1319-连通网络的操作次数"><a href="#1319-连通网络的操作次数" class="headerlink" title="1319. 连通网络的操作次数"></a><a href="https://leetcode-cn.com/problems/number-of-operations-to-make-network-connected/">1319. 连通网络的操作次数</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/QhV5ev.png" alt="QhV5ev"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目要求将所有电脑连接起来。即将所有连通分量合并成一个。根据定义，一个连通图若要连通，则至少需要$n-1$条边。每次合并两个连通分量就需要一条边，因此本题就转化成，计算给定图中存在多少连通分量。而所需要断开的线的数量为<strong>连通分量数量-1</strong>。</p><p>并查集可以解决连通分量问题。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span> &#123;</span><br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; parent;<br>    <span class="hljs-keyword">int</span> countConnections;<br>    <span class="hljs-keyword">public</span>:<br>    UnionFind(<span class="hljs-keyword">int</span> n) &#123;<br>        countConnections = n;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) parent.push_back(i);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (x != parent[x]) &#123;<br>            parent[x] = find(parent[x]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> parent[x];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quick_union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> w)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> vRoot = find(v), wRoot = find(w);<br>        <span class="hljs-keyword">if</span> (vRoot == wRoot) <span class="hljs-keyword">return</span>;<br>        parent[find(v)] = find(w);<br>        countConnections--;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getCountConnections</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> countConnections;<br>    &#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">makeConnected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; connections)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (connections.size() &lt; n - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-function">UnionFind <span class="hljs-title">uf</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; node: connections) &#123;<br>            <span class="hljs-keyword">int</span> u = node[<span class="hljs-number">0</span>], v = node[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (uf.find(u) != uf.find(v)) &#123;<br>                uf.quick_union(u, v);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> uf.getCountConnections() - <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>union-find</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1152 Google Recruitment</title>
    <link href="/2021/01/22/1152-Google-Recruitment/"/>
    <url>/2021/01/22/1152-Google-Recruitment/</url>
    
    <content type="html"><![CDATA[<h1 id="1152-Google-Recruitment-20分"><a href="#1152-Google-Recruitment-20分" class="headerlink" title="1152 Google Recruitment (20分)"></a>1152 Google Recruitment (20分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>In July 2004, Google posted on a giant billboard along Highway 101 in Silicon Valley (shown in the picture below) for recruitment. The content is super-simple, a URL consisting of the first 10-digit prime found in consecutive digits of the natural constant e. The person who could find this prime number could go to the next step in Google’s hiring process by visiting this website.</p><p><img src="https://images.ptausercontent.com/57148679-d574-4f49-b048-775c6c07791c.jpg" alt="Google"></p><p>The natural constant e is a well known transcendental number（超越数）. The first several digits are: e = 2.71828182845904523536028747135266249775724709369995957496696762772407663035354759457138217852516642742<strong>7466391</strong>932003059921… where the 10 digits in bold are the answer to Google’s question.</p><p>Now you are asked to solve a more general problem: find the first K-digit prime in consecutive digits of any given L-digit number.</p><p><strong>Input Specification:</strong></p><p>Each input file contains one test case. Each case first gives in a line two positive integers: L (≤ 1,000) and K (&lt; 10), which are the numbers of digits of the given number and the prime to be found, respectively. Then the L-digit number N is given in the next line.</p><p><strong>Output Specification:</strong></p><p>For each test case, print in a line the first K-digit prime in consecutive digits of N. If such a number does not exist, output 404 instead. Note: the leading zeroes must also be counted as part of the K digits. For example, to find the 4-digit prime in 200236, 0023 is a solution. However the first digit 2 must not be treated as a solution 0002 since the leading zeroes are not in the original number.</p><p><strong>Sample Input 1:</strong></p><blockquote><p>20 5</p><p>23654987725541023819</p></blockquote><p><strong>Sample Output 1:</strong></p><blockquote><p>49877</p></blockquote><p><strong>Sample Input 2:</strong></p><blockquote><p>10 3</p><p>2468024680</p></blockquote><p><strong>Sample Output 2:</strong></p><blockquote><p>404</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本题是寻找给定数字中第一个K位素数。所以需要将给定数字依次分割成K位进行判断是否为素数。</p><p>⚠️</p><ul><li>在依次分割K位的时候，<code>i + k &lt;= l</code>注意应该是<code>&lt;=</code>。</li><li>在判断是否为素数的时候，也是需要<code>i * i &lt;= n</code>。这里符号是<code>&lt;=</code>。</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPrime</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> ( x &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i * i &lt;= x; i++) &#123;<br>        <span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> l, k;<br>    <span class="hljs-built_in">string</span> str;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; l &gt;&gt; k &gt;&gt; str;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i + k &lt;= l; i++) &#123; <span class="hljs-comment">// 这里需要使用 == 号</span><br>        <span class="hljs-built_in">string</span> ts = str.substr(i, k);<br>        <span class="hljs-keyword">if</span> (isPrime(stoi(ts))) &#123;<br>            <span class="hljs-built_in">cout</span> &lt;&lt; ts &lt;&lt; <span class="hljs-built_in">endl</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;404\n&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><code>string</code>的<code>substr</code>方法使用<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="std::string::substr">[1]</span></a></sup></li></ul><p><code>string substr (size_t pos = 0, size_t len = npos) const;</code></p><p>该方法返回一个新的字符串</p><ul><li><code>stoi</code>方法使用 <sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="std::stoi">[2]</span></a></sup></li></ul><p>将字符串转化为数字</p><section class="footnotes"><h2>参考</h2><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="http://www.cplusplus.com/reference/string/string/substr/">std::string::substr</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="http://www.cplusplus.com/reference/string/stoi/?kw=stoi">std::stoi</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
      <tag>素数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1050 螺旋矩阵</title>
    <link href="/2021/01/22/1050-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/"/>
    <url>/2021/01/22/1050-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="1050-螺旋矩阵"><a href="#1050-螺旋矩阵" class="headerlink" title="1050 螺旋矩阵"></a>1050 螺旋矩阵</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/ObYCj4.png" alt="ObYCj4"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本题是一道按照给定条件打印对应的样式题目。</p><p>步骤</p><ol><li>找到满足条件的$m,n$</li></ol><p>根据题目可以知道，$m,n$是$N$的公约数，且$m$是不小于$\sqrt{N}$。所以从$\sqrt{N}$开始，找到$N % m == 0$的值，这样就找到了$m$。</p><ol start="2"><li>给输入序列从大到小排序</li><li>设置<code>top, bottom, left, right</code>四个边界，每次按照<strong>右，下，左，上</strong>的顺序输入，直到所有数字输入完成。</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">10001</span>;<br><span class="hljs-keyword">int</span> ans[MAX][MAX], a[MAX];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, m, N;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;N);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (N == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, a[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    sort(a, a+N, [](<span class="hljs-keyword">auto</span> a, <span class="hljs-keyword">auto</span> b) &#123;<span class="hljs-keyword">return</span> a &gt; b;&#125;);<br>    m = (<span class="hljs-keyword">int</span>)<span class="hljs-built_in">ceil</span>(<span class="hljs-built_in">sqrt</span>(N * <span class="hljs-number">1.0</span>));<br>    <span class="hljs-keyword">while</span> (N % m != <span class="hljs-number">0</span>) &#123;m++;&#125;<br>    n = N / m;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">1</span>, now = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> top = <span class="hljs-number">1</span>, bottom = m, left = <span class="hljs-number">1</span>, right = n;<br>    <span class="hljs-keyword">while</span> (now &lt; N) &#123;<br>        <span class="hljs-keyword">while</span> (now &lt; N &amp;&amp; j &lt; right) &#123;<br>            ans[i][j] = a[now++];<br>            j++;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (now &lt; N &amp;&amp; i &lt; bottom) &#123;<br>            ans[i][j] = a[now++];<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (now &lt; N &amp;&amp; j &gt; left) &#123;<br>            ans[i][j] = a[now++];<br>            j--;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (now &lt; N &amp;&amp; i &gt; top) &#123;<br>            ans[i][j] = a[now++];<br>            i--;<br>        &#125;<br>        top++, bottom--, left++, right--;<br>        i++,j++;<span class="hljs-comment">// 往角线方向移动</span><br>        <span class="hljs-keyword">if</span> (now == N - <span class="hljs-number">1</span>) &#123;<br>            ans[i][j] = a[now++];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ans[i][j]);<br>            <span class="hljs-keyword">if</span> (j &lt; n) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);&#125;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相似题目"><a href="#相似题目" class="headerlink" title="相似题目"></a>相似题目</h2><ul><li><a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805285812551680">1036 跟奥巴马一起编程</a></li><li><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805462535356416">1031 Hello World for U</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1057 Stack</title>
    <link href="/2021/01/22/1057-Stack/"/>
    <url>/2021/01/22/1057-Stack/</url>
    
    <content type="html"><![CDATA[<h1 id="1057-Stack"><a href="#1057-Stack" class="headerlink" title="1057 Stack"></a>1057 Stack</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/ZWtFjU.png" alt="ZWtFjU"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="分块思想"><a href="#分块思想" class="headerlink" title="分块思想"></a>分块思想</h3><p>给定一个序列，该序列随时可能进行添加和删除元素，实时查询该元素中第K大的值。</p><p>此处的分块思想，就是把<strong>有序元素划分若干块</strong>.</p><p>例如 ${1,2,3,4,5,6,7,8,9}$</p><p>按照$\sqrt{N}$的依据分组，这里$N$是指序列数量。在这里$N=9$。因此上面序列被划分为</p><ul><li>${1,2,3}$</li><li>${4,5,6}$</li><li>${7,8,9}$</li></ul><p>设置两个数组</p><ul><li><code>table[x]</code>表示<code>x</code>值的出现次数</li><li><code>block[x[</code>表示所属于<code>x</code>块出现的次数</li></ul><p>假如给定一个空序列<code>a = []</code>，我们插入一个数字$3$,这是需要将$3$所在的区块进行+1，同时对$3$这个元素的<code>table</code>中也+1.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">block[<span class="hljs-number">3</span> / <span class="hljs-number">3</span>]++; <span class="hljs-comment">// 后面3是分组的数量</span><br>table[<span class="hljs-number">3</span>]++; <span class="hljs-comment">// 3这个元素的数量+1</span><br></code></pre></td></tr></table></figure><p>有上面可以看到第$1$组中的元素多了一个。当我们要查询第$K$个元素的时候，就可以先去查找第$K$个元素在第几组，然后再到该组內找到第$K$个值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">K</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span> </span>&#123;<br><span class="hljs-keyword">int</span> blockIdx = <span class="hljs-number">0</span>, n = <span class="hljs-number">0</span>; <span class="hljs-comment">// blockIdx 表示当前查找第几组， n表示当前第n大的值</span><br><span class="hljs-keyword">while</span> (n + block[blockIdx] &lt; k) &#123;<br>n += block[blockIdx++]; <span class="hljs-comment">// 若当前组还没找到第K大的值，n直接+上当前的值</span><br>&#125;<br><span class="hljs-keyword">int</span> tableIdx = blockIdx * blockNum; <span class="hljs-comment">// 找到blockIdx组內存在第K大的值。</span><br><span class="hljs-keyword">while</span> (n + table[tableIdx] &lt; k) &#123;<br>n += table[tableIdx++]; <span class="hljs-comment">//在第blockIdx组內继续找。</span><br>&#125;<br><span class="hljs-keyword">return</span> tableIdx; <span class="hljs-comment">// 最后这个下标既是第K大的值。</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><p>了解到分块思想后，下面这道题就简单了，需要注意如果是弹出一个元素，那么<code>block, table</code>中对应的块和值的数量需要-1.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">100010</span>;<br><span class="hljs-keyword">int</span> numBlock = <span class="hljs-number">316</span>;<br><span class="hljs-keyword">int</span> table[MAX] = &#123;<span class="hljs-number">0</span>&#125;, block[<span class="hljs-number">316</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; st;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>    st.push(val);<br>    table[val]++; <span class="hljs-comment">// val值+1</span><br>    block[val / numBlock]++; <span class="hljs-comment">// val所属区间+1</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Pop</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (st.empty()) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Invalid\n&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> val = st.top();<br>    st.pop();<br>    table[val]--;<br>    block[val / numBlock]--;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, val);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PeekMedian</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (st.empty()) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Invalid\n&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 开始去找第k大的值</span><br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, size = st.size(), num = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> mid = size &amp; <span class="hljs-number">1</span> ? (size + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> : size / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">while</span> (num + block[i] &lt; mid) &#123;<br>        num += block[i++];<br>    &#125;<br>    i = i * numBlock;<br>    <span class="hljs-keyword">while</span> (num + table[i] &lt; mid) &#123;<br>        num += table[i++];<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, i); <span class="hljs-comment">// i是第 k大的值</span><br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, val;<br>    <span class="hljs-built_in">string</span> op;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; op;<br>        <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&quot;Push&quot;</span>) &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; val;<br>            Push(val);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&quot;Pop&quot;</span>) &#123;<br>            Pop();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&quot;PeekMedian&quot;</span>) &#123;<br>            PeekMedian();<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
      <tag>分块思想</tag>
      
      <tag>堆</tag>
      
      <tag>stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>989. 数组形式的整数加法</title>
    <link href="/2021/01/22/989-%E6%95%B0%E7%BB%84%E5%BD%A2%E5%BC%8F%E7%9A%84%E6%95%B4%E6%95%B0%E5%8A%A0%E6%B3%95/"/>
    <url>/2021/01/22/989-%E6%95%B0%E7%BB%84%E5%BD%A2%E5%BC%8F%E7%9A%84%E6%95%B4%E6%95%B0%E5%8A%A0%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="989-数组形式的整数加法"><a href="#989-数组形式的整数加法" class="headerlink" title="989. 数组形式的整数加法"></a><a href="https://leetcode-cn.com/problems/add-to-array-form-of-integer/">989. 数组形式的整数加法</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/aBM7Pe.png" alt="aBM7Pe"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>方法一：按照最低位，逐渐往上加。然后把进位放到<code>K</code>上面。</li><li>方法二：参考<a href="https://leetcode-cn.com/problems/add-to-array-form-of-integer/solution/shu-zu-xing-shi-de-zheng-shu-jia-fa-by-l-jljp/">官方题解二</a>。将K加载数组的最低位，例如</li></ul><p>$123+912$，我们把它表示成 $[1,2,3+912]$。然后，我们计算 $3+912=915$。$5$ 留在当前这一位，将 $910/10=91$ 以进位的形式加入下一位。</p><p>然后，我们再重复这个过程，计算 $[1,2+91,5]$。我们得到 $93$，$3$ 留在当前位，将 $90/10=9$ 以进位的形式加入下一位。继而又得到 $[1+9,3,5]$，重复这个过程之后，最终得到结果 $[1,0,3,5]$。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>方法一</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">addToArrayForm</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; A, <span class="hljs-keyword">int</span> K)</span> </span>&#123;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans;<br>        <span class="hljs-keyword">int</span> n = A.size();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123; <span class="hljs-comment">// 从地位往高位计算，同时将进位的1加到K上面</span><br>            <span class="hljs-keyword">int</span> sum = A[i] + K % <span class="hljs-number">10</span>; <span class="hljs-comment">// 最后一位相加</span><br>            K /= <span class="hljs-number">10</span>; <span class="hljs-comment">// K的最后一位计算完成</span><br>            <span class="hljs-keyword">if</span> (sum &gt;= <span class="hljs-number">10</span>) &#123; <span class="hljs-comment">// 判断是否存在进位</span><br>                K += <span class="hljs-number">1</span>; <span class="hljs-comment">// 进位则在K上面+1</span><br>                sum -= <span class="hljs-number">10</span>;<br>            &#125;<br>            ans.push_back(sum);<br>        &#125;<br>        <span class="hljs-keyword">while</span> (K &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 计算剩余的结果</span><br>            ans.push_back(K % <span class="hljs-number">10</span>);<br>            K /= <span class="hljs-number">10</span>;<br>        &#125;<br>        reverse(ans.begin(), ans.end());<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>方法二</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">addToArrayForm</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; A, <span class="hljs-keyword">int</span> K)</span> </span>&#123;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans;<br>        <span class="hljs-keyword">int</span> n = A.size();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> || K &gt; <span class="hljs-number">0</span>; i--, K /= <span class="hljs-number">10</span>) &#123; <span class="hljs-comment">// 从地位往高位计算，同时将最低位加到K上面</span><br>            <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span>) &#123;<br>                K += A[i];<br>            &#125;<br>            ans.push_back(K % <span class="hljs-number">10</span>);<br>        &#125;<br>        reverse(ans.begin(), ans.end());<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>算法</tag>
      
      <tag>leetcode</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆</title>
    <link href="/2021/01/21/%E5%A0%86/"/>
    <url>/2021/01/21/%E5%A0%86/</url>
    
    <content type="html"><![CDATA[<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p><strong>堆是完全二叉树</strong></p><p>既然是完全二叉树，那么可以使用数组对完全二叉树进行描述</p><p><code>i</code>表示当前结点，<code>2i</code>表示左子结点，<code>2i + 1</code>表示右子结点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> MAX = <span class="hljs-number">10010</span>;<br><span class="hljs-keyword">int</span> heap[MAX], n; <span class="hljs-comment">// 堆，元素个数</span><br></code></pre></td></tr></table></figure><h2 id="创建堆"><a href="#创建堆" class="headerlink" title="创建堆"></a>创建堆</h2><p>建堆过程中，每次都要向下进行调整。若当前结点比子结点小，则和子结点进行交换，交换后继续和子结点进行比较，直至当前结点大于子结点或不存在子结点了。向下调整的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">downAdjust</span><span class="hljs-params">(<span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123; <span class="hljs-comment">// low: 当前结点。 high: 堆的最后一个结点</span><br><span class="hljs-keyword">int</span> i = low, j = low * <span class="hljs-number">2</span>; <span class="hljs-comment">// j表示左子结点</span><br><span class="hljs-keyword">while</span> (j &lt;= high) &#123;<br><span class="hljs-comment">// 找出左右子结点中值最大的结点下标。</span><br><span class="hljs-keyword">if</span> (j + <span class="hljs-number">1</span> &lt; high &amp;&amp; heap[j + <span class="hljs-number">1</span>] &gt; heap[j]) &#123; <span class="hljs-comment">// 右结点存在 &amp;&amp; 右结点大于左结点</span><br>j = j + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">// 和根结点进行比较</span><br><span class="hljs-keyword">if</span> (heap[i] &lt; heap[j]) &#123; <span class="hljs-comment">// 小于子结点</span><br>swap(heap[i], heap[j]); <span class="hljs-comment">// 交换</span><br>i = j; <span class="hljs-comment">// 交换后，i移动到新的位置。继续和子结点比较</span><br>j = i * <span class="hljs-number">2</span>; <span class="hljs-comment">// j 移动到i的新子结点</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">break</span>; <span class="hljs-comment">// 若i结点大于子结点，则不需要移动。</span><br>&#125;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>接下来就是建立一个堆了。对于一个大小为$n$的堆，它的叶子结点数量是$|n/2|$。因为叶子结点不需要调整顺序，因此需要调整顺序的结点范围在$1 \sim n/2$。于是可以从$n/2$开始倒着遍历，为什么倒着遍历呢？因为每次调整都可以保证根结点都变成了最大值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createHeap</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n / <span class="hljs-number">2</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>downAdjust(i, n);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="删除堆顶元素"><a href="#删除堆顶元素" class="headerlink" title="删除堆顶元素"></a>删除堆顶元素</h2><p>删除堆顶元素，只需要将最后一个值覆盖堆顶元素，由于此时堆顶元素不是最大值，因此只需要对堆顶元素进行调整即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deleteTop</span><span class="hljs-params">()</span> </span>&#123;<br>heap[<span class="hljs-number">1</span>] = heap[n--]; <span class="hljs-comment">// 元素n-1</span><br>downAdjust(<span class="hljs-number">1</span>, n);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="在堆中添加元素"><a href="#在堆中添加元素" class="headerlink" title="在堆中添加元素"></a>在堆中添加元素</h2><p>在堆中添加元素，需要把元素加到最后面，然后进行向上调整，把自己和父结点对比。若权值大于父结点，则与其交换，直到到达堆顶或者结点权值小于父结点停止。</p><p>下面是向上调整代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">upAdjust</span><span class="hljs-params">(<span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;<br><span class="hljs-keyword">int</span> i = high, j = i / <span class="hljs-number">2</span>; <span class="hljs-comment">// j为i的父结点</span><br><span class="hljs-keyword">while</span> (j &gt;= low) &#123;<br><span class="hljs-keyword">if</span> (heap[i] &gt; heap[j]) &#123;<br>swap(heap[i], heap[j]);<br>i = j;<br>j = j / <span class="hljs-number">2</span>; <span class="hljs-comment">// 找当上一个父结点</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">break</span>; <span class="hljs-comment">// 权值小于父结点，不替换</span><br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>heap[++n] = x;<br>upAdjust(<span class="hljs-number">1</span>, n);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
      <tag>堆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1098 Insertion or Heap Sort</title>
    <link href="/2021/01/21/1098-Insertion-or-Heap-Sort/"/>
    <url>/2021/01/21/1098-Insertion-or-Heap-Sort/</url>
    
    <content type="html"><![CDATA[<h1 id="1098-Insertion-or-Heap-Sort"><a href="#1098-Insertion-or-Heap-Sort" class="headerlink" title="1098 Insertion or Heap Sort"></a>1098 Insertion or Heap Sort</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/KmXTsV.png" alt="KmXTsV"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本题和<a href=""></a>类似,都是要通过</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">10010</span>;<br><span class="hljs-keyword">int</span> origin[MAX], temp[MAX], ans[MAX], change[MAX];<br><span class="hljs-keyword">int</span> n;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSame</span><span class="hljs-params">(<span class="hljs-keyword">int</span> A[], <span class="hljs-keyword">int</span> B[])</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (A[i] != B[i]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">insertSort</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (i != <span class="hljs-number">2</span> &amp;&amp; isSame(temp, change)) &#123; flag = <span class="hljs-literal">true</span>; &#125;<br>        sort(temp, temp + i + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (flag) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125; <span class="hljs-comment">// 已经是找到了目标数组</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">showArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[])</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, arr[i]);<br>        <span class="hljs-keyword">if</span> (i &lt; n) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">downAdjust</span><span class="hljs-params">(<span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123; <span class="hljs-comment">// high最后一个结点</span><br>    <span class="hljs-keyword">int</span> i = low, j = i * <span class="hljs-number">2</span>; <span class="hljs-comment">// i为当前正要调整结点, j为左孩子结点</span><br>    <span class="hljs-keyword">while</span> (j &lt;= high) &#123;<br>        <span class="hljs-keyword">if</span> (j + <span class="hljs-number">1</span> &lt;= high &amp;&amp; temp[j] &lt; temp[j + <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 找到左右最大的结点，去和待调整点比较</span><br>            j = j + <span class="hljs-number">1</span>; <span class="hljs-comment">// j存储右边孩子结点</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (temp[j] &gt; temp[i]) &#123;<br>            swap(temp[i], temp[j]);<br>            i = j; <span class="hljs-comment">// 同时移动根结点</span><br>            j = j*<span class="hljs-number">2</span>; <span class="hljs-comment">// j也进行移动</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 如果根结点大于子结点，不需要调整</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heapSort</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n / <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">1</span>; i--) &#123;<br>        downAdjust(i, n);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n; i &gt; <span class="hljs-number">1</span>; i--) &#123;<br>        <span class="hljs-keyword">if</span> (i != n &amp;&amp; isSame(temp, change)) &#123;<br>            flag = <span class="hljs-literal">true</span>;<br>        &#125;<br>        swap(temp[i], temp[<span class="hljs-number">1</span>]);<br>        downAdjust(<span class="hljs-number">1</span>, i - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (flag) &#123;<br>            showArray(temp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;origin[i]);<br>        temp[i] = origin[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;change[i]);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (insertSort()) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Insertion Sort\n&quot;</span>);<br>        showArray(temp);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Heap Sort\n&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;temp[i] = origin[i];&#125;<br>        heapSort();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
      <tag>堆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1489. 找到最小生成树里的关键边和伪关键边</title>
    <link href="/2021/01/21/1489-%E6%89%BE%E5%88%B0%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E9%87%8C%E7%9A%84%E5%85%B3%E9%94%AE%E8%BE%B9%E5%92%8C%E4%BC%AA%E5%85%B3%E9%94%AE%E8%BE%B9/"/>
    <url>/2021/01/21/1489-%E6%89%BE%E5%88%B0%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E9%87%8C%E7%9A%84%E5%85%B3%E9%94%AE%E8%BE%B9%E5%92%8C%E4%BC%AA%E5%85%B3%E9%94%AE%E8%BE%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="1489-找到最小生成树里的关键边和伪关键边"><a href="#1489-找到最小生成树里的关键边和伪关键边" class="headerlink" title="1489. 找到最小生成树里的关键边和伪关键边"></a><a href="https://leetcode-cn.com/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/">1489. 找到最小生成树里的关键边和伪关键边</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/Yu4UTc.png" alt="Yu4UTc"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本题参考<a href="https://leetcode-cn.com/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/solution/zhao-dao-zui-xiao-sheng-cheng-shu-li-de-gu57q/">官方解答</a>，用简单的话来理解什么是关键边和伪关键边。</p><ul><li><strong>关键边</strong>: 当图中删除这条边的时候，无法形成最小生成树或是权值大于最小生成树的权值。所以<strong>删除这条边了影响生成最佳的最小生成树</strong></li><li><strong>伪关键边</strong>: 该边只出现在部分最小生成树中，不会出现在所有最小生成树中。</li></ul><p>根据上面可以得到，若改边是<strong>关键边</strong>，则就不需要判断它是不是<strong>伪关键边</strong>了，因为<strong>关键边</strong>一定出现在每个最小生成树中。所以可以对一条边先进行判断是否是关键边，若是，则不需要判断是伪关键边。若不是则需要判断是不是伪关键边。</p><p>步骤</p><ol><li>先使用<code>Kruskal</code>+<code>UnionFind</code>计算出最小生成树的权值<code>minWeight</code>.</li><li>在对每条边依次判断。</li><li>关键边，在并查集中不加入边，判断改变是否对最小生成树和权值有影响。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span> (i != j &amp;&amp; (uf.find(u) != uf.find(v)))<br></code></pre></td></tr></table></figure><ol start="4"><li>伪关键边，在判断完不是关键边后，把这条边作为第一条连接的边加入并查集中，然后去继续判断生成的树权值是否和<code>minWeight</code>相等，若相等，则证明该边在当前生成树中是有效的边，加入到伪关键边中。</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span> &#123;</span><br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; parent;<br>    <span class="hljs-keyword">int</span> num;<br>    <span class="hljs-keyword">public</span>:<br>    UnionFind(<span class="hljs-keyword">int</span> n) &#123;<br>        num = n;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) parent.push_back(i);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (x != parent[x]) &#123;<br>            parent[x] = find(parent[x]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> parent[x];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quick_union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> w)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> vRoot = find(v), wRoot = find(w);<br>        <span class="hljs-keyword">if</span> (vRoot == wRoot) <span class="hljs-keyword">return</span>;<br>        parent[find(v)] = find(w);<br>        num--;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 获取连通分量个数</span><br>        <span class="hljs-keyword">return</span> num;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">findCriticalAndPseudoCriticalEdges</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;<br>        <span class="hljs-comment">// 使用官方的思路</span><br>        <span class="hljs-comment">// 1. 先求出最小生成树的权值</span><br>        <span class="hljs-comment">// 2. 关键边，依次对每条边判断，若该边不存在，是否影响到权值</span><br>        <span class="hljs-comment">// 3. 非关键边，优先连接该边，若value相同，则证明该边不影响最终结果</span><br><br>        <span class="hljs-comment">// 0. 记录关键边的下标，因为题目要求返回的下标，等会按权值排序会打乱下标</span><br>        <span class="hljs-keyword">int</span> size = edges.size();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;edges[i].push_back(i);&#125;<br><br>        <span class="hljs-comment">// 1.1 对权边排序</span><br>        sort(edges.begin(), edges.end(), [](<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; a,<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; b) &#123;<br>            <span class="hljs-keyword">return</span> a[<span class="hljs-number">2</span>] &lt; b[<span class="hljs-number">2</span>];<br>        &#125;);<br>        <span class="hljs-comment">// 1.2 依次对权值最小边进行合并,并求出最小权值和</span><br>        <span class="hljs-function">UnionFind <span class="hljs-title">uf</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">int</span> minWeight = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            <span class="hljs-keyword">int</span> u = edges[i][<span class="hljs-number">0</span>], v = edges[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (uf.find(u) != uf.find(v)) &#123;<br>                uf.quick_union(u, v);<br>                minWeight += edges[i][<span class="hljs-number">2</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 2. 依次排除一条边，判断权值是否变化，若变大，则证明该边是关键边</span><br>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">ans</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            <span class="hljs-comment">// 2.1 找出关键边</span><br>            <span class="hljs-function">UnionFind <span class="hljs-title">uf</span><span class="hljs-params">(n)</span></span>;<br>            <span class="hljs-keyword">int</span> weight = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; size; j++) &#123;<br>                <span class="hljs-keyword">int</span> u = edges[j][<span class="hljs-number">0</span>], v = edges[j][<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span> (i != j &amp;&amp; (uf.find(u) != uf.find(v))) &#123;<br>                    uf.quick_union(u, v);<br>                    weight += edges[j][<span class="hljs-number">2</span>];<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 2.2 关键边去除是无法形成最小生成树的或形成了生成树，但是权值增大。</span><br>            <span class="hljs-keyword">if</span> (uf.getCount() != <span class="hljs-number">1</span> || (uf.getCount() == <span class="hljs-number">1</span> &amp;&amp; weight &gt; minWeight)) &#123;<br>                ans[<span class="hljs-number">0</span>].push_back(edges[i][<span class="hljs-number">3</span>]);<br>                <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 既然是关键边，那么肯定是非关键边。</span><br>            &#125;<br>            <span class="hljs-comment">// 2.2 找出非关键边。非关键去除也对最小权值没有影响。</span><br>            <span class="hljs-comment">// UnionFind uf(n); 这种写法错误，会导致重新定义</span><br>            uf = UnionFind(n);<br>            uf.quick_union(edges[i][<span class="hljs-number">0</span>], edges[i][<span class="hljs-number">1</span>]); <span class="hljs-comment">// 先连接改边，若改变对结果没有影响。那么他就是非关键边</span><br>            weight = edges[i][<span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; size; j++) &#123;<br>                <span class="hljs-keyword">int</span> u = edges[j][<span class="hljs-number">0</span>], v = edges[j][<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span> (i != j &amp;&amp; (uf.find(u) != uf.find(v))) &#123;<br>                    uf.quick_union(u, v);<br>                    weight += edges[j][<span class="hljs-number">2</span>];<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (weight == minWeight) &#123;<br>                ans[<span class="hljs-number">1</span>].push_back(edges[i][<span class="hljs-number">3</span>]); <span class="hljs-comment">// 把非关键边下标放进去</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>C++ iota函数用法详解<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="C++ iota函数用法详解">[1]</span></a></sup></li></ul><p>在官方题解中，看到在并查集中有这样的写法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">UnionFind(<span class="hljs-keyword">int</span> _n): n(_n), setCount(_n), parent(_n), size(_n, <span class="hljs-number">1</span>) &#123;<br>iota(parent.begin(), parent.end(), <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>定义在 numeric 头文件中的 iota() 函数模板会用连续的 T 类型值填充序列。</p><pre><code>- 前两个参数是定义序列的正向迭代器，第三个参数是初始的 T 值。- 第三个指定的值会被保存到序列的第一个元素中。保存在第一个元素后的值是通过对前面的值**运用自增运算符得到的**。当然，这意味着 T 类型必须支持 operator++()。</code></pre><p>下面展示了如何生成一个有连续的浮点值元素的 vector 容器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(<span class="hljs-number">9</span>)</span></span>;<br><span class="hljs-keyword">double</span> initial &#123;<span class="hljs-number">-4</span>&#125;;<br><span class="hljs-built_in">std</span>::iota (<span class="hljs-built_in">std</span>::begin (data) , <span class="hljs-built_in">std</span>::end (data) , initial);<br><span class="hljs-built_in">std</span>::copy(<span class="hljs-built_in">std</span>::begin(data), <span class="hljs-built_in">std</span>::end(data),<span class="hljs-built_in">std</span>::ostream_iterator&lt;<span class="hljs-keyword">double</span>&gt;&#123;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt; <span class="hljs-built_in">std</span>::fixed &lt;&lt; <span class="hljs-built_in">std</span>::setprecision(<span class="hljs-number">1</span>), <span class="hljs-string">&quot; &quot;</span>&#125;);<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// -4.0 -3.0 -2.0 -1.0 0.0 1.0 2.0 3.0 4.0</span><br></code></pre></td></tr></table></figure><ul><li>排序 sort vector，並使用 lambda function 匿名函式排序(升序)<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="">[2]</span></a></sup></li></ul><p>很多语言都要匿名函数，那么在C++中如何写呢？</p><p>这是本题的匿名函数在排序中使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">sort(edges.begin(), edges.end(), [](<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; a,<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; b) &#123;<br><span class="hljs-keyword">return</span> a[<span class="hljs-number">2</span>] &lt; b[<span class="hljs-number">2</span>];<br>&#125;);<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">std</span>::sort(v.begin(), v.end(), [](<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)&#123;<br><span class="hljs-keyword">return</span> a &lt; b; <span class="hljs-comment">// 升序排列</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>参考上面的两个例子，匿名函数的写法应该是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">sort(head_address，end_address，[](<span class="hljs-keyword">auto</span>&amp; a, <span class="hljs-keyword">auto</span>&amp; b) &#123;<br><span class="hljs-keyword">return</span> a &lt; b; <span class="hljs-comment">// a b 的一些比较</span><br>&#125;)<br></code></pre></td></tr></table></figure><section class="footnotes"><h2>参考</h2><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="http://c.biancheng.net/view/681.html">C++ iota函数用法详解</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://shengyu7697.github.io/blog/2019/11/30/std-sort/"></a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>union-find</tag>
      
      <tag>leetcode</tag>
      
      <tag>Kruskal</tag>
      
      <tag>最小生成树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1382. 将二叉搜索树变平衡</title>
    <link href="/2021/01/20/1382-%E5%B0%86%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%8F%98%E5%B9%B3%E8%A1%A1/"/>
    <url>/2021/01/20/1382-%E5%B0%86%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%8F%98%E5%B9%B3%E8%A1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="1382-将二叉搜索树变平衡"><a href="#1382-将二叉搜索树变平衡" class="headerlink" title="1382. 将二叉搜索树变平衡"></a><a href="https://leetcode-cn.com/problems/balance-a-binary-search-tree/">1382. 将二叉搜索树变平衡</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/9bWA3J.png" alt="9bWA3J"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>使用中序遍历将结点转化为递增顺序的数组。</li><li>对递增顺序的数组，采用递归的方式建立一个完全二叉树。（完全二叉树一定是平衡二叉树）</li><li>因为完全二叉树是一个静态的数组，因此还需要根据下面规则，对完全二叉树內的结点建立联系。<ul><li>索引$X$的左子树索引是$2X$，右子树索引是$2X + 1$</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, self.n + <span class="hljs-number">1</span>):<br><span class="hljs-keyword">if</span> i * <span class="hljs-number">2</span> &lt;= self.n: self.cbt[i].left = self.cbt[i * <span class="hljs-number">2</span>]<br><span class="hljs-keyword">else</span>: self.cbt[i].left = <span class="hljs-literal">None</span><br><span class="hljs-keyword">if</span> i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt;= self.n: self.cbt[i].right = self.cbt[i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>]<br><span class="hljs-keyword">else</span>: self.cbt[i].right = <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p>⚠️: 完全二叉树根结点的索引是$1$开始的。因此完全二叉树的数组大小是$结点数量+1$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode(object):</span><br><span class="hljs-comment">#     def __init__(self, x):</span><br><span class="hljs-comment">#         self.val = x</span><br><span class="hljs-comment">#         self.left = None</span><br><span class="hljs-comment">#         self.right = None</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inorder</span>(<span class="hljs-params">self, root</span>):</span><br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span><br>        self.inorder(root.left)<br>        self.ans.append(root)<br>        self.inorder(root.right)<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_cbt</span>(<span class="hljs-params">self, idx</span>):</span><br>        <span class="hljs-keyword">if</span> idx &gt; self.n: <span class="hljs-keyword">return</span><br>        self.create_cbt(idx * <span class="hljs-number">2</span>)<br>        self.cbt[idx].val = self.ans[self.num].val<br>        self.num += <span class="hljs-number">1</span><br>        self.create_cbt(idx * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>)<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">balanceBST</span>(<span class="hljs-params">self, root</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: TreeNode</span><br><span class="hljs-string">        :rtype: TreeNode</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br><br>        <span class="hljs-comment"># 1. 将搜索二叉树中序遍历，获取其递增序列</span><br>        self.ans = []<br>        self.inorder(root)<br>        <span class="hljs-comment"># 2. 创建完全二叉树数组</span><br>        self.n = <span class="hljs-built_in">len</span>(self.ans) <span class="hljs-comment"># 结点数量</span><br>        self.num = <span class="hljs-number">0</span> <span class="hljs-comment"># 当前递增序列遍历的结点</span><br>        self.cbt = [TreeNode(<span class="hljs-number">0</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.n + <span class="hljs-number">1</span>)] <span class="hljs-comment"># 静态的完全二叉树数组</span><br>        self.create_cbt(<span class="hljs-number">1</span>) <span class="hljs-comment"># 完全二叉树以1为根结点</span><br>        <span class="hljs-comment"># 3. 根据左子树索引:2x, 右子树索引:2x+1, 重建二叉树索引</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, self.n + <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> i * <span class="hljs-number">2</span> &lt;= self.n: self.cbt[i].left = self.cbt[i * <span class="hljs-number">2</span>]<br>            <span class="hljs-keyword">else</span>: self.cbt[i].left = <span class="hljs-literal">None</span><br>            <span class="hljs-keyword">if</span> i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt;= self.n: self.cbt[i].right = self.cbt[i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>]<br>            <span class="hljs-keyword">else</span>: self.cbt[i].right = <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">return</span> self.cbt[<span class="hljs-number">1</span>]<br><br></code></pre></td></tr></table></figure><p>C++实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; inorder;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">balanceBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        midtravel(root);<br>        <span class="hljs-keyword">return</span> create(<span class="hljs-number">0</span>, inorder.size() - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">create</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (left &gt; right) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="hljs-number">1</span>);<br>        TreeNode* root = <span class="hljs-keyword">new</span> TreeNode(inorder[mid]);<br>        root-&gt;left = create(left, mid - <span class="hljs-number">1</span>);<br>        root-&gt;right = create(mid + <span class="hljs-number">1</span>,right);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">midtravel</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span>;<br>        midtravel(root-&gt;left);<br>        inorder.push_back(root-&gt;val);<br>        midtravel(root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>leetcode</tag>
      
      <tag>完全二叉树</tag>
      
      <tag>二叉搜索树</tag>
      
      <tag>平衡二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1066 Root of AVL Tree</title>
    <link href="/2021/01/20/1066-Root-of-AVL-Tree/"/>
    <url>/2021/01/20/1066-Root-of-AVL-Tree/</url>
    
    <content type="html"><![CDATA[<h1 id="1066-Root-of-AVL-Tree"><a href="#1066-Root-of-AVL-Tree" class="headerlink" title="1066 Root of AVL Tree"></a>1066 Root of AVL Tree</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/yfKAnA.png" alt="yfKAnA"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><div class="note note-warning">            <p>平衡二叉树的平衡因子特性应用。</p>          </div><p>本题目的是建立一颗平衡二叉树。比较难，记住下面结论。通过下面结论来进行编程</p><ul><li>平衡二叉树为了平衡，需要进行<strong>左旋转</strong>，<strong>右旋转</strong>两个操作。那么如何该选择是否需要选择操作？（使用平衡因子）</li><li>平衡因子是左右子树的高度差值。如下图所示，图中结点上的值为平衡因子。</li></ul><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/d0NKih.png" alt="d0NKih"></p><ul><li>若平衡因子出现大于$|1|$，则出现问题，需要进行调整。那么调整会出现4种情况。</li></ul><ol><li><p>$LL$和$LR$<br><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/ZmTYVu.png" alt="ZmTYVu"></p><ul><li>$LL$类型只需要绕着根结点进行<strong>左旋转</strong>即可平衡。<br><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/MpUjsi.png" alt="MpUjsi"></li><li>$LR$类型需要先将$root-&gt;left$作为结点，然后进行<strong>右旋转</strong>，将树转化为$LL$类型，再<strong>左旋转即可</strong>。<br><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/DcLVBG.png" alt="DcLVBG"></li></ul></li><li><p>$RR$和$RL$</p></li></ol><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/UVFCj0.png" alt="UVFCj0"></p><pre><code>这种类型的和$LL$,$LR$的类似，只需要将上面操作反过来。</code></pre><ul><li><p>所以根据上面给出的类型，在每次插入的时候都去判断当前插入后的平衡因子变化。再判断属于上述四种的哪一类。分别进行相应的旋转。</p></li><li><p>插入操作就是在之前的二叉搜索树上增加了旋转操作的处理。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(TreeNode* &amp;root, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) &#123;<br>        root = newNode(val);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (root-&gt;val &gt; val) &#123; <span class="hljs-comment">// 插入到左边</span><br>        insert(root-&gt;left, val);<br>        updateHeight(root); <span class="hljs-comment">// 插入后看看树的高度是否满足要求</span><br>        <span class="hljs-comment">// 开始处理平衡问题</span><br>        <span class="hljs-keyword">if</span> (getBalanceFactor(root) == <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">if</span> (getBalanceFactor(root-&gt;left) == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// LL</span><br>                R(root);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (getBalanceFactor(root-&gt;left) == <span class="hljs-number">-1</span>) &#123; <span class="hljs-comment">// LR</span><br>                L(root-&gt;left);<br>                R(root);<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        insert(root-&gt;right, val);<br>        updateHeight(root);<br>        <span class="hljs-keyword">if</span> (getBalanceFactor(root) == <span class="hljs-number">-2</span>) &#123;<br>            <span class="hljs-keyword">if</span> (getBalanceFactor(root-&gt;right) == <span class="hljs-number">-1</span>) &#123;<br>                L(root);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (getBalanceFactor(root-&gt;right) == <span class="hljs-number">1</span>) &#123;<br>                R(root-&gt;right);<br>                L(root);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span> &#123;</span><br>    <span class="hljs-keyword">int</span> val, height;<br>    TreeNode *left, *right;<br>&#125; *root;<br><br><span class="hljs-function">TreeNode* <span class="hljs-title">newNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>    TreeNode *node = <span class="hljs-keyword">new</span> TreeNode;<br>    node-&gt;val = val;<br>    node-&gt;height = <span class="hljs-number">1</span>;<br>    node-&gt;left = node-&gt;right = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getHeight</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> root-&gt;height;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">updateHeight</span><span class="hljs-params">(TreeNode* &amp;root)</span> </span>&#123;<br>    root-&gt;height = max(getHeight(root-&gt;left), getHeight(root-&gt;right)) + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getBalanceFactor</span><span class="hljs-params">(TreeNode* &amp;root)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> getHeight(root-&gt;left) - getHeight(root-&gt;right);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">R</span><span class="hljs-params">(TreeNode* &amp;root)</span> </span>&#123;<br>    TreeNode* temp = root-&gt;left;<br>    root-&gt;left = temp-&gt;right;<br>    temp-&gt;right = root;<br>    updateHeight(root);<br>    updateHeight(temp);<br>    root = temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">L</span><span class="hljs-params">(TreeNode* &amp;root)</span> </span>&#123;<br>    TreeNode* temp = root-&gt;right;<br>    root-&gt;right = temp-&gt;left;<br>    temp-&gt;left = root;<br>    updateHeight(root);<br>    updateHeight(temp);<br>    root = temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(TreeNode* &amp;root, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) &#123;<br>        root = newNode(val);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (root-&gt;val &gt; val) &#123; <span class="hljs-comment">// 插入到左边</span><br>        insert(root-&gt;left, val);<br>        updateHeight(root); <span class="hljs-comment">// 插入后看看树的高度是否满足要求</span><br>        <span class="hljs-comment">// 开始处理平衡问题</span><br>        <span class="hljs-keyword">if</span> (getBalanceFactor(root) == <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">if</span> (getBalanceFactor(root-&gt;left) == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// LL</span><br>                R(root);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (getBalanceFactor(root-&gt;left) == <span class="hljs-number">-1</span>) &#123; <span class="hljs-comment">// LR</span><br>                L(root-&gt;left);<br>                R(root);<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        insert(root-&gt;right, val);<br>        updateHeight(root);<br>        <span class="hljs-keyword">if</span> (getBalanceFactor(root) == <span class="hljs-number">-2</span>) &#123;<br>            <span class="hljs-keyword">if</span> (getBalanceFactor(root-&gt;right) == <span class="hljs-number">-1</span>) &#123;<br>                L(root);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (getBalanceFactor(root-&gt;right) == <span class="hljs-number">1</span>) &#123;<br>                R(root-&gt;right);<br>                L(root);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, val;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;val);<br>        insert(root, val);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, root-&gt;val);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>平衡二叉树建立模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span> &#123;</span><br>    <span class="hljs-keyword">int</span> val;<br>    TreeNode *left, *right;<br>&#125; *root;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">R</span><span class="hljs-params">(TreeNode* &amp;root)</span> </span>&#123;<br>    TreeNode* temp = root-&gt;left;<br>    root-&gt;left = temp-&gt;right;<br>    temp-&gt;right = root;<br>    root = temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">L</span><span class="hljs-params">(TreeNode* &amp;root)</span> </span>&#123;<br>    TreeNode* temp = root-&gt;right;<br>    root-&gt;right = temp-&gt;left;<br>    temp-&gt;left = root;<br>    root = temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getHeight</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> max(getHeight(root-&gt;left), getHeight(root-&gt;right)) + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(TreeNode* &amp;root, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) &#123;<br>        root = <span class="hljs-keyword">new</span> TreeNode;<br>        root-&gt;val = val;<br>        root-&gt;left = root-&gt;right = <span class="hljs-literal">NULL</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root-&gt;val &gt; val) &#123; <span class="hljs-comment">// 左子树</span><br>        insert(root-&gt;left, val);<br>        <span class="hljs-keyword">int</span> l = getHeight(root-&gt;left), r = getHeight(root-&gt;right);<br>        <span class="hljs-keyword">if</span> (l - r == <span class="hljs-number">2</span>) &#123; <span class="hljs-comment">// l</span><br>            <span class="hljs-keyword">if</span> (root-&gt;left-&gt;val &lt; val) &#123; <span class="hljs-comment">// LR 新的结点被插入左边结点的右子树</span><br>                L(root-&gt;left);<br>            &#125;<br>            R(root);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        insert(root-&gt;right,val);<br>        <span class="hljs-keyword">int</span> l = getHeight(root-&gt;left), r = getHeight(root-&gt;right);<br>        <span class="hljs-keyword">if</span> (l - r == <span class="hljs-number">-2</span>) &#123; <span class="hljs-comment">// R</span><br>            <span class="hljs-keyword">if</span> (root-&gt;right-&gt;val &gt; val) &#123; <span class="hljs-comment">// RL 新的结点插入到右子树的左边</span><br>                R(root-&gt;right);<br>            &#125;<br>            L(root);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, val;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;val);<br>        insert(root, val);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, root-&gt;val);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="平衡二叉树建立模板"><a href="#平衡二叉树建立模板" class="headerlink" title="平衡二叉树建立模板"></a>平衡二叉树建立模板</h2><p>记住下面关键几点</p><ul><li>一个获取高度的函数</li><li>两个旋转函数R,L</li><li>四种树形结构<ul><li>LL: 根结点R</li><li>LR: 根结点左子树L,根结点R</li><li>RR: 根结点L</li><li>RL: 根结点右子树R,根结点L</li></ul></li><li>判断当前结点属于上面哪种树形结构<ul><li>LL: getH(root-&gt;left) - getH(root-&gt;right) == 2</li><li>LR: getH(root-&gt;left) - getH(root-&gt;right) == 2 &amp;&amp; root-&gt;left-&gt;val &lt; val</li><li>RR: getH(root-&gt;left) - getH(root-&gt;right) == -2</li><li>RL: getH(root-&gt;left) - getH(root-&gt;right) == -2 &amp;&amp; root-&gt;right-&gt;val &gt; val</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span> &#123;</span><br>    <span class="hljs-keyword">int</span> val;<br>    TreeNode *left, *right;<br>&#125; *root;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">R</span><span class="hljs-params">(TreeNode* &amp;root)</span> </span>&#123;<br>    TreeNode* temp = root-&gt;left;<br>    root-&gt;left = temp-&gt;right;<br>    temp-&gt;right = root;<br>    root = temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">L</span><span class="hljs-params">(TreeNode* &amp;root)</span> </span>&#123;<br>    TreeNode* temp = root-&gt;right;<br>    root-&gt;right = temp-&gt;left;<br>    temp-&gt;left = root;<br>    root = temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getHeight</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> max(getHeight(root-&gt;left), getHeight(root-&gt;right)) + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(TreeNode* &amp;root, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) &#123;<br>        root = <span class="hljs-keyword">new</span> TreeNode;<br>        root-&gt;val = val;<br>        root-&gt;left = root-&gt;right = <span class="hljs-literal">NULL</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root-&gt;val &gt; val) &#123; <span class="hljs-comment">// 左子树</span><br>        insert(root-&gt;left, val);<br>        <span class="hljs-keyword">int</span> l = getHeight(root-&gt;left), r = getHeight(root-&gt;right);<br>        <span class="hljs-keyword">if</span> (l - r == <span class="hljs-number">2</span>) &#123; <span class="hljs-comment">// l</span><br>            <span class="hljs-keyword">if</span> (root-&gt;left-&gt;val &lt; val) &#123; <span class="hljs-comment">// LR 新的结点被插入左边结点的右子树</span><br>                L(root-&gt;left);<br>            &#125;<br>            R(root);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        insert(root-&gt;right,val);<br>        <span class="hljs-keyword">int</span> l = getHeight(root-&gt;left), r = getHeight(root-&gt;right);<br>        <span class="hljs-keyword">if</span> (l - r == <span class="hljs-number">-2</span>) &#123; <span class="hljs-comment">// R</span><br>            <span class="hljs-keyword">if</span> (root-&gt;right-&gt;val &gt; val) &#123; <span class="hljs-comment">// RL 新的结点插入到右子树的左边</span><br>                R(root-&gt;right);<br>            &#125;<br>            L(root);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, val;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;val);<br>        insert(root, val);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, root-&gt;val);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
      <tag>AVL</tag>
      
      <tag>二叉搜索树</tag>
      
      <tag>平衡二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1099 Build A Binary Search Tree</title>
    <link href="/2021/01/20/1099-Build-A-Binary-Search-Tree/"/>
    <url>/2021/01/20/1099-Build-A-Binary-Search-Tree/</url>
    
    <content type="html"><![CDATA[<h1 id="1099-Build-A-Binary-Search-Tree"><a href="#1099-Build-A-Binary-Search-Tree" class="headerlink" title="1099 Build A Binary Search Tree"></a>1099 Build A Binary Search Tree</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/XBryb4.png" alt="XBryb4"></p><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><div class="note note-warning">            <p>二叉查找树的重要性质之一：中序遍历是一个递增序列。</p>          </div><p>本题目标是<strong>给定一个二叉搜索树的结构，然后在给出一组序列。根据二叉查找树的性质，将该组序列填充到给定的二叉树中。</strong></p><p>本题和<a href="https://emhui.fun/2021/01/20/1064-Complete-Binary-Search-Tree/">1064 Complete Binary Search Tree</a>类似，也是去填充一个空白的二叉树。因此可以考虑将给定序列进行排序，然后对二叉树进行中序遍历，把排序好的序列依次填充进去。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-comment">// 思路，使用静态二叉树先构建二叉树。</span><br><span class="hljs-comment">// 对输入序列排序</span><br><span class="hljs-comment">// 对构建好的二叉树进行中序遍历，把排好序的序列赋值</span><br><span class="hljs-comment">// 最后使用BFS进行层次遍历</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">101</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>&#123;</span><br>    <span class="hljs-keyword">int</span> val;<br>    <span class="hljs-keyword">int</span> left, right;<br>&#125;treenode[MAX];<br><br><span class="hljs-keyword">int</span> arr[MAX], num = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> node)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    dfs(treenode[node].left);<br>    treenode[node].val = arr[num++];<br>    dfs(treenode[node].right);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> node)</span> </span>&#123;<br>    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q;<br>    q.push(node);<br>    <span class="hljs-keyword">while</span> (!q.empty()) &#123;<br>        <span class="hljs-keyword">int</span> size = q.size();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            <span class="hljs-keyword">int</span> node = q.front();<br>            q.pop();<br>            ans.push_back(node);<br>            <span class="hljs-keyword">if</span> (treenode[node].left != <span class="hljs-number">-1</span>) q.push(treenode[node].left);<br>            <span class="hljs-keyword">if</span> (treenode[node].right != <span class="hljs-number">-1</span>) q.push(treenode[node].right);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;treenode[i].left, &amp;treenode[i].right);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;arr[i]);<br>    &#125;<br>    sort(arr, arr + n);<br>    dfs(<span class="hljs-number">0</span>);<br>    bfs(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, treenode[ans[i]].val);<br>        <span class="hljs-keyword">if</span> (i &lt; n - <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
      <tag>二叉查找树， bst</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1064 Complete Binary Search Tree</title>
    <link href="/2021/01/20/1064-Complete-Binary-Search-Tree/"/>
    <url>/2021/01/20/1064-Complete-Binary-Search-Tree/</url>
    
    <content type="html"><![CDATA[<h1 id="1064-Complete-Binary-Search-Tree"><a href="#1064-Complete-Binary-Search-Tree" class="headerlink" title="1064 Complete Binary Search Tree"></a>1064 Complete Binary Search Tree</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/doKWdq.png" alt="doKWdq"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>用数组表示一个完全二叉树，假设某个结点编号为$x$(根结点的编号一定是1),那它具有下面性质</p><ul><li>x的左孩子编号是$2x$</li><li>x的右孩子编号是$2x+1$</li></ul><p>对于一个二叉搜索树来说，中序遍历该是该树结点的递增序列。</p><p>因此可以建立一个空的完全二叉树，同时对输入的序列进行由小到大，然后中序遍历该完全二叉树，同时把排好序的序列依次填入该完全二叉树中。</p><p>完全二叉树本身是按照层次遍历排序的。所以最后只要按序输出。</p><p>⚠️ 完全二叉树的根结点是从1开始。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">10010</span>;<br><span class="hljs-keyword">int</span> a[MAX], cbt[MAX];<br><span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>, n;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (x &gt; n) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    inorder(x * <span class="hljs-number">2</span>);<br>    cbt[x] = a[num++];<br>    inorder(x * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br>    &#125;<br>    sort(a, a+n);<br>    inorder(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, cbt[i]);<br>        <span class="hljs-keyword">if</span> (i &lt; n) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
      <tag>完全二叉树</tag>
      
      <tag>二叉查找树</tag>
      
      <tag>bst</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1087 All Roads Lead to Rome</title>
    <link href="/2021/01/20/1087-All-Roads-Lead-to-Rome/"/>
    <url>/2021/01/20/1087-All-Roads-Lead-to-Rome/</url>
    
    <content type="html"><![CDATA[<h1 id="1087-All-Roads-Lead-to-Rome"><a href="#1087-All-Roads-Lead-to-Rome" class="headerlink" title="1087 All Roads Lead to Rome"></a>1087 All Roads Lead to Rome</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本题和<a href="https://emhui.fun/2021/01/19/1018-Public-Bike-Management/">1018 Public Bike Management</a>思路基本一致。通过<code>Dijkstra</code>+<code>DFS</code>结合。</p><ul><li><code>Dijkstra</code>: 计算出起点到目标点的所有最短路径，使用<code>pre</code>存储。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span> </span>&#123;<br>    fill(dis, dis + MAX, INF);<br>    dis[s] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">int</span> u = <span class="hljs-number">-1</span>, MIN = INF;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (!visited[j] &amp;&amp; dis[j] &lt; MIN) &#123;<br>                u = j;<br>                MIN = dis[j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (u == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span>;<br>        visited[u] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v = <span class="hljs-number">0</span>; v &lt; n; v++) &#123; <span class="hljs-comment">// 优化u-v</span><br>            <span class="hljs-keyword">if</span> (!visited[v] &amp;&amp; G[u][v] != INF) &#123;<br>                <span class="hljs-keyword">if</span> (dis[u] + G[u][v] &lt; dis[v]) &#123;<br>                    dis[v] = dis[u] + G[u][v];<br>                    pre[v].clear();<br>                    pre[v].push_back(u);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dis[u] + G[u][v] == dis[v]) &#123;<br>                    pre[v].push_back(u);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>DFS</code>: 使用<code>dfs</code>对<code>pre</code>进行遍历，该操作是逆序的，从目标到起点。所以临界条件是到达起点。然后计算出最大幸福值，平均幸福值等。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>&#123; <span class="hljs-comment">// 从终点去开始找起点</span><br>    <span class="hljs-keyword">if</span> (v == city2id[startCity]) &#123; <span class="hljs-comment">// 临界条件</span><br>        leastNum++;<br>        tempPath.push_back(v);<br>        <span class="hljs-keyword">int</span> size = tempPath.size();<br>        <span class="hljs-keyword">int</span> maxHappy = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">double</span> avgHappy = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) <span class="hljs-comment">// startcity的happy是0，因为path是倒序，所以最后一个是起点</span><br>        &#123;<br>            maxHappy += happines[tempPath[i]];<br>        &#125;<br>        avgHappy = <span class="hljs-number">1.0</span> * maxHappy / (size - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (maxHappy &gt; ansHappy) &#123;<br>            ansHappy = maxHappy;<br>            ansAvgHappy = avgHappy;<br>            path = tempPath;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (maxHappy == ansHappy &amp;&amp; ansAvgHappy &lt; avgHappy) &#123;<br>            ansAvgHappy = avgHappy;<br>            path = tempPath;<br>        &#125;<br>        tempPath.pop_back();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    tempPath.push_back(v);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; pre[v].size(); i++) &#123;<br>        DFS(pre[v][i]);<br>    &#125;<br>    tempPath.pop_back();<br>&#125;<br></code></pre></td></tr></table></figure><p>⚠️</p><ul><li>本题需要注意将<code>城市名</code>和<code>ID</code>建立映射，这里使用两个<code>map</code>.</li><li>存储最短路径的路线<code>pre</code>是倒序输出。最后答案也要倒序输出</li><li>起始点没有幸福值，因此在计算平均幸福值的时候，经过的城市数量应该-1.</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-comment">// 分析</span><br><span class="hljs-comment">// Dijkstra 求出最短路径的条数</span><br><span class="hljs-comment">// 再使用DFS求出最大的happines和avehappines</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">210</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">987654321</span>;<br><br><span class="hljs-keyword">int</span> G[MAX][MAX], dis[MAX], happines[MAX];<br><span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt; city2id;<br><span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">string</span>&gt; id2city;<br><span class="hljs-keyword">int</span> numCity = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">bool</span> visited[MAX] = &#123;<span class="hljs-literal">false</span>&#125;;<br><span class="hljs-keyword">int</span> n, k;<br><span class="hljs-built_in">string</span> startCity;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; tempPath, path;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; pre[MAX];<br><span class="hljs-keyword">int</span> ansHappy = <span class="hljs-number">-1</span>, leastNum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">double</span> ansAvgHappy = <span class="hljs-number">-1</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span> </span>&#123;<br>    fill(dis, dis + MAX, INF);<br>    dis[s] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">int</span> u = <span class="hljs-number">-1</span>, MIN = INF;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (!visited[j] &amp;&amp; dis[j] &lt; MIN) &#123;<br>                u = j;<br>                MIN = dis[j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (u == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span>;<br>        visited[u] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v = <span class="hljs-number">0</span>; v &lt; n; v++) &#123; <span class="hljs-comment">// 优化u-v</span><br>            <span class="hljs-keyword">if</span> (!visited[v] &amp;&amp; G[u][v] != INF) &#123;<br>                <span class="hljs-keyword">if</span> (dis[u] + G[u][v] &lt; dis[v]) &#123;<br>                    dis[v] = dis[u] + G[u][v];<br>                    pre[v].clear();<br>                    pre[v].push_back(u);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dis[u] + G[u][v] == dis[v]) &#123;<br>                    pre[v].push_back(u);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>&#123; <span class="hljs-comment">// 从终点去开始找起点</span><br>    <span class="hljs-keyword">if</span> (v == city2id[startCity]) &#123; <span class="hljs-comment">// 临界条件</span><br>        leastNum++;<br>        tempPath.push_back(v);<br>        <span class="hljs-keyword">int</span> size = tempPath.size();<br>        <span class="hljs-keyword">int</span> maxHappy = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">double</span> avgHappy = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) <span class="hljs-comment">// startcity的happy是0，因为path是倒序，所以最后一个是起点</span><br>        &#123;<br>            maxHappy += happines[tempPath[i]];<br>        &#125;<br>        avgHappy = <span class="hljs-number">1.0</span> * maxHappy / (size - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (maxHappy &gt; ansHappy) &#123;<br>            ansHappy = maxHappy;<br>            ansAvgHappy = avgHappy;<br>            path = tempPath;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (maxHappy == ansHappy &amp;&amp; ansAvgHappy &lt; avgHappy) &#123;<br>            ansAvgHappy = avgHappy;<br>            path = tempPath;<br>        &#125;<br>        tempPath.pop_back();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    tempPath.push_back(v);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; pre[v].size(); i++) &#123;<br>        DFS(pre[v][i]);<br>    &#125;<br>    tempPath.pop_back();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; k &gt;&gt; startCity;<br>    happines[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    city2id[startCity] = <span class="hljs-number">0</span>;<br>    id2city[<span class="hljs-number">0</span>] = startCity;<br>    <span class="hljs-built_in">string</span> city;<br>    <span class="hljs-keyword">int</span> happy;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123; <span class="hljs-comment">// 输入n-1个城市和它的幸福值</span><br>        <span class="hljs-built_in">cin</span> &gt;&gt; city &gt;&gt; happy;<br>        happines[i] = happy;<br>        city2id[city] = i;<br>        id2city[i] = city;<br>    &#125;<br>    <span class="hljs-built_in">string</span> city1, city2;<br>    <span class="hljs-keyword">int</span> cost;<br>    fill(G[<span class="hljs-number">0</span>], G[<span class="hljs-number">0</span>] + MAX*MAX, INF);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; city1 &gt;&gt; city2 &gt;&gt; cost;<br>        G[city2id[city1]][city2id[city2]] = G[city2id[city2]][city2id[city1]] = cost;<br>    &#125;<br>    Dijkstra(city2id[startCity]);<br>    <span class="hljs-comment">// for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; dis[i] &lt;&lt; &quot; &quot;;&#125;</span><br>    DFS(city2id[<span class="hljs-string">&quot;ROM&quot;</span>]);<br>    <span class="hljs-built_in">cout</span> &lt;&lt; leastNum &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; dis[city2id[<span class="hljs-string">&quot;ROM&quot;</span>]] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; ansHappy &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; (<span class="hljs-keyword">int</span>)ansAvgHappy &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = path.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; id2city[path[i]];<br>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;-&gt;&quot;</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
      <tag>Dijkstra</tag>
      
      <tag>dfs</tag>
      
      <tag>最短路径</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1030 Travel Plan</title>
    <link href="/2021/01/19/1030-Travel-Plan/"/>
    <url>/2021/01/19/1030-Travel-Plan/</url>
    
    <content type="html"><![CDATA[<h1 id="1030-Travel-Plan"><a href="#1030-Travel-Plan" class="headerlink" title="1030 Travel Plan"></a>1030 Travel Plan</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/re6TKW.png" alt="re6TKW"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>和<a href="https://emhui.fun/2021/01/19/1018-Public-Bike-Management/">1018 Public Bike Management</a>思路类似。也是要找到最短距离并记录最短距离经过的结点。可以使用<code>pre</code>来记录最短路径的该点的上一个点是谁。若最短距离相同,就比较第二个权值大小。上一题是比较点上面的权值，本题是比较边上的第二个权值<code>cost</code>。因此再设置一个<code>Cost[MAX][MAX]</code>来存储<code>cost</code>，同时在更新最短距离的时候更新<code>cost</code>值。</p><p>具体更新如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v = <span class="hljs-number">0</span>; v &lt; n; v++) &#123; <span class="hljs-comment">// 优化u-v的路线</span><br><span class="hljs-keyword">if</span> (!visited[v] &amp;&amp; G[u][v] != INF) &#123;<br><span class="hljs-keyword">if</span> (dis[u] + G[u][v] &lt; dis[v]) &#123;<br>dis[v] = dis[u] + G[u][v];<br>cost[v] = cost[u] + Cost[u][v];<br>pre[v] = u;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dis[u] + G[u][v] == dis[v]) &#123;<br><span class="hljs-keyword">if</span> (cost[u] + Cost[u][v] &lt; cost[v]) &#123;<br>cost[v] = cost[u] + Cost[u][v];<br>pre[v] = u;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>本题采用<code>Dijkstra</code>计算最短距离和最小花费。也可以和之前的题目一样使用<code>dfs</code>去遍历，求最小花费。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">510</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">987654321</span>;<br><br><span class="hljs-keyword">int</span> G[MAX][MAX], Cost[MAX][MAX], dis[MAX], cost[MAX];<br><span class="hljs-keyword">bool</span> visited[MAX] = &#123;<span class="hljs-literal">false</span>&#125;;<br><span class="hljs-keyword">int</span> n, m, s, d;<br><span class="hljs-keyword">int</span> pre[MAX];<br><span class="hljs-keyword">int</span> minDis = INF, minCost = INF;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dijstra</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span> </span>&#123;<br>    fill(dis, dis + MAX, INF);<br>    fill(cost, cost + MAX, INF);<br>    dis[s] = <span class="hljs-number">0</span>;<br>    cost[s] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) pre[i] = i;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">int</span> u = <span class="hljs-number">-1</span>, MIN = INF;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123; <span class="hljs-comment">// 找到距离最短</span><br>            <span class="hljs-keyword">if</span> (!visited[j] &amp;&amp; dis[j] &lt; MIN) &#123;<br>                u = j;<br>                MIN = dis[j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (u == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span>;<br>        visited[u] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v = <span class="hljs-number">0</span>; v &lt; n; v++) &#123; <span class="hljs-comment">// 优化u-v的路线</span><br>            <span class="hljs-keyword">if</span> (!visited[v] &amp;&amp; G[u][v] != INF) &#123;<br>                <span class="hljs-keyword">if</span> (dis[u] + G[u][v] &lt; dis[v]) &#123;<br>                    dis[v] = dis[u] + G[u][v];<br>                    cost[v] = cost[u] + Cost[u][v];<br>                    pre[v] = u;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dis[u] + G[u][v] == dis[v]) &#123;<br>                    <span class="hljs-keyword">if</span> (cost[u] + Cost[u][v] &lt; cost[v]) &#123;<br>                        cost[v] = cost[u] + Cost[u][v];<br>                        pre[v] = u;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (v == s) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, pre[v]);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    dfs(pre[v]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, v);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;s, &amp;d);<br>    fill(G[<span class="hljs-number">0</span>], G[<span class="hljs-number">0</span>] + MAX * MAX, INF);<br>    <span class="hljs-keyword">int</span> u, v;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;G[u][v], &amp;Cost[u][v]);<br>        G[v][u] = G[u][v];<br>        Cost[v][u] = G[u][v];<br>    &#125;<br>    Dijstra(s);<br>    dfs(d); <span class="hljs-comment">// 倒着输出</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, dis[d], cost[d]);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
      <tag>图</tag>
      
      <tag>Dijkstra</tag>
      
      <tag>dfs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1018 Public Bike Management</title>
    <link href="/2021/01/19/1018-Public-Bike-Management/"/>
    <url>/2021/01/19/1018-Public-Bike-Management/</url>
    
    <content type="html"><![CDATA[<h1 id="1018-Public-Bike-Management"><a href="#1018-Public-Bike-Management" class="headerlink" title="1018 Public Bike Management"></a>1018 Public Bike Management</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/fg0RYG.png" alt="fg0RYG"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本题需要使用<code>Dijkstra</code>和<code>DFS</code>算法。</p><ul><li><code>Dijkstra</code>: 找到起点到指定点的权值最短的路径。使用<code>vector&lt;int&gt; pre[max]</code>来记录该位置。</li><li><code>DFS</code>: 计算最短路径花费的</li></ul><p>为了便于编写代码,不妨把每个点的点权(自行车数目)都减去Cmax /2,这样就可以用点权的正负来直接判断当前车站是需要补给还是需要带走额外的车辆。由于需要输出应从PBMC携带的自行车数目与从问题车站带回的自行车数目,因此对每个顶点来说需要增加两个属性:从PBMC到当前车站必须携带的自行车数目Need以及到达当前车站时手上多余的自行车数目Remain。显然,如果当前车站u的点权weightu为正,说明需要从该车站额外带走自行车,因此新的Remain等于旧的Remain加上weight[j;而如果当前车站u的点权weight[u]为负,说明当前车站需要补给自行车的数量为abs(weightu),此时如果Remain大于0,就可以用来补给当前车站,但如果Remain不够完全补给,剩余部分需要从PBMC携带,故Need增加这个数值。代码如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> need = <span class="hljs-number">0</span>, remain = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = tempPath.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>&#123;<br><span class="hljs-keyword">int</span> id = tempPath[i];<br><span class="hljs-keyword">if</span> (weight[id] &gt; <span class="hljs-number">0</span>)<br>&#123;<br>remain += weight[id];<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> (remain &gt; <span class="hljs-built_in">abs</span>(weight[id])) &#123;<br>remain -= <span class="hljs-built_in">abs</span>(weight[id]);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>need += <span class="hljs-built_in">abs</span>(weight[id]) - remain;<br>remain = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (minNeed &gt; need)<br>&#123;<br>minNeed = need;<br>minRemain = remain;<br>path = tempPath;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (minNeed == need &amp;&amp; minRemain &gt; remain)<br>&#123;<br>minRemain = remain;<br>path = tempPath;<br>&#125;<br></code></pre></td></tr></table></figure><p>显然,本题可以使用Djkstra + DFS的写法求解。具体做法是,先使用Dijkstra求出所有最短路径,然后用DFS从这些最短路径中选出need最小的(need相同时选remain 小)最路径的效E可以在Dijikstra部分顺便求出,也可以在DFS中边界条件处进行累计。<br>注意点</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 1. 使用Dijkstra算法求得最短路径条数</span><br><span class="hljs-comment">// 2. 然后对最短路径条数使用DFS遍历获取need最小的值</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">510</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">987654321</span>;<br><span class="hljs-keyword">int</span> n, m, sp, cmax;<br><span class="hljs-keyword">int</span> G[MAX][MAX], dis[MAX], weight[MAX];<br><span class="hljs-keyword">bool</span> visited[MAX] = &#123;<span class="hljs-literal">false</span>&#125;;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; tempPath, path;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; pre[MAX]; <span class="hljs-comment">// 存储开始结点到该结点的最短路径中，前一个结点。</span><br><span class="hljs-keyword">int</span> minNeed = INF, minRemain = INF;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span> </span>&#123;<br>    fill(dis, dis + MAX, INF);<br>    dis[s] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 自己到自己的距离为0</span><br>    <span class="hljs-comment">// visited[root] = true; // 访问自己</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123; <span class="hljs-comment">// 开始依次找到最短距离. == n</span><br>        <span class="hljs-keyword">int</span> u = <span class="hljs-number">-1</span>, minDis = INF; <span class="hljs-comment">// 找到最近的，且没有被访问的点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (!visited[j] &amp;&amp; minDis &gt; dis[j]) &#123;<br>                u = j;<br>                minDis = dis[j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (u == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 没有找到</span><br>        visited[u] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 找到了，访问该结点。同时开始更新</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v = <span class="hljs-number">0</span>; v &lt;= n; v++) &#123;<br>            <span class="hljs-keyword">if</span> (!visited[v] &amp;&amp; G[u][v] != INF) &#123; <span class="hljs-comment">// uv是可以访问</span><br>                <span class="hljs-keyword">if</span> (dis[u] + G[u][v] &lt; dis[v]) &#123;<br>                    dis[v] = dis[u] + G[u][v];<br>                    pre[v].clear();<br>                    pre[v].push_back(u); <span class="hljs-comment">// 存储的每个路径的最短的上一个结点</span><br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dis[u] + G[u][v] == dis[v]) &#123;<br>                    pre[v].push_back(u); <span class="hljs-comment">// 存在多个最短路径的上一个结点</span><br>                &#125;<br>            &#125;;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (v == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 找到了边界</span><br>        tempPath.push_back(v);<br>        <span class="hljs-keyword">int</span> need = <span class="hljs-number">0</span>, remain = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = tempPath.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>        &#123;<br>            <span class="hljs-keyword">int</span> id = tempPath[i];<br>            <span class="hljs-keyword">if</span> (weight[id] &gt; <span class="hljs-number">0</span>)<br>            &#123;<br>                remain += weight[id];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (remain &gt; <span class="hljs-built_in">abs</span>(weight[id])) &#123;<br>                    remain -= <span class="hljs-built_in">abs</span>(weight[id]);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    need += <span class="hljs-built_in">abs</span>(weight[id]) - remain;<br>                    remain = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (minNeed &gt; need)<br>        &#123;<br>            minNeed = need;<br>            minRemain = remain;<br>            path = tempPath;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (minNeed == need &amp;&amp; minRemain &gt; remain)<br>        &#123;<br>            minRemain = remain;<br>            path = tempPath;<br>        &#125;<br>        tempPath.pop_back();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    tempPath.push_back(v); <span class="hljs-comment">// 存储路径</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; pre[v].size(); i++)<br>    &#123;<br>        dfs(pre[v][i]);<br>    &#125;<br><br>    tempPath.pop_back();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>, &amp;cmax, &amp;n, &amp;sp, &amp;m);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123; <span class="hljs-comment">// i从1开始</span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;weight[i]);<br>        weight[i] -= cmax / <span class="hljs-number">2</span>;<br>    &#125;<br>    fill(G[<span class="hljs-number">0</span>], G[<span class="hljs-number">0</span>] + MAX * MAX, INF);<br>    <span class="hljs-keyword">int</span> u, v;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;G[u][v]);<br>        G[v][u] = G[u][v];<br>    &#125;<br>    Dijkstra(<span class="hljs-number">0</span>);<br>    dfs(sp);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, minNeed);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = path.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, path[i]);<br>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-&gt;&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d\n&quot;</span>, minRemain);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
      <tag>Dijkstra</tag>
      
      <tag>dfs</tag>
      
      <tag>最短路径</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1584. 连接所有点的最小费用</title>
    <link href="/2021/01/19/1584-%E8%BF%9E%E6%8E%A5%E6%89%80%E6%9C%89%E7%82%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8/"/>
    <url>/2021/01/19/1584-%E8%BF%9E%E6%8E%A5%E6%89%80%E6%9C%89%E7%82%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="1584-连接所有点的最小费用"><a href="#1584-连接所有点的最小费用" class="headerlink" title="1584. 连接所有点的最小费用"></a><a href="https://emhui.fun/2021/01/19/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/">1584. 连接所有点的最小费用</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/MiReTb.png" alt="MiReTb"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本题是求由这些点组成的最小生成树权值大小。可以使用<strong>Kruskal算法</strong>。</p><h3 id="Kruskal算法-lt-span-class-”hint–top-hint–rounded”-aria-label-”最小生成树"><a href="#Kruskal算法-lt-span-class-”hint–top-hint–rounded”-aria-label-”最小生成树" class="headerlink" title="Kruskal算法 &lt;span class=”hint–top hint–rounded” aria-label=”最小生成树"></a>Kruskal算法 <sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote">&lt;span class=”hint–top hint–rounded” aria-label=”最小生成树</h3><p>“&gt;[1]</span></a></sup></p><blockquote><p>该算法细节可以参考<a href="https://emhui.fun/2021/01/19/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/">最小生成树</a></p></blockquote><p>该算法满足实现两点</p><ul><li>建立一个权值边和边两个顶点的集合。同时该集合按照边的权值由小到达排序。</li><li>从该集合中几次选出最小的边，判断该边的两个点是否已经在最小生成树中（<strong>使用并查集</strong>），若不在，则将该边加入到最小生成树中，同时连通该两点。若存在该两点，则继续寻找下一个权值最小的边。</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span> &#123;</span><br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; parent;<br>    <span class="hljs-keyword">public</span>:<br>    UnionFind(<span class="hljs-keyword">int</span> n) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) parent.push_back(i);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (x != parent[x]) &#123;<br>            parent[x] = find(parent[x]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> parent[x];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quick_union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> w)</span> </span>&#123;<br>        parent[find(v)] = find(w);<br>    &#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minCostConnectPoints</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;<br>        <span class="hljs-comment">// 建立一个权值的对应的边</span><br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt;&gt; edges;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; points.size(); i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; points.size(); j++) &#123;<br>                <span class="hljs-keyword">int</span> cost = <span class="hljs-built_in">abs</span>(points[i][<span class="hljs-number">0</span>] - points[j][<span class="hljs-number">0</span>]) + <span class="hljs-built_in">abs</span>(points[i][<span class="hljs-number">1</span>] - points[j][<span class="hljs-number">1</span>]);<br><br>                edges.push_back(<span class="hljs-built_in">make_pair</span>(cost, <span class="hljs-built_in">make_pair</span>(i, j))); <span class="hljs-comment">// 把i,j两个点放到求加权边的目录</span><br>            &#125;<br>        &#125;<br>        sort(edges.begin(), edges.end()); <span class="hljs-comment">// 按照权边进行排序</span><br>        <span class="hljs-function">UnionFind <span class="hljs-title">uf</span><span class="hljs-params">(points.size())</span></span>;<br>        <span class="hljs-comment">// 开始检查加权边</span><br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; edges.size(); i++) &#123;<br>            <span class="hljs-keyword">int</span> cost = edges[i].first;<br>            <span class="hljs-keyword">int</span> u = edges[i].second.first, v = edges[i].second.second;<br>            <span class="hljs-keyword">if</span> (uf.find(u) == uf.find(v)) <span class="hljs-keyword">continue</span>;<br>            uf.quick_union(u, v);<br>            sum += cost;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><section class="footnotes"><h2>参考</h2><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://emhui.fun/2021/01/19/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/">最小生成树</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>图</tag>
      
      <tag>leetcode</tag>
      
      <tag>Kruskal</tag>
      
      <tag>最小生成树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最小生成树</title>
    <link href="/2021/01/19/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    <url>/2021/01/19/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="最小生成树算法"><a href="#最小生成树算法" class="headerlink" title="最小生成树算法"></a>最小生成树算法</h1><p>满足最小生成树</p><ul><li>所有顶点都连接</li><li>没有环</li></ul><p>生成树可能存在多个，而权值只和最小的就是最小生成树</p><p>实现方法</p><ul><li><input checked="" disabled="" type="checkbox"> Kruskal</li><li><input disabled="" type="checkbox"> Prim</li></ul><h2 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h2><ul><li>所有的边按照权值排序</li><li>解决当前最小的权值边和已添加的线是否形成回路（重点）</li></ul><p>如图是Kruskal算法的过程</p><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/mFdoQR.png" alt="mFdoQR"></p><p>每次从权值边选出最小边，再判断该边的两点是否已经存在于最小生成树中（使用并查集来判断），若不存在就加入最小生成树中。若存在则寻找下一条最小权值的边。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>如何将权值和两个顶点联系起来呢？这是使用<code>pair&lt;int, pair&lt;int, int&gt;&gt;</code>来实现，其中权值作为第一个元素，第二个元素为该权值对应的两个顶点。使用<code>sort</code>对权值边从小到达大进行排序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">100</span>;<br>UnionFind uf;<br><span class="hljs-keyword">int</span> V; <span class="hljs-comment">// 顶点个数</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt; adj[MAX]; <span class="hljs-comment">// 邻接表，存储图</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">kruskal</span><span class="hljs-params">(&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">pair</span>(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>)&gt;&gt;&amp; selected)</span> </span>&#123;<br><span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>selected.clear(); <span class="hljs-comment">// 加入到最小生成树的顶点</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt;&gt; edges; <span class="hljs-comment">// 存储权值边以及两端顶点</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> u = <span class="hljs-number">0</span>; u &lt; V; u++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; adj[u].size(); i++) &#123;<br><span class="hljs-keyword">int</span> v = adj[u][i].first;<br><span class="hljs-keyword">int</span> cost = adj[u][i].second;<br>edges.push_back(<span class="hljs-built_in">make_pair</span>(cost, <span class="hljs-built_in">make_pair</span>(u, v))); <span class="hljs-comment">// 把 权值， 两个点 存储到 edges中</span><br>&#125;<br>&#125;<br>sort(edges.begin(), sort.end()); <span class="hljs-comment">// 按照权值进行排序</span><br><span class="hljs-function">UnionFind <span class="hljs-title">uf</span><span class="hljs-params">(V)</span></span>; <span class="hljs-comment">// 建立并查集</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; edges.size(); i++) &#123; <span class="hljs-comment">// 开始依次选择最小权值生成最小生成树</span><br><span class="hljs-keyword">int</span> cost = edges[i].first;<br><span class="hljs-keyword">int</span> u = edges[i].second.first, v = edges[i].second.second;<br><span class="hljs-keyword">if</span> (uf.find(u) == uf.find(v)) <span class="hljs-keyword">continue</span>;<br>uf.quick_union(u, v);<br>selected.push_back(<span class="hljs-built_in">make_pair</span>(u, v));<br>sum += cost;<br>&#125;<br><span class="hljs-keyword">return</span> sum; <span class="hljs-comment">// 最小生成树权值</span><br>&#125;<br></code></pre></td></tr></table></figure><p>相关题目</p><ul><li><a href="https://emhui.fun/2021/01/19/1584-%E8%BF%9E%E6%8E%A5%E6%89%80%E6%9C%89%E7%82%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8/">1584.连接所有点的最小费用</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>leetcode</tag>
      
      <tag>Kruskal</tag>
      
      <tag>最小生成树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1005 Spell It Right</title>
    <link href="/2021/01/18/1005-Spell-It-Right/"/>
    <url>/2021/01/18/1005-Spell-It-Right/</url>
    
    <content type="html"><![CDATA[<h1 id="1005-Spell-It-Right"><a href="#1005-Spell-It-Right" class="headerlink" title="1005 Spell It Right"></a>1005 Spell It Right</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/AngAu5.png" alt="AngAu5"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>$N &lt;= 10^100$。使用<code>int,long long</code>类型还是不行的，因此使用<code>char[]</code>作为输入。</li><li>建立一个二维字符数组<code>num2engilis</code>.建立数字和英文数字之间映射</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> num2englis[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>] = &#123;<span class="hljs-string">&quot;zero&quot;</span>, <span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>, <span class="hljs-string">&quot;four&quot;</span>, <span class="hljs-string">&quot;five&quot;</span>, <span class="hljs-string">&quot;six&quot;</span>, <span class="hljs-string">&quot;seven&quot;</span>, <span class="hljs-string">&quot;eight&quot;</span>, <span class="hljs-string">&quot;nine&quot;</span>&#125;;<br></code></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">101</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> num2englis[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>] = &#123;<span class="hljs-string">&quot;zero&quot;</span>, <span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>, <span class="hljs-string">&quot;four&quot;</span>, <span class="hljs-string">&quot;five&quot;</span>, <span class="hljs-string">&quot;six&quot;</span>, <span class="hljs-string">&quot;seven&quot;</span>, <span class="hljs-string">&quot;eight&quot;</span>, <span class="hljs-string">&quot;nine&quot;</span>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">char</span> s[maxn];<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, s);<br>    <span class="hljs-keyword">int</span> size = <span class="hljs-built_in">strlen</span>(s);<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>, arr[maxn];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>        sum += s[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">do</span> &#123;<br>        arr[num++] = sum % <span class="hljs-number">10</span>;<br>        sum /= <span class="hljs-number">10</span>;<br>    &#125; <span class="hljs-keyword">while</span> (sum);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = num - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, num2englis[arr[i]]);<br>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);&#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1001 A+B Format</title>
    <link href="/2021/01/18/1001-A-B-Format/"/>
    <url>/2021/01/18/1001-A-B-Format/</url>
    
    <content type="html"><![CDATA[<h1 id="1001-A-B-Format"><a href="#1001-A-B-Format" class="headerlink" title="1001 A+B Format"></a>1001 A+B Format</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/FpwMfH.png" alt="FpwMfH"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本题通过$a+b$得到一个新的值，新的值按照三个一组的格式输出，每组前面一个逗号。</p><p>因此可以考虑将新的值拆解到数组中，再倒序输出数组，每当三个的时候输出一个逗号。</p><p>⚠️： 如果结果是负数，需要取负数的绝对值进行运算。但是最好不要使用<code>abs</code>。经过测试，这个函数在有的编译器无法编译。考虑如果是负数对其取反即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> a,b;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);<br>    <span class="hljs-keyword">int</span> n = a + b;<br>    <span class="hljs-keyword">int</span> temp = n &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> - n : n;<br>    <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>, arr[<span class="hljs-number">10</span>];<br>    <span class="hljs-keyword">do</span> &#123;<br>        arr[num++] = temp % <span class="hljs-number">10</span>;<br>        temp /= <span class="hljs-number">10</span>;<br>    &#125; <span class="hljs-keyword">while</span> (temp);<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-&quot;</span>);&#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = num - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, arr[i]);<br>        <span class="hljs-keyword">if</span> (i % <span class="hljs-number">3</span> == <span class="hljs-number">0</span> &amp;&amp; i != <span class="hljs-number">0</span>) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;,&quot;</span>);&#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>数学</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>账户合并</title>
    <link href="/2021/01/18/%E8%B4%A6%E6%88%B7%E5%90%88%E5%B9%B6/"/>
    <url>/2021/01/18/%E8%B4%A6%E6%88%B7%E5%90%88%E5%B9%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="账户合并"><a href="#账户合并" class="headerlink" title="账户合并"></a><a href="https://leetcode-cn.com/problems/accounts-merge/">账户合并</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/Ssq91V.png" alt="Ssq91V"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本题需要找到邮箱之间的连通性，若邮箱之间连通，那么就确定了该邮箱所属的人。可以采用并查集来实现。设置两个哈希表。建立<strong>email-&gt;idx</strong>，<strong>email-&gt;name</strong>。</p><p>映射方法如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt; email2idx;<br><span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>,<span class="hljs-built_in">string</span>&gt; email2name;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; accounts.size(); i++) &#123;<br><span class="hljs-built_in">string</span> name = accounts[i][<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; accounts[i].size(); j++) &#123;<br><span class="hljs-keyword">if</span> (email2idx.find(accounts[i][j]) == email2idx.end()) &#123;<br>email2idx[accounts[i][j]] = email2idx.size();<br>email2name[accounts[i][j]] = name;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着使用并查集，将属于同一连通分量的email连通。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">UnionFind <span class="hljs-title">uf</span><span class="hljs-params">(email2idx.size())</span></span>; <span class="hljs-comment">// 初始化</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; accounts.size(); i++) &#123;<br><span class="hljs-built_in">string</span> first = accounts[i][<span class="hljs-number">1</span>]; <span class="hljs-comment">// 每一组account对象中，各个邮箱都是连通的，因此只要选择一个来和其他连通就可以。</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">2</span>; j &lt; accounts[i].size(); j++) &#123;<br>uf.quick_union(email2idx[first], email2idx[accounts[i][j]]); <span class="hljs-comment">// 合并同一个集合</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>合并好连通分量后，开始将同一个连通分量下的email集合到一起</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C+">&#x2F;&#x2F; 将同一连通分量下的集合添加到一起<br>map&lt;int, vector&lt;string&gt;&gt; idx2emails;<br>for (map&lt;string, int&gt;::iterator it &#x3D; email2idx.begin(); it !&#x3D; email2idx.end(); it++) &#123;<br>idx2emails[uf.find(it-&gt;second)].push_back(it-&gt;first);<br>&#125;<br></code></pre></td></tr></table></figure><p>最后按照题目返回对应格式数据即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span> &#123;</span><br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; parent;<br>    <span class="hljs-keyword">public</span>:<br>    UnionFind(<span class="hljs-keyword">int</span> n) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) parent.push_back(i);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (x != parent[x]) &#123;<br>            parent[x] = find(parent[x]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> parent[x];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quick_union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> w)</span> </span>&#123;<br>        parent[find(v)] = find(w);<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt; <span class="hljs-title">accountsMerge</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt;&amp; accounts)</span> </span>&#123;<br>        <span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt; email2idx;<br>        <span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>,<span class="hljs-built_in">string</span>&gt; email2name;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; accounts.size(); i++) &#123;<br>            <span class="hljs-built_in">string</span> name = accounts[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; accounts[i].size(); j++) &#123;<br>                <span class="hljs-keyword">if</span> (email2idx.find(accounts[i][j]) == email2idx.end()) &#123;<br>                    email2idx[accounts[i][j]] = email2idx.size();<br>                    email2name[accounts[i][j]] = name;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-function">UnionFind <span class="hljs-title">uf</span><span class="hljs-params">(email2idx.size())</span></span>; <span class="hljs-comment">// 初始化</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; accounts.size(); i++) &#123;<br>            <span class="hljs-built_in">string</span> first = accounts[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">2</span>; j &lt; accounts[i].size(); j++) &#123;<br>                uf.quick_union(email2idx[first], email2idx[accounts[i][j]]); <span class="hljs-comment">// 合并同一个集合</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 将同一连通分量下的集合添加到一起</span><br>        <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt; idx2emails;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt;::iterator it = email2idx.begin(); it != email2idx.end(); it++) &#123;<br>            <span class="hljs-comment">// cout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; uf.find(it-&gt;second) &lt;&lt;endl;</span><br>            idx2emails[uf.find(it-&gt;second)].push_back(it-&gt;first);<br>        &#125;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt; ans;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt;::iterator it = idx2emails.begin(); it != idx2emails.end(); it++) &#123;<br>            <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; temp;<br>            temp.push_back(email2name[it-&gt;second[<span class="hljs-number">0</span>]]);<br>            sort(it-&gt;second.begin(), it-&gt;second.end());<br>            temp.insert(temp.end(), it-&gt;second.begin(), it-&gt;second.end());<br>            ans.push_back(temp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>&#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><code>vector&lt;type&gt;</code>合并数据</li></ul><p>如下例所示，使用<code>insert(oriin.end(), in.begin(), in.end())</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vec1 = &#123;...&#125;;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vec2 = &#123;...&#125;;<span class="hljs-comment">// vec1和vec2都存有内容</span><br><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vec3;<span class="hljs-comment">//vec3是空的</span><br>vec3.insert(vec3.end(),vec1.begin(),vec1.end())<span class="hljs-comment">//将vec1压入</span><br>vec3.insert(vec3.end(),vec2.begin(),vec2.end())<span class="hljs-comment">//继续将vec2压入</span><br></code></pre></td></tr></table></figure><ul><li><code>vector</code>如何使用<code>sort</code></li></ul><p>基本使用：<code>sort(v.begin(), v.end())</code></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>union-find</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1034 Head of a Gang</title>
    <link href="/2021/01/18/1034-Head-of-a-Gang/"/>
    <url>/2021/01/18/1034-Head-of-a-Gang/</url>
    
    <content type="html"><![CDATA[<h1 id="1034-Head-of-a-Gang"><a href="#1034-Head-of-a-Gang" class="headerlink" title="1034 Head of a Gang"></a>1034 Head of a Gang</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/oAOiuF.png" alt="oAOiuF"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>略.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">2001</span>;<br><span class="hljs-keyword">int</span> numPersion = <span class="hljs-number">0</span>, count = <span class="hljs-number">0</span>; <span class="hljs-comment">// count 连通分量个数</span><br><span class="hljs-keyword">int</span> parent[maxn] = &#123;<span class="hljs-number">0</span>&#125;, weight[maxn] = &#123;<span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-built_in">string</span>&gt; int2string;<br><span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>,<span class="hljs-keyword">int</span>&gt; string2num, gang;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">str2num</span><span class="hljs-params">(<span class="hljs-built_in">string</span> name)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (string2num.find(name) != string2num.end()) &#123;<br>        <span class="hljs-keyword">return</span> string2num[name];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        string2num[name] = numPersion; <span class="hljs-comment">// str-&gt;num</span><br>        int2string[numPersion] = name; <span class="hljs-comment">// num-&gt;str</span><br>        <span class="hljs-keyword">return</span> numPersion++;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (v != parent[v]) &#123;parent[v] = find(parent[v]);&#125; <span class="hljs-comment">// 路径压缩</span><br>    <span class="hljs-keyword">return</span> parent[v];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quick_union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> w)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> vRoot = find(v), wRoot = find(w);<br>    <span class="hljs-keyword">if</span> (vRoot == wRoot) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (weight[vRoot] &gt; weight[wRoot]) parent[wRoot] = vRoot;<br>    <span class="hljs-keyword">else</span> parent[vRoot] = wRoot;<br>    count--;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">string</span> s1, s2;<br>    <span class="hljs-keyword">int</span> n, k, w;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; temp[maxn];<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; s1 &gt;&gt; s2 &gt;&gt; w;<br>        <span class="hljs-keyword">int</span> id1 = str2num(s1), id2 = str2num(s2);<br>        weight[id1] += w;<br>        weight[id2] += w;<br>        temp[i].push_back(id1);<br>        temp[i].push_back(id2);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numPersion; i++) &#123;parent[i] = i;&#125;<br>    count = numPersion; <span class="hljs-comment">// 一开始连通分量个数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">int</span> v = temp[i][<span class="hljs-number">0</span>], w = temp[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (find(v) != find(w)) &#123;<br>            quick_union(v, w);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> numGang = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; head; <span class="hljs-comment">// 记录所有的头</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numPersion; i++) &#123;<br>        <span class="hljs-comment">// cout &lt;&lt; i &lt;&lt; &quot;:&quot; &lt;&lt;int2string[i] &lt;&lt; &quot;-&gt;&quot; &lt;&lt; int2string[parent[i]] &lt;&lt; &quot; w: &quot; &lt;&lt; weight[i] &lt;&lt; endl;</span><br>        <span class="hljs-keyword">if</span> (i == parent[i]) &#123;<br>            head.push_back(i);<br>            <span class="hljs-comment">// cout &lt;&lt; &quot;head =&gt; &quot; &lt;&lt; int2string[i] &lt;&lt;endl;</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; head.size(); i++) &#123;<br>        <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> weightGange = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; numPersion; j++) &#123;<br>            <span class="hljs-keyword">if</span> (find(j) == head[i]) &#123;<br>                weightGange += weight[j];<br>                num++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (num &gt; <span class="hljs-number">2</span> &amp;&amp; (weightGange / <span class="hljs-number">2</span>) &gt; k)<br>        &#123;<br>            gang[int2string[head[i]]] = num;<br>            numGang++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; numGang &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>,<span class="hljs-keyword">int</span>&gt;::iterator it = gang.begin(); it != gang.end(); it++) &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt;<span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <span class="hljs-comment">// cout &lt;&lt; find(4) &lt;&lt; endl;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
      <tag>图</tag>
      
      <tag>union-find</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1003 Emergency</title>
    <link href="/2021/01/17/1003-Emergency/"/>
    <url>/2021/01/17/1003-Emergency/</url>
    
    <content type="html"><![CDATA[<h1 id="1003-Emergency"><a href="#1003-Emergency" class="headerlink" title="1003 Emergency"></a>1003 Emergency</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/ugQwkH.png" alt="ugQwkH"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本题主要是找出<strong>给出一个带有点和边的权值无向图，求出两点之间最短路径的数量和到达最短路径的最大点权值</strong></p><p>本题主要求</p><ul><li>给定两点之间的<strong>最短距离数量</strong></li><li>在满足<strong>最短距离</strong>下的<strong>最大点权值和</strong></li></ul><p>因此设置两个数组分别记录<strong>最短距离数量</strong>，<strong>最大点权值和</strong></p><ul><li><code>path</code></li><li><code>w</code></li></ul><p>找最短距离可以使用<code>Dijkstra</code>算法，在该算法的优化更新过程中对<code>path,w</code>进行优化,代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v = <span class="hljs-number">0</span>; v &lt; n; v++) &#123; <span class="hljs-comment">// 开始进行优化u-v和s-v的最短距离。</span><br><span class="hljs-keyword">if</span> (visited[v] == <span class="hljs-literal">false</span> &amp;&amp; G[u][v] != INF) &#123;<br><span class="hljs-comment">// 判断最短路径</span><br><span class="hljs-keyword">if</span> (d[u] + G[u][v] &lt; d[v]) &#123; <span class="hljs-comment">// 如果存在还要短的路径，进行优化更新</span><br>d[v] = d[u] + G[u][v];<br>w[v] = w[u] + pw[v]; <span class="hljs-comment">// 同时更新该点权值</span><br>path[v] = path[u];<span class="hljs-comment">// 更新路径数量,不存在多条一样的最短路径</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (d[u] + G[u][v] == d[v])&#123; <span class="hljs-comment">// 出现长度相同的路径</span><br>path[v] += path[u];<br><span class="hljs-keyword">if</span> (w[u] + pw[v] &gt; w[v]) &#123; <span class="hljs-comment">// 若这条路径的点权值大，则进行更新。</span><br>w[v] = w[u] + pw[v];<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">510</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">100000000</span>;<br><br><span class="hljs-keyword">int</span> n, m, c1, c2, G[maxn][maxn];<br><span class="hljs-keyword">int</span> d[maxn], pw[maxn], path[maxn], w[maxn]; <span class="hljs-comment">// d 路径, w 点权重, path 路径数量</span><br><span class="hljs-keyword">bool</span> visited[maxn] = &#123;<span class="hljs-literal">false</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start)</span> </span>&#123;<br>    <span class="hljs-comment">// 1. 查询前的初始化操作</span><br>    fill(d, d + maxn, INF); <span class="hljs-comment">// 初始化所有距离为INF</span><br>    <span class="hljs-built_in">memset</span>(path, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(path)); <span class="hljs-comment">// 初始化所有的路径为0</span><br>    <span class="hljs-built_in">memset</span>(w, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(w)); <span class="hljs-comment">// 初始化点权重为0</span><br>    path[start] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 自己到自己有一个路</span><br>    d[start] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 自己到自己的距离为0</span><br>    w[start] = pw[start]; <span class="hljs-comment">// 默认点的权重是自己</span><br>    <span class="hljs-comment">// 2. 开始找start到各个点的距离</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-comment">// 2.1 找到最短距离。</span><br>        <span class="hljs-keyword">int</span> u = <span class="hljs-number">-1</span>, MIN = INF; <span class="hljs-comment">// 找到最近的那个点，开始遍历。</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (visited[j] == <span class="hljs-literal">false</span> &amp;&amp; d[j] &lt; MIN) &#123;<br>                u = j;<br>                MIN = d[j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (u == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span>;<br>        visited[u] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 访问u</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v = <span class="hljs-number">0</span>; v &lt; n; v++) &#123; <span class="hljs-comment">// 开始进行优化u-v和s-v的最短距离。</span><br>            <span class="hljs-keyword">if</span> (visited[v] == <span class="hljs-literal">false</span> &amp;&amp; G[u][v] != INF) &#123;<br>                <span class="hljs-comment">// 判断最短路径</span><br>                <span class="hljs-keyword">if</span> (d[u] + G[u][v] &lt; d[v]) &#123; <span class="hljs-comment">// 如果存在还要短的路径，进行优化更新</span><br>                    d[v] = d[u] + G[u][v];<br>                    w[v] = w[u] + pw[v]; <span class="hljs-comment">// 同时计算该点权值</span><br>                    path[v] = path[u];<span class="hljs-comment">// 更新路径数量</span><br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (d[u] + G[u][v] == d[v])&#123; <span class="hljs-comment">// 出现长度相同的路径</span><br>                    path[v] += path[u];<br>                    <span class="hljs-keyword">if</span> (w[u] + pw[v] &gt; w[v]) &#123; <span class="hljs-comment">// 若这条路径的点权值大，则进行更新。</span><br>                        w[v] = w[u] + pw[v];<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;c1, &amp;c2);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123; <span class="hljs-comment">// 点权，每个城市的救护车数量</span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;pw[i]);<br>    &#125;<br>    <span class="hljs-keyword">int</span> v1, v2, dis;<br>    fill(G[<span class="hljs-number">0</span>], G[<span class="hljs-number">0</span>] + maxn * maxn, INF); <span class="hljs-comment">// fill(首地址，尾地址，填充值);</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123; <span class="hljs-comment">// 连通图</span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;v1, &amp;v2, &amp;dis);<br>        G[v1][v2] = dis;<br>        G[v2][v1] = dis;<br>    &#125;<br>    Dijkstra(c1);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, path[c2], w[c2]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><code>C++</code>中<code>memset</code>和<code>fill</code>区别</li></ul><p><code>memset</code>在<code>string.h</code>头文件中。<code>memset</code>只能填充字节，一般填充0或-1.填充其他数不适合。所以在使用初始化<code>bool</code>数组的可以使用。</p><p><code>memset(数组,填充数据0/-1,数组大小)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">memset</span>(visited, <span class="hljs-literal">false</span>, <span class="hljs-keyword">sizeof</span>(visited));<br></code></pre></td></tr></table></figure><p><code>fill</code>在<code>algorithm</code>中，它可以填充任何值。使用方法<code>fill(首地址, 为地址,填充数据)</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">fill(G[<span class="hljs-number">0</span>], G[<span class="hljs-number">0</span>] + maxn * maxn, INF); <span class="hljs-comment">// fill(首地址，尾地址，填充值);</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
      <tag>图</tag>
      
      <tag>Dijkstra</tag>
      
      <tag>最短距离</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1021 Deepest Root</title>
    <link href="/2021/01/17/1021-Deepest-Root/"/>
    <url>/2021/01/17/1021-Deepest-Root/</url>
    
    <content type="html"><![CDATA[<h1 id="1021-Deepest-Root"><a href="#1021-Deepest-Root" class="headerlink" title="1021 Deepest Root"></a>1021 Deepest Root</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/8yP8rz.png" alt="8yP8rz"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本题主要是求<strong>一个图转化为树，从图中每个顶点出发到根结点的最大深度。若图存在多个连通分量，则直接输出连通分量个数。若存在多个最大深度相同的根结点，则升序输出这些根结点</strong>。</p><p>步骤</p><ol><li>在输入的使用使用并查集,输入完成后就可以统计连通分量个个数。若连通分量个数大于1直接输出。</li><li>若整个图是连通的，则使用<code>BFS</code>将每个结点做根结点进行遍历。用一个数组<code>ans[maxn]</code>统计每个结点作为根结点时候的最大深度。再使用<code>maxHight</code>变量设置为整个图的最大深度。</li><li>最后使用遍历<code>ans[maxn]</code>便可以按升序输出最大深度的根结点。</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">10010</span>;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; graphic[maxn];<br><span class="hljs-keyword">bool</span> visited[maxn] = &#123;<span class="hljs-literal">false</span>&#125;;<br><span class="hljs-keyword">int</span> ans[maxn] = &#123;<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// 记录每个结点的连通分量</span><br><span class="hljs-keyword">int</span> highest = <span class="hljs-number">-1</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> root, <span class="hljs-keyword">int</span> depth)</span> </span>&#123;<br>    visited[root] = <span class="hljs-literal">true</span>;<br>    highest = highest &gt; depth ? highest: depth;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; graphic[root].size(); i++) &#123;<br>        <span class="hljs-keyword">if</span> (visited[graphic[root][i]] == <span class="hljs-literal">false</span>) &#123;<br>            dfs(graphic[root][i], depth + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initVisited</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        visited[i] = <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 判断是否有多个连通分量。这个函数无法统计连通分量，只能判断连通分量是否超过一个</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countConnected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!visited[i]) &#123;<br>            count++;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span> &#123;</span><br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> count;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; parent;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; sz;<br>    <span class="hljs-keyword">public</span>:<br>    UnionFind(<span class="hljs-keyword">int</span> n) &#123;<br>        count = n;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            parent.push_back(i);<br>            sz.push_back(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (x != parent[x]) &#123; <span class="hljs-comment">// 路径压缩</span><br>            parent[x] = find(parent[x]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> parent[x];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quick_union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> w)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> vR = find(v), wR = find(w);<br>        <span class="hljs-keyword">if</span> (vR == wR ) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (sz[vR] &gt; sz[wR]) &#123;<br>            parent[wR] = vR;<br>            sz[vR] += sz[wR];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            parent[vR] = wR;<br>            sz[wR] += sz[vR];<br>        &#125;<br>        count--;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">connected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> w)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> find(v) == find(w);<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, v, w;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-function">UnionFind <span class="hljs-title">uf</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">// id是1~n</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123; <span class="hljs-comment">// n-1条边</span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;v, &amp;w);<br>        graphic[v].push_back(w);<br>        graphic[w].push_back(v);<br>        uf.quick_union(v,w);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (uf.getCount() &gt; <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error: %d components\n&quot;</span>, uf.getCount() - <span class="hljs-number">1</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>, maxHight = <span class="hljs-number">-1</span>; <span class="hljs-comment">// 开始对每个点进行遍历，并且记录每个点的最大深度。</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            initVisited(n);<br>            highest = <span class="hljs-number">-1</span>;<br>            dfs(i, <span class="hljs-number">0</span>);<br>            ans[i] = highest;<br>            maxHight = maxHight &gt; highest ? maxHight : highest;<br>            count = countConnected(n);<br>            <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">break</span>;&#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-keyword">if</span> (maxHight == ans[i]) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, i);&#125;;<br>        &#125; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
      <tag>图</tag>
      
      <tag>union-find</tag>
      
      <tag>dfs</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1013 Battle Over Cities</title>
    <link href="/2021/01/16/1013-Battle-Over-Cities/"/>
    <url>/2021/01/16/1013-Battle-Over-Cities/</url>
    
    <content type="html"><![CDATA[<h1 id="1013-Battle-Over-Cities"><a href="#1013-Battle-Over-Cities" class="headerlink" title="1013 Battle Over Cities"></a>1013 Battle Over Cities</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/CLjpGz.png" alt="CLjpGz"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本题意思就是在一个连通图中，删去一个结点，需要添加多少边使得图重新连通起来。</p><p>用下图来举例</p><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/5mOVVl.png" alt="5mOVVl"></p><p>在当前连通图中，若把$3$给删除了，存在4个连通分量。而只需要添加$4-2=2$条线将其重新连通。</p><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/lye84M.png" alt="lye84M"></p><p>在该图中，把结点$1$删除后，剩下三个连通分量。而只需要添加$3-2=1$条线即可重新连通。</p><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/9nbLnk.png" alt="9nbLnk"></p><p>因此需要添加的线的数量为<strong>删除该结点后的新的连通图连通分量-2</strong>。</p><p>所以我们每次查询的时候，都需要重新建立连通分量。</p><p>实现步骤</p><ol><li>设置一个<code>cityMap</code>对象存储连通的路线。</li><li>写一个<code>UnionFind</code>类，每次查询重新创建一个该类对象，并且计算连通分量。</li><li>当遇到查询点的时候，不将其进行连接。</li></ol><p>⚠️</p><ul><li>城市的编号是$1 \sim N$，所以<code>UnionFind</code>的<code>n</code>初始值为<code>n+1</code></li><li>在PAT中，一直有一个<code>段错误</code>无法通过,在牛客网中则可以通过。</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 记录输入的值，每次重建并查集,同时计算连通分量，连通分量-2就是需要链接的数量。</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1010</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span> &#123;</span><br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> count;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; parent;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; sz;<br>    <span class="hljs-keyword">public</span>:<br>    UnionFind(<span class="hljs-keyword">int</span> n) &#123;<br>        count = n;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            parent.push_back(i);<br>            sz.push_back(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (x != parent[x]) &#123; <span class="hljs-comment">// 路径压缩</span><br>            parent[x] = find(parent[x]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> parent[x];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quick_union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> w)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> vR = find(v), wR = find(w);<br>        <span class="hljs-keyword">if</span> (vR == wR ) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (sz[vR] &gt; sz[wR]) &#123;<br>            parent[wR] = vR;<br>            sz[vR] += sz[wR];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            parent[vR] = wR;<br>            sz[wR] += sz[vR];<br>        &#125;<br>        count--;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">connected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> w)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> find(v) == find(w);<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, m, k;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; cityMap[maxn];<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;k);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">int</span> v, w;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;v, &amp;w); <span class="hljs-comment">// 输入两条边</span><br>        cityMap[i].push_back(v);<br>        cityMap[i].push_back(w);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123; <span class="hljs-comment">// 开始查询</span><br>        <span class="hljs-keyword">int</span> cityID;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;cityID);<br>        <span class="hljs-function">UnionFind <span class="hljs-title">uf</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">// 城市编号是1-n，所以需要传入n+1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123; <span class="hljs-comment">// 每次重建并查集，重新计算连通分量。</span><br>            <span class="hljs-keyword">int</span> v = cityMap[j][<span class="hljs-number">0</span>], w = cityMap[j][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (v == cityID || w == cityID) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (!uf.connected(v,w)) &#123;uf.quick_union(v,w);&#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span> ans = uf.getCount() - <span class="hljs-number">3</span> &gt; <span class="hljs-number">0</span> ? uf.getCount() - <span class="hljs-number">3</span>: <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans); <span class="hljs-comment">// 减去被删除的连通分量，0位置的连通分量，需要修复的一个分量。</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>本代码在PAT中有一个段错误，把代码复制到牛客网中，有一个用例无法通过。牛客网可以看到该测试用例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">1 0 1<br>1<br></code></pre></td></tr></table></figure><p>这里只需要在程序最后加一个判断就可以通过牛客网的用例。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> ans = uf.getCount() - <span class="hljs-number">3</span> &gt; <span class="hljs-number">0</span> ? uf.getCount() - <span class="hljs-number">3</span>: <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>但是PAT中的<code>段错误</code>的用例是什么还不知道。。。</p>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
      <tag>union-find</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1053 Path of Equal Weight</title>
    <link href="/2021/01/16/1053-Path-of-Equal-Weight/"/>
    <url>/2021/01/16/1053-Path-of-Equal-Weight/</url>
    
    <content type="html"><![CDATA[<h1 id="1053-Path-of-Equal-Weight"><a href="#1053-Path-of-Equal-Weight" class="headerlink" title="1053 Path of Equal Weight"></a>1053 Path of Equal Weight</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/mR0f9v.png" alt="mR0f9v"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><div class="note note-success">            <p>重点：多条路径的时候如何以递减方式输出。</p>          </div><p>本题不是很难，目标是<strong>输出根到叶子路径权值和为给值的的路径</strong>。</p><p>难点是输出的时候如何路径按照权值大小以递减方式进行输出。在给定子结点后，可以对子结点根据权重从大到小进行排序。然后遍历的时候自然也是结点自然也是从大到小遍历，可以直接输出路径。</p><p>根结点到叶子路径如何实现。方法有很多，这里使用<code>vector</code>模拟一个<strong>栈</strong>，因为<code>C++</code>的<code>stack</code>无法进行遍历输出。所以采用<code>vector</code>的<code>push_back</code> <code>pop_back</code>模拟一个栈。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">101</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span> &#123;</span><br>    <span class="hljs-keyword">int</span> weight;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; children;<br>&#125;treenode[maxn];<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> treenode[a].weight &gt; treenode[b].weight;<br>&#125;<br><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; path; <span class="hljs-comment">// 使用vector模拟栈，因为等会需要遍历输出路径。stack无法实现遍历输出</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> root, <span class="hljs-keyword">int</span> w, <span class="hljs-keyword">int</span> s, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; path)</span> </span>&#123;<br>    path.push_back(root);<br>    w += treenode[root].weight;<br>    <span class="hljs-keyword">if</span> (treenode[root].children.size() == <span class="hljs-number">0</span> &amp;&amp; w == s) &#123; <span class="hljs-comment">// 找到一条路径,输出该路径</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; path.size(); i++) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, treenode[path[i]].weight);<br>            <span class="hljs-keyword">if</span> (i &lt; path.size() - <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 遍历子结点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; treenode[root].children.size(); i++) &#123;<br>        dfs(treenode[root].children[i], w, s, path);<br>    &#125;<br>    path.pop_back();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, m, s, w, parent, child, k;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;s);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123; <span class="hljs-comment">// 设置权重</span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;w);<br>        treenode[i].weight = w;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123; <span class="hljs-comment">// 设置子结点</span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;parent, &amp;k);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; k; j++) &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;child);<br>            treenode[parent].children.push_back(child);<br>        &#125;<br>        <span class="hljs-comment">// 按权重开始排序，等会直接可以输出</span><br>        sort(treenode[parent].children.begin(), treenode[parent].children.end(), cmp);<br>    &#125;<br>    dfs(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,s,path);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
      <tag>dfs</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集总结</title>
    <link href="/2021/01/16/%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%80%BB%E7%BB%93/"/>
    <url>/2021/01/16/%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><blockquote><p>参考自《算法4》</p></blockquote><p>算法API</p><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/guUjRV.png" alt="guUjRV"></p><ul><li>union() 将两个不同分量中的结点归并</li><li>find() 返回给定结点所在的连通分量标识</li><li>connected() 判断两个结点是否存在同一连通分量中</li><li>count() 返回连通分量个数，每次归并两个结点，连通分量数量-1</li></ul><p>union-find的实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UF</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, N</span>):</span><br>        self.count = N<br>        self.<span class="hljs-built_in">id</span> = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(N)) <span class="hljs-comment"># 初始化</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">count</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.count<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">connected</span>(<span class="hljs-params">self, p, q</span>):</span><br>        <span class="hljs-keyword">return</span> self.find(p) == self.find(q)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find</span>(<span class="hljs-params">self, p</span>):</span><br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">union</span>(<span class="hljs-params">self, p, q</span>):</span><br><span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    data = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>], [<span class="hljs-number">1</span>,<span class="hljs-number">4</span>], [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>]]<br>    size = <span class="hljs-built_in">len</span>(data)<br>    uf = UF(size + <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> v, w <span class="hljs-keyword">in</span> data:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> uf.connected(v, w):<br>            uf.union(v, w)<br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>三种不同方式</p><ul><li><code>quick-find</code></li><li><code>quick-union</code></li><li><code>加权quick-union</code></li></ul><h3 id="quick-find"><a href="#quick-find" class="headerlink" title="quick-find"></a>quick-find</h3><p>重点：实现<code>find()</code>的快速查找</p><p>属于同一连通分量的<code>id[i]</code>值都应该相同。</p><p>实现一</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find</span>(<span class="hljs-params">self, p</span>):</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">id</span>[p]<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">union</span>(<span class="hljs-params">slef, p, q</span>):</span><br>p_id, q_id = self.find(p), self.find(q)<br><span class="hljs-keyword">if</span> p_id == q_id: <span class="hljs-keyword">return</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(<span class="hljs-built_in">id</span>)):<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">id</span>[i] == p_id:<br><span class="hljs-built_in">id</span>[i] = q_id <span class="hljs-comment"># 将所有属于连通分量p_id的结点挂到q_id上</span><br>self.count -= <span class="hljs-number">1</span> <span class="hljs-comment"># 两个连通分量合并后，总连通分量数量-1</span><br></code></pre></td></tr></table></figure><p>分析</p><ul><li>find() 速度很快，每次查找执行操作都是$O(1)$</li><li>union() 每次都要遍历数组，执行操作$O(n)$。数据量过大时不适用。</li></ul><p>由于<code>union()</code>操作比较耗时，下面介绍第二种方法</p><h3 id="quick-union"><a href="#quick-union" class="headerlink" title="quick-union"></a>quick-union</h3><p>重点：提升<code>union()</code>的速度。</p><p>这里需要重新定义一下<code>id</code>变量的意义，之前方法一中，该变量的意义是<strong>标识一个连通分量</strong>。但是在这里，我们使用<code>id</code>表示的是<strong>同一连通分量中，另一个结点的id</strong>。为了混淆，重新写一下上面的代码，并且使用<code>parent</code>来替换<code>id</code>,<code>parent</code>表示<strong>在同一连通分量中，当前结点的上一个结点是谁，有可能该结点是本身</strong></p><p>在实现<code>find()</code>的方法时候，通过<code>parent</code>找到它的上一个结点，再继续找上一个结点的上一个结点。最终找到根结点（根结点即是指向自己的结点）。所以当两个结点找到同一个根结点，则证明它们在同一连通分量中。</p><p>而在<code>union</code>中则需要维持这个关系，找到两个结点的根结点。然后将其中一个根结点指向另一个根结点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuickUnionUF</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, N</span>):</span><br>        self.count = N<br>        self.parent = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(N)) <span class="hljs-comment"># 初始化</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">count</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.count<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">connected</span>(<span class="hljs-params">self, p, q</span>):</span><br>        <span class="hljs-keyword">return</span> self.find(p) == self.find(q)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find</span>(<span class="hljs-params">self, p</span>):</span> <span class="hljs-comment"># 寻找根结点</span><br><span class="hljs-keyword">while</span> p ¡= self.parent[p]: p = self.parent[p]<br><span class="hljs-keyword">return</span> p<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">union</span>(<span class="hljs-params">self, p, q</span>):</span><br>p_root, q_root = self.find(p), self.find(q)<br><span class="hljs-keyword">if</span> p_root == q_root: <span class="hljs-keyword">return</span><br>self.parent[p_root] = q_root <span class="hljs-comment"># 合并，将其中一个根结点挂在到另一个根结点</span><br>self.count -= <span class="hljs-number">1</span> <span class="hljs-comment"># 连通分量数量 - 1</span><br><span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p><code>quick-union</code>的实现形成了一个树形结构。</p><h3 id="加权quick-union"><a href="#加权quick-union" class="headerlink" title="加权quick-union"></a>加权quick-union</h3><p>重点：提升效率，减少树的高度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WeightQuickUnionUF</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, N</span>):</span><br>        self.count = N<br>        self.parent = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(N)) <span class="hljs-comment"># 初始化</span><br>self.sz = [<span class="hljs-number">1</span>] * N <span class="hljs-comment"># 每个连通分量根结点的权重</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">count</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.count<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">connected</span>(<span class="hljs-params">self, p, q</span>):</span><br>        <span class="hljs-keyword">return</span> self.find(p) == self.find(q)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find</span>(<span class="hljs-params">self, p</span>):</span> <span class="hljs-comment"># 寻找根结点</span><br><span class="hljs-keyword">while</span> p ¡= self.parent[p]: p = self.parent[p]<br><span class="hljs-keyword">return</span> p<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">union</span>(<span class="hljs-params">self, p, q</span>):</span><br>p_root, q_root = self.find(p), self.find(q)<br><span class="hljs-keyword">if</span> p_root == q_root: <span class="hljs-keyword">return</span><br><br><span class="hljs-comment"># 根据权重，将权重小的根结点挂在到权重大的根结点上</span><br><span class="hljs-keyword">if</span> self.sz[p_root] &gt; self.sz[q_root]:<br>self.parent[q_root] = p_root<br>self.sz[p_root] += self.sz[q_root]<br><span class="hljs-keyword">else</span>:<br>self.parent[p_root] = q_root<br>self.sz[q_root] += self.sz[p_root]<br><br>self.count -= <span class="hljs-number">1</span> <span class="hljs-comment"># 连通分量数量 - 1</span><br><span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><h2 id="绝招：路径压缩的加权quick-union"><a href="#绝招：路径压缩的加权quick-union" class="headerlink" title="绝招：路径压缩的加权quick-union"></a>绝招：路径压缩的加权quick-union</h2><p>重点：检查每个结点的同时，直接将该结点链接到它的根结点。</p><p>因为<code>quick-union</code>已经无法在优化了，所以只能从<code>quick-find</code>入手，对<code>find</code>方法进行下手。将每次在查找路径中遇到的结点链接到根结点上。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CompressRouteWeightQuickUnionUF</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, N</span>):</span><br>        self.count = N<br>        self.parent = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(N)) <span class="hljs-comment"># 初始化</span><br>self.sz = [<span class="hljs-number">1</span>] * N <span class="hljs-comment"># 每个连通分量根结点的权重</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">count</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.count<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">connected</span>(<span class="hljs-params">self, p, q</span>):</span><br>        <span class="hljs-keyword">return</span> self.find(p) == self.find(q)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find</span>(<span class="hljs-params">self, p</span>):</span> <span class="hljs-comment"># 寻找根结点</span><br><span class="hljs-keyword">if</span> (p != self.parent[p]):<br>self.parent[p] = self.find(self.parent[p]) <span class="hljs-comment"># 将每一个结点都链接到根结点上</span><br><span class="hljs-keyword">return</span> self.parent[p] <span class="hljs-comment"># 最后返回根结点的值</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">union</span>(<span class="hljs-params">self, p, q</span>):</span><br>p_root, q_root = self.find(p), self.find(q)<br><span class="hljs-keyword">if</span> p_root == q_root: <span class="hljs-keyword">return</span><br><br><span class="hljs-comment"># 根据权重，将权重小的根结点挂在到权重大的根结点上</span><br><span class="hljs-keyword">if</span> self.sz[p_root] &gt; self.sz[q_root]:<br>self.parent[q_root] = p_root<br>self.sz[p_root] += self.sz[q_root]<br><span class="hljs-keyword">else</span>:<br>self.parent[p_root] = q_root<br>self.sz[q_root] += self.sz[p_root]<br><br>self.count -= <span class="hljs-number">1</span> <span class="hljs-comment"># 连通分量数量 - 1</span><br><span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p>最后通过此方法，得到的是一个扁平的树。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>leetcode</tag>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1090 Highest Price in Supply Chain</title>
    <link href="/2021/01/15/1090-Highest-Price-in-Supply-Chain/"/>
    <url>/2021/01/15/1090-Highest-Price-in-Supply-Chain/</url>
    
    <content type="html"><![CDATA[<h1 id="1090-Highest-Price-in-Supply-Chain"><a href="#1090-Highest-Price-in-Supply-Chain" class="headerlink" title="1090 Highest Price in Supply Chain"></a>1090 Highest Price in Supply Chain</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/l1FlAd.png" alt="题目"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>给出一个供应链网络，其中有三类成员</p><ul><li>retailers</li><li>distributors</li><li>suppliers</li></ul><p>输入分析</p><p>首先输入三个参数</p><ul><li>$N$: 供应网络上成员的数量，成员的ID范围 $0 \sim N - 1$</li><li>$P$: 顶级（根）供应商的每件货物的价格</li><li>$r$: 每一级传下来增加的价格百分比。</li></ul><p>接下来是$N$个输入。每个输入假设叫做<code>S_i</code>。<code>S_i</code>别是的是第$i$个成员的供应商是谁。</p><p>输出分析</p><p>输出到零售商最高的价值和拥有最高价格的零售商的数量。</p><p>根据上面分析。转化为树的题目，即<strong>求一棵树最大深度的叶子结点数量和最大深度</strong>。</p><p><del>考虑使用静态二叉树，其结构如下,因为不需要存储数据，只需要存储子结点即可</del>。</p><p>本题可以直接使用<code>vector</code>数组来表示一个静态二叉树，索引表示该父结点<code>id</code>,索引內的数组表示子结点的<code>id</code>,结构如下。(代码部分暂时使用原来的静态二叉树，不做改动。)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment">const int maxn = 100010;</span><br><span class="hljs-comment">struct TreeNode&#123;</span><br><span class="hljs-comment">    vector&lt;int&gt; children;</span><br><span class="hljs-comment">&#125;treenode[maxn];</span><br><span class="hljs-comment">**/</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; treenode[maxn];<br></code></pre></td></tr></table></figure><p>然后在输入数据的时候构建一个树，将输入的<code>id</code>作为树的索引，而当前索引<code>i</code>则是树<code>id</code>的子结点。</p><p>⚠️ 当<code>id=-1</code>是需要记录一下根结点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;id);<br><span class="hljs-keyword">if</span> (id != <span class="hljs-number">-1</span>) &#123;treenode[id].children.push_back(i);&#125;<br><span class="hljs-keyword">else</span> &#123;root = i;&#125; <span class="hljs-comment">// 根结点</span><br>&#125;<br></code></pre></td></tr></table></figure><p>最后使用<code>BFS</code>对每一层进行遍历。其中每一层的数量正好是栈的数量<code>q.size()</code>。所以只需要在每一层不断更新<code>highestPrice,maxNum</code>两个变量即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 最后一层有多少个叶子结点。然后计算出它的最高价格</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">100010</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>&#123;</span><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; children;<br>&#125;treenode[maxn];<br><br><span class="hljs-keyword">int</span> n; <span class="hljs-comment">// n个供应商，id供应商id，根供应商</span><br><span class="hljs-keyword">double</span> P, r;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> root)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> depth = <span class="hljs-number">0</span>, maxNum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">double</span> highestPrice = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q;<br>    q.push(root);<br>    <span class="hljs-keyword">while</span> (!q.empty()) &#123;<br>        <span class="hljs-keyword">int</span> size = q.size();<br>        maxNum = size;<br>        highestPrice = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            <span class="hljs-keyword">int</span> node = q.front(); q.pop();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; treenode[node].children.size(); j++) &#123;<br>                q.push(treenode[node].children[j]);<br>            &#125;<br>        &#125;<br>        highestPrice = P * <span class="hljs-built_in">pow</span>(<span class="hljs-number">1</span>+r, depth++);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2lf %d\n&quot;</span>, highestPrice, maxNum);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> id, root;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%lf%lf&quot;</span>, &amp;n, &amp;P, &amp;r);<br>    r /= <span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;id);<br>        <span class="hljs-keyword">if</span> (id != <span class="hljs-number">-1</span>) &#123;treenode[id].children.push_back(i);&#125;<br>        <span class="hljs-keyword">else</span> &#123;root = i;&#125; <span class="hljs-comment">// 根结点</span><br>    &#125;<br>    bfs(root);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
      <tag>bfs</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BFS遍历模板</title>
    <link href="/2021/01/15/BFS%E9%81%8D%E5%8E%86%E6%A8%A1%E6%9D%BF/"/>
    <url>/2021/01/15/BFS%E9%81%8D%E5%8E%86%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="BFS遍历模板"><a href="#BFS遍历模板" class="headerlink" title="BFS遍历模板"></a>BFS遍历模板</h1><div class="note note-warning">            <p>有两种</p><ul><li>以结点为单位进行搜索，适用于<strong>图</strong></li><li>以层为单位进行搜索，适用于<strong>树</strong></li></ul>          </div><h2 id="结点为单位：图"><a href="#结点为单位：图" class="headerlink" title="结点为单位：图"></a>结点为单位：图</h2><p>C++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">def <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>visited[x] = <span class="hljs-literal">true</span>;<br><span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q;<br>q.push(x);<br><span class="hljs-keyword">while</span> (!q.empty()) &#123;<br><span class="hljs-keyword">int</span> node = q.front();<br>q.pop();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; graphic[node].size(); i++) &#123;<br><span class="hljs-keyword">if</span> (!visited[graphic[node][i]]) &#123;<br>q.push(graphic[node][i]);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">BFS</span>(<span class="hljs-params">x</span>):</span><br>    visit(x)<br>    bfs = collections.deque([x])<br>    <span class="hljs-keyword">while</span> bfs:<br>        v = bfs.popleft()<br>        <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> neighbor(v):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> visited(n):<br>                visit(n)<br>                bfs.append(n)<br>    <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><h2 id="以层为单位：树"><a href="#以层为单位：树" class="headerlink" title="以层为单位：树"></a>以层为单位：树</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(Node* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> depth = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">queue</span>&lt;Node*&gt; q;<br>        q.push(root);<br>        <span class="hljs-keyword">while</span> (!q.empty()) &#123;<br>            <span class="hljs-keyword">int</span> size = q.size();<br><span class="hljs-comment">// 操作。这里为计算树的深度</span><br>            depth++;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                Node* node = q.front();<br>                q.pop();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; node-&gt;children.size(); j++) &#123;<br>                    q.push(node-&gt;children[j]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> depth;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">BFS</span>(<span class="hljs-params">x</span>):</span><br>    visit(x)<br>    bfs = collections.deque([x])<br>    <span class="hljs-keyword">while</span> bfs:<br>        num_level = <span class="hljs-built_in">len</span>(bfs)<br>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_level)<br>            v = bfs.popleft()<br>            <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> neighbor(v):<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> visited(v):<br>                    visit(n)<br>                    bfs.append(n)<br>    <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
      <tag>图</tag>
      
      <tag>bfs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1079 Total Sales of Supply Chain</title>
    <link href="/2021/01/15/1079-Total-Sales-of-Supply-Chain/"/>
    <url>/2021/01/15/1079-Total-Sales-of-Supply-Chain/</url>
    
    <content type="html"><![CDATA[<h1 id="1079-Total-Sales-of-Supply-Chain"><a href="#1079-Total-Sales-of-Supply-Chain" class="headerlink" title="1079 Total Sales of Supply Chain"></a>1079 Total Sales of Supply Chain</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/vlJ1r4.png" alt="题目"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先分析题目想表达什么意思。</p><p>一个供应链网络有三类角色</p><ul><li>retailers</li><li>distributors</li><li>suppliers</li></ul><p>输入分析</p><p>首先输入三个参数</p><ul><li>$N$: 供应网络上成员的数量，成员的ID范围 $0 \sim N - 1$</li><li>$P$: 顶级（根）供应商的每件货物的价格</li><li>$r$: 每一级传下来增加的价格百分比。</li></ul><p>接下来是$N$个输入。</p><p>$K_i \quad ID[1] \quad ID[2] … ID[K_i]$</p><ul><li>$i$表示第$i$个供应商。</li><li>$K_i$表示第$i$个供应商供应成员的数量。</li><li>$ID$，则是成员的$ID$。</li><li>⭐️其中$K_i = 0$表示的是$ID=i$的成员是零售商，然后后面那个数则表示该零售商进货的数量。</li></ul><p>根据题目中的输入，可以得到下面这个树形图。</p><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/l7lba9.png" alt="l7lba9"></p><p>因此题目要求的就是到零售商这一级的总销售额。</p><p>$$<br>1.8*((7+9)<em>(1+0.01)^2 + (4+3)</em>(1+0.01)^3)=42.4<br>$$</p><p>根据上面分析。这里使用静态二叉树。我们需要将数据分成两种</p><ul><li>非叶子结点。$K_i!=0$的结点。该结点需要存储<strong>供应链的下一级(子结点)</strong></li><li>叶子结点。$K_i=0$的结点。该结点需要存储<strong>进货量</strong>。</li></ul><p>然后使用<code>BFS,DFS</code>求出叶子结点深度。在计算结果即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>C++</p><blockquote><p>bfs和dfs方法两者都写了，把注释取消即可。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">100010</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>&#123;</span><br>    <span class="hljs-keyword">int</span> val;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; children;<br>&#125;treenode[maxn];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> idx, <span class="hljs-keyword">int</span> depth, <span class="hljs-keyword">double</span> r, <span class="hljs-keyword">double</span>&amp; ans)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (treenode[idx].children.size() == <span class="hljs-number">0</span>) &#123;<br>        ans += treenode[idx].val * <span class="hljs-built_in">pow</span>(<span class="hljs-number">1</span> + r, depth);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; treenode[idx].children.size(); i++) &#123;<br>        dfs(treenode[idx].children[i], depth + <span class="hljs-number">1</span>, r, ans);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> idx, <span class="hljs-keyword">int</span> depth, <span class="hljs-keyword">double</span> r, <span class="hljs-keyword">double</span>&amp; ans)</span> </span>&#123;<br>    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q;<br>    q.push(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">while</span> (!q.empty()) &#123;<br>        <span class="hljs-keyword">int</span> size = q.size();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>             <span class="hljs-keyword">int</span> node = q.front();<br>            q.pop();<br>            <span class="hljs-keyword">if</span> (treenode[node].children.size() == <span class="hljs-number">0</span>) &#123;<br>                ans += treenode[node].val * <span class="hljs-built_in">pow</span>(<span class="hljs-number">1</span> + r, depth);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; treenode[node].children.size(); i++) &#123;<br>                    q.push(treenode[node].children[i]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        depth++;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-keyword">double</span> P, r;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%lf%lf&quot;</span>, &amp;n, &amp;P, &amp;r);<br>    <span class="hljs-keyword">int</span> val, k;<br>    r /= <span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;k);<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// k = 0证明是叶子结点</span><br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;treenode[i].val);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; k; j++) &#123;<br>                <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;val);<br>                treenode[i].children.push_back(val);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">double</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// dfs(0,0,r,ans);</span><br>    bfs(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,r,ans);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.1lf\n&quot;</span>, P * ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
      <tag>dfs</tag>
      
      <tag>bfs</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1102 Invert a Binary Tree</title>
    <link href="/2021/01/15/1102-Invert-a-Binary-Tree/"/>
    <url>/2021/01/15/1102-Invert-a-Binary-Tree/</url>
    
    <content type="html"><![CDATA[<h1 id="1102-Invert-a-Binary-Tree"><a href="#1102-Invert-a-Binary-Tree" class="headerlink" title="1102 Invert a Binary Tree"></a>1102 Invert a Binary Tree</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/wAVNFn.png" alt="wAVNFn"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><div class="note note-warning">            <p>难点：输入数据的处理</p>          </div><ol><li>使用静态二叉树结构</li><li>设置一个bool数组，假设所有结点是根结点。当读取子结点的时候，设置子结点为false</li><li>使用后序遍历交换两边</li><li>使用层次和中序遍历输出结果</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 1. 使用静态二叉树结构</span><br><span class="hljs-comment">// 2. 设置一个bool数组，假设所有结点是根结点。当读取子结点的时候，设置子结点为false</span><br><span class="hljs-comment">// 3. 使用后序遍历交换两边</span><br><span class="hljs-comment">// 4. 使用层次和中序遍历输出结果</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">10010</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>&#123;</span><br>    <span class="hljs-keyword">int</span> left, right;<br>&#125;treenode[maxn];<br><br><span class="hljs-keyword">bool</span> isRoot[maxn]; <span class="hljs-comment">// 无法设置为true，这样只可以设置第一个值为true。但是设置为false却可以。</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ch2num</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;-&#x27;</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;<br>    isRoot[c - <span class="hljs-string">&#x27;0&#x27;</span>] = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 子结点</span><br>    <span class="hljs-keyword">return</span> c - <span class="hljs-string">&#x27;0&#x27;</span>;<br>&#125;<br><br><span class="hljs-comment">// 交换左右子树</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">posttravel</span><span class="hljs-params">(<span class="hljs-keyword">int</span> root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span>;<br>    posttravel(treenode[root].left);<br>    posttravel(treenode[root].right);<br>    swap(treenode[root].left, treenode[root].right);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> root, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q;<br>    q.push(root);<br>    <span class="hljs-keyword">while</span> (!q.empty()) &#123;<br>        <span class="hljs-keyword">int</span> node = q.front();<br>        q.pop();<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, node);<br>        <span class="hljs-keyword">if</span> (--n) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);&#125;<br>        <span class="hljs-keyword">if</span> (treenode[node].left != <span class="hljs-number">-1</span>) q.push(treenode[node].left);<br>        <span class="hljs-keyword">if</span> (treenode[node].right != <span class="hljs-number">-1</span>) q.push(treenode[node].right);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">intravel</span><span class="hljs-params">(<span class="hljs-keyword">int</span> root, <span class="hljs-keyword">int</span>&amp; n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span>;<br>    intravel(treenode[root].left, n);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, root);<br>    <span class="hljs-keyword">if</span> (--n) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);&#125;<br>    intravel(treenode[root].right, n);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(isRoot, <span class="hljs-literal">true</span>, <span class="hljs-keyword">sizeof</span>(isRoot)); <span class="hljs-comment">// 需要引入头文件 &lt;memory.h&gt; or &lt;string.h&gt;</span><br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-keyword">char</span> c1, c2;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        getchar(); <span class="hljs-comment">//吸收回车字符</span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c %c&quot;</span>, &amp;c1, &amp;c2);<br>        treenode[i].left = ch2num(c1);<br>        treenode[i].right = ch2num(c2);<br>    &#125;<br>    <span class="hljs-keyword">int</span> root = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (isRoot[i]) &#123;<br>            root = i;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    posttravel(root);<br>    bfs(root, n);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    intravel(root, n);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><code>memset</code>的使用需要引入头文件<code>memory.h</code> or <code>string.h</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1086 Tree Traversals Again</title>
    <link href="/2021/01/14/1086-Tree-Traversals-Again/"/>
    <url>/2021/01/14/1086-Tree-Traversals-Again/</url>
    
    <content type="html"><![CDATA[<h1 id="1086-Tree-Traversals-Again"><a href="#1086-Tree-Traversals-Again" class="headerlink" title="1086 Tree Traversals Again"></a>1086 Tree Traversals Again</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/Fo0YeY.png" alt="Fo0YeY"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本题使用栈模拟先序遍历和中序遍历，其中</p><ul><li><code>push</code>: 1,2,3,4,5,6 为先序遍历</li><li><code>pop</code>: 3,2,4,1,6,5 为中序遍历</li></ul><p>输出它的后续遍历。因此可以先使用栈储存它的输入，同时构建<code>preorder, inorder</code>序列。再通过<strong>先序遍历和中序遍历求出后序遍历</strong></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; preorder, inorder;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span> &#123;</span><br>    <span class="hljs-keyword">int</span> val;<br>    TreeNode *left, *right;<br>&#125;;<br><br><span class="hljs-function">TreeNode* <span class="hljs-title">createTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> preL, <span class="hljs-keyword">int</span> preR, <span class="hljs-keyword">int</span> inL, <span class="hljs-keyword">int</span> inR, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; preorder, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (preL &gt; preR) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    TreeNode *root = <span class="hljs-keyword">new</span> TreeNode;<br>    root-&gt;val = preorder[preL];<br>    <span class="hljs-keyword">int</span> mid = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (mid = inL; mid &lt;= inR; mid++) &#123;<br>        <span class="hljs-keyword">if</span> (inorder[mid] == preorder[preL]) <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> leftNum = mid - inL;<br>    root-&gt;left = createTree(preL + <span class="hljs-number">1</span>, preL + leftNum, inL, mid - <span class="hljs-number">1</span>, preorder, inorder);<br>    root-&gt;right = createTree(preL + leftNum + <span class="hljs-number">1</span>, preR, mid + <span class="hljs-number">1</span>, inR, preorder, inorder);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">posttravel</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> &amp;n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    posttravel(root-&gt;left, n);<br>    posttravel(root-&gt;right, n);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, root-&gt;val);<br>    <span class="hljs-keyword">if</span> (--n) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">char</span> s[<span class="hljs-number">5</span>];<br>    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; st;<br>    <span class="hljs-keyword">int</span> n, val;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>*n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, s);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(s, <span class="hljs-string">&quot;Push&quot;</span>) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;val);<br>            st.push(val);<br>            preorder.push_back(val);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            inorder.push_back(st.top());<br>            st.pop();<br>        &#125;<br>    &#125;<br>    TreeNode* root = createTree(<span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, preorder, inorder);<br>    posttravel(root, n);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
      <tag>中序遍历</tag>
      
      <tag>二叉树</tag>
      
      <tag>先序遍历</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>105. 从前序与中序遍历序列构造二叉树</title>
    <link href="/2021/01/14/105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2021/01/14/105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/8Fzs61.png" alt="8Fzs61"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>参考<a href="https://emhui.fun/2021/01/14/106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/">106. 从中序与后序遍历序列构造二叉树</a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; preorder, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> createTree(<span class="hljs-number">0</span>, preorder.size() - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, inorder.size() - <span class="hljs-number">1</span>, preorder, inorder);<br>    &#125;<br><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">createTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> preL, <span class="hljs-keyword">int</span> preR, <span class="hljs-keyword">int</span> inL, <span class="hljs-keyword">int</span> inR, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; preorder, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (preL &gt; preR) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        TreeNode *root = <span class="hljs-keyword">new</span> TreeNode;<br>        root-&gt;val = preorder[preL];<br>        <span class="hljs-keyword">int</span> mid = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (mid = inL; mid &lt;= inR; mid++) &#123;<br>            <span class="hljs-keyword">if</span> (inorder[mid] == preorder[preL]) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> leftNum = mid - inL;<br>        root-&gt;left = createTree(preL + <span class="hljs-number">1</span>, preL + leftNum, inL, mid - <span class="hljs-number">1</span>, preorder, inorder);<br>        root-&gt;right = createTree(preL + leftNum + <span class="hljs-number">1</span>, preR, mid + <span class="hljs-number">1</span>, inR, preorder, inorder);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>leetcode</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1020 Tree Traversals</title>
    <link href="/2021/01/14/1020-Tree-Traversals/"/>
    <url>/2021/01/14/1020-Tree-Traversals/</url>
    
    <content type="html"><![CDATA[<h1 id="1020-Tree-Traversals"><a href="#1020-Tree-Traversals" class="headerlink" title="1020 Tree Traversals"></a>1020 Tree Traversals</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/SSNibA.png" alt="SSNibA"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本题目的是<strong>给出后续遍历和中序遍历，输出层次遍历</strong>。因此本题分为两步</p><ol><li>根据后序遍历和中序遍历推断出二叉树<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="106. 从中序与后序遍历序列构造二叉树">[1]</span></a></sup>。</li><li>使用BFS层次遍历二叉树。</li></ol><p>这里分析第一点实现的思路:由用后序遍历序列和中序遍历序列来重建二叉树。</p><p>假设递归过程中某步的后序序列区间为[postL, postR],中序序列区间为[inL, inR],那么由后序序列性质可知,后序序列的最后一个元素post[postR]即为根结点。接着需要在中序序列中寻找一个位置k,使得in(k]=postpostR],这样就找到了中序序列中的根结点。易知左子树结点个数为numLeft=k-inL,于是左子树的后序序列区间为[postL, postL + numLeft1],左子树的中序序列区间为[inL, k-1];右子树的后序序列区间为[postL + numLefj),右子树的中序序列区间为k + 1, inR]。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 先构建好二叉树，再用bfs遍历.</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; postorder, inorder;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>&#123;</span><br>    <span class="hljs-keyword">int</span> val;<br>    TreeNode *left, *right;<br>&#125;;<br><br><span class="hljs-function">TreeNode* <span class="hljs-title">createTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> inL, <span class="hljs-keyword">int</span> inR, <span class="hljs-keyword">int</span> postL, <span class="hljs-keyword">int</span> postR, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; inorder, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (postL &gt; postR) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    TreeNode* node = <span class="hljs-keyword">new</span> TreeNode;<br>    node-&gt;val = postorder[postR];<br>    <span class="hljs-keyword">int</span> mid = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (mid = inL; mid &lt;= inR; mid++) &#123; <span class="hljs-comment">// 找到中序遍历的根结点位置</span><br>        <span class="hljs-keyword">if</span> (inorder[mid] == node-&gt;val) <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> leftNum = mid - inL; <span class="hljs-comment">// 左子树的数量</span><br>    node-&gt;left = createTree(inL, mid - <span class="hljs-number">1</span>, postL, postL + leftNum - <span class="hljs-number">1</span>, inorder, postorder);<br>    node-&gt;right = createTree(mid + <span class="hljs-number">1</span>, inR, postL + leftNum, postR - <span class="hljs-number">1</span>, inorder, postorder);<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-built_in">queue</span>&lt;TreeNode*&gt;  q;<br>    q.push(root);<br>    <span class="hljs-keyword">while</span> (!q.empty()) &#123;<br>        TreeNode* node = q.front();<br>        q.pop();<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, node-&gt;val);<br>        n--;<br>        <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);&#125;;<br>        <span class="hljs-keyword">if</span> (node-&gt;left != <span class="hljs-literal">NULL</span>) q.push(node-&gt;left);<br>        <span class="hljs-keyword">if</span> (node-&gt;right != <span class="hljs-literal">NULL</span>) q.push(node-&gt;right);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, val;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;val);<br>        postorder.push_back(val);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;val);<br>        inorder.push_back(val);<br>    &#125;<br>    TreeNode* root = createTree(<span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, inorder, postorder);<br>    bfs(root, n);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><section class="footnotes"><h2>参考</h2><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://emhui.fun/2021/01/14/106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/">106. 从中序与后序遍历序列构造二叉树</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
      <tag>bfs</tag>
      
      <tag>后序遍历</tag>
      
      <tag>中序遍历</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>106. 从中序与后序遍历序列构造二叉树</title>
    <link href="/2021/01/14/106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2021/01/14/106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><div class="note note-warning">            <p>难度：中等</p>          </div><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/qPKWr8.png" alt="qPKWr8"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>分析由用后序遍历序列和中序遍历序列来重建二叉树。</p><p>假设递归过程中某步的后序序列区间为[postL, postR],中序序列区间为[inL, inR],那么由后序序列性质可知,后序序列的最后一个元素post[postR]即为根结点。接着需要在中序序列中寻找一个位置k,使得in(k]=postpostR],这样就找到了中序序列中的根结点。易知左子树结点个数为numLeft=k-inL,于是左子树的后序序列区间为[postL, postL + numLeft1],左子树的中序序列区间为[inL, k-1];右子树的后序序列区间为[postL + numLefj),右子树的中序序列区间为k + 1, inR]。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; inorder, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> createTree(<span class="hljs-number">0</span>, inorder.size() - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, postorder.size() - <span class="hljs-number">1</span>, inorder, postorder);<br>    &#125;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">createTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> inL, <span class="hljs-keyword">int</span> inR, <span class="hljs-keyword">int</span> postL, <span class="hljs-keyword">int</span> postR, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; inorder, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (postL &gt; postR) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        TreeNode* node = <span class="hljs-keyword">new</span> TreeNode;<br>        node-&gt;val = postorder[postR];<br>        <span class="hljs-keyword">int</span> mid = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (mid = inL; mid &lt;= inR; mid++) &#123; <span class="hljs-comment">// 找到中序遍历的根结点位置</span><br>            <span class="hljs-keyword">if</span> (inorder[mid] == node-&gt;val) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> leftNum = mid - inL; <span class="hljs-comment">// 左子树的数量</span><br>        node-&gt;left = createTree(inL, mid - <span class="hljs-number">1</span>, postL, postL + leftNum - <span class="hljs-number">1</span>, inorder, postorder);<br>        node-&gt;right = createTree(mid + <span class="hljs-number">1</span>, inR, postL + leftNum, postR - <span class="hljs-number">1</span>, inorder, postorder);<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>后序遍历</tag>
      
      <tag>leetcode</tag>
      
      <tag>二叉树</tag>
      
      <tag>前序遍历</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1091 Acute Stroke</title>
    <link href="/2021/01/14/1091-Acute-Stroke/"/>
    <url>/2021/01/14/1091-Acute-Stroke/</url>
    
    <content type="html"><![CDATA[<h1 id="1091-Acute-Stroke"><a href="#1091-Acute-Stroke" class="headerlink" title="1091 Acute Stroke"></a>1091 Acute Stroke</h1><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/VMhdDm.png" alt="题目"></p><p>部分专有名词</p><ul><li><code>MBR</code>: (Magnetic Resonance Imaging) 核磁共振成像。</li><li><code>threshold</code>: 门槛,阈值。</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本题意思是<strong>给出一个三维数组,数组元素的取值为0或1。与某一个元素相邻的元素为其上、下、左、右、前、后这6个方向的邻接元素。另外,若干个相邻的”1”称为一个“块” (不必两两相邻,只要与块中某一个”1”相邻,该”1”就在块中),而如果某个块中的“1”的个数不低于T个,那么称这个块为“卒中核心区”。现在需要求解所有卒中核心区中的1的个数之和。</strong></p><p>本题是一个三维的BFS。基本思路是:枚举三维数组中的每一个位置,如果为0,则跳过;如果为1,则使用BFS查询与该位置相邻的6个位置(前提是不出界),判断它们是否为1 (如果某个相邻的位置为1,则同样去查询与该位置相邻的6个位置,直到整个”1”块访问完毕)。而为了防止重复,可以设置一个bool型数组<code>visited</code>来记录每个位置是否在BFS中已入过队。</p><p>其中枚举6个方向的代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> X[<span class="hljs-number">6</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// X方向移动</span><br><span class="hljs-keyword">int</span> Y[<span class="hljs-number">6</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// Y方向移动</span><br><span class="hljs-keyword">int</span> Z[<span class="hljs-number">6</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>&#125;; <span class="hljs-comment">// Z方向移动</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;<br><span class="hljs-keyword">int</span> newX = top.x + X[i];<br><span class="hljs-keyword">int</span> newY = top.y + Y[i];<br><span class="hljs-keyword">int</span> newZ = top.z + Z[i];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 题目意思，计算每个点附近的连通情况，若连通，即1的数量，若该层1的数量大于T则符合条件</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span><br>    <span class="hljs-keyword">int</span> x, y, z;<br>&#125;Node;<br><br><span class="hljs-keyword">int</span> M, N, L, T;<br><br><span class="hljs-keyword">int</span> pixel[<span class="hljs-number">1296</span>][<span class="hljs-number">130</span>][<span class="hljs-number">61</span>]; <span class="hljs-comment">// M N L</span><br><span class="hljs-keyword">bool</span> visited[<span class="hljs-number">1296</span>][<span class="hljs-number">130</span>][<span class="hljs-number">61</span>] = &#123;<span class="hljs-literal">false</span>&#125;; <span class="hljs-comment">// M N L</span><br><br><span class="hljs-keyword">int</span> X[<span class="hljs-number">6</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// X方向移动</span><br><span class="hljs-keyword">int</span> Y[<span class="hljs-number">6</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// Y方向移动</span><br><span class="hljs-keyword">int</span> Z[<span class="hljs-number">6</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>&#125;; <span class="hljs-comment">// Z方向移动</span><br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isVaildNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> z)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || x &gt;= M || y &lt; <span class="hljs-number">0</span> || y &gt;= N || z &lt; <span class="hljs-number">0</span> || z &gt;= L) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (pixel[x][y][z] == <span class="hljs-number">0</span> || visited[x][y][z] == <span class="hljs-literal">true</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> z)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">queue</span>&lt;node&gt; Q;<br>    Node.x = x, Node.y = y, Node.z = z;<br>    Q.push(Node);<br>    visited[x][y][z] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 记住这个一定要写。当前的入队</span><br>    <span class="hljs-keyword">while</span> (!Q.empty()) &#123;<br>        node top = Q.front();<br>        Q.pop();<br>        num++; <span class="hljs-comment">// 满足数量+1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;<br>            <span class="hljs-keyword">int</span> newX = top.x + X[i];<br>            <span class="hljs-keyword">int</span> newY = top.y + Y[i];<br>            <span class="hljs-keyword">int</span> newZ = top.z + Z[i];<br>            <span class="hljs-keyword">if</span> (isVaildNode(newX, newY, newZ)) &#123;<br>                Node.x = newX, Node.y = newY, Node.z = newZ;<br>                Q.push(Node);<br>                visited[newX][newY][newZ] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> num &gt;= T ? num : <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>, &amp;M, &amp;N, &amp;L, &amp;T);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> z = <span class="hljs-number">0</span>; z &lt; L; z++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; M; x++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>; y &lt; N; y++) &#123;<br>                <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;pixel[x][y][z]); <span class="hljs-comment">// 注意xyz顺序</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> z = <span class="hljs-number">0</span>; z &lt; L; z++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; M; x++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>; y &lt; N; y++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (pixel[x][y][z] == <span class="hljs-number">1</span> &amp;&amp; visited[x][y][z] == <span class="hljs-literal">false</span>)&#123;<br>                    ans += bfs(x, y, z);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
      <tag>图</tag>
      
      <tag>bfs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>990. Satisfiability of Equality Equations</title>
    <link href="/2021/01/14/990-Satisfiability-of-Equality-Equations/"/>
    <url>/2021/01/14/990-Satisfiability-of-Equality-Equations/</url>
    
    <content type="html"><![CDATA[<h1 id="990-Satisfiability-of-Equality-Equations"><a href="#990-Satisfiability-of-Equality-Equations" class="headerlink" title="990. Satisfiability of Equality Equations"></a><a href="https://leetcode-cn.com/problems/satisfiability-of-equality-equations/">990. Satisfiability of Equality Equations</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><div class="note note-warning">            <p>难度：中等</p>          </div><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/oY9FRa.png" alt="oY9FRa"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这里考察等式是否成立，若两个值本来就相等，但是出现不等的情况，说明有矛盾，等式不成立。因此可以反过来想，若一个不等式中出现了等式的情况，那么也是有矛盾。所以题目可以转化为<strong>判断一个不等式的两个值在一个连通图中是否连通，若连通，则矛盾，返回false</strong>。使用<strong>并查集</strong>可以判断两个点的连通问题。</p><p>⚠️ 这里使用<code>dict</code>将每个字符与唯一数字进行映射。因为，数组查找元素的速度大于字典。也可以直接使用字典。</p><p>步骤</p><ol><li>使用字典将字符和唯一数字进行映射。</li><li>建立一个<code>parent</code>数组存储每个结点，初始化<code>parent[i]=i</code>。</li><li>对于<code>a==b</code>的等式使用<code>union-find</code>建立一个连通图。</li><li>对<code>a!=b</code>判断是<code>a,b</code>是否连通。若连通，则返回<code>False</code></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">equationsPossible</span>(<span class="hljs-params">self, equations: List[<span class="hljs-built_in">str</span>]</span>) -&gt; bool:</span><br>        order = <span class="hljs-number">0</span><br>        hasmap = &#123;&#125;<br>        <span class="hljs-comment"># 1. 处理数据，将字符与唯一的数字进行映射。</span><br>        <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> equations:<br>            <span class="hljs-keyword">if</span> s[<span class="hljs-number">0</span>] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hasmap.keys():<br>                hasmap[s[<span class="hljs-number">0</span>]] = order<br>                order += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> s[<span class="hljs-number">-1</span>] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hasmap.keys():<br>                hasmap[s[<span class="hljs-number">-1</span>]] = order<br>                order += <span class="hljs-number">1</span><br>        parent = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(hasmap))) <span class="hljs-comment"># 初始化数据</span><br><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find</span>(<span class="hljs-params">p</span>):</span><br>            <span class="hljs-keyword">while</span> p != parent[p]: p = parent[p]<br>            <span class="hljs-keyword">return</span> p<br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">union</span>(<span class="hljs-params">p, q</span>):</span><br>            parent[find(p)] = find(q)<br>        <span class="hljs-comment"># 构建一个连通的并查集</span><br>        <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> equations:<br>            <span class="hljs-keyword">if</span> s[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;=&#x27;</span>:<br>                <span class="hljs-keyword">if</span> find(hasmap[s[<span class="hljs-number">0</span>]]) != find(hasmap[s[<span class="hljs-number">-1</span>]]):<br>                    union(hasmap[s[<span class="hljs-number">0</span>]], hasmap[s[<span class="hljs-number">-1</span>]])<br>        <span class="hljs-comment"># 若本来不连通的出现连通的现象，证明有误</span><br>        <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> equations:<br>            <span class="hljs-keyword">if</span> s[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;!&#x27;</span>:<br>                <span class="hljs-keyword">if</span> find(hasmap[s[<span class="hljs-number">0</span>]]) == find(hasmap[s[<span class="hljs-number">-1</span>]]):<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>复杂度分析</p><ul><li>时间复杂度: $O(n + ClogC)$. $n$是方程数量，$C$是变量总数，合并和查找的时间复杂度是$logC$，但是要遍历每个方程，因此时间复杂度是$ClogC$。</li><li>空间复杂度: $O(C)$, $C$是<code>parent</code>的长度。</li></ul>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>图</tag>
      
      <tag>union-find</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>geoserver通过wfs服务对feature进行增删改查</title>
    <link href="/2021/01/14/geoserver%E9%80%9A%E8%BF%87wfs%E6%9C%8D%E5%8A%A1%E5%AF%B9feature%E8%BF%9B%E8%A1%8C%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/"/>
    <url>/2021/01/14/geoserver%E9%80%9A%E8%BF%87wfs%E6%9C%8D%E5%8A%A1%E5%AF%B9feature%E8%BF%9B%E8%A1%8C%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="GeoServer对feature实现增删改查"><a href="#GeoServer对feature实现增删改查" class="headerlink" title="GeoServer对feature实现增删改查"></a>GeoServer对feature实现增删改查</h1><blockquote><p><a href="http://docs.opengeospatial.org/is/09-025r2/09-025r2.html#351">官方参考文档</a></p></blockquote><h3 id="查询feature"><a href="#查询feature" class="headerlink" title="查询feature"></a>查询feature</h3><p>该功能很简单，具体使用参考之前写的<a href="https://www.jianshu.com/p/3160dc274d07">文档</a></p><h3 id="更新feature"><a href="#更新feature" class="headerlink" title="更新feature"></a>更新feature</h3><p>官方示例</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; ?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">wfs:Transaction</span></span><br><span class="hljs-tag">   <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;2.0.02.0.2&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">service</span>=<span class="hljs-string">&quot;WFS&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.someserver.example.com/myns&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">xmlns:fes</span>=<span class="hljs-string">&quot;http://www.opengis.net/fes/2.0&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">xmlns:wfs</span>=<span class="hljs-string">&quot;http://www.opengis.net/wfs/2.0&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.opengis.net/wfs/2.0</span></span><br><span class="hljs-tag"><span class="hljs-string">                       http://schemas.opengis.net/wfs/2.0.02.0/wfs.xsd&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">wfs:Update</span> <span class="hljs-attr">typeName</span>=<span class="hljs-string">&quot;BuiltUpA_1M&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">wfs:Property</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">wfs:ValueReference</span>&gt;</span>population<span class="hljs-tag">&lt;/<span class="hljs-name">wfs:ValueReference</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">wfs:Value</span>&gt;</span>4070000<span class="hljs-tag">&lt;/<span class="hljs-name">wfs:Value</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">wfs:Property</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">fes:Filter</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">fes:ResourceId</span> <span class="hljs-attr">rid</span>=<span class="hljs-string">&quot;BuiltUpA_1M.10131&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">fes:Filter</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">wfs:Update</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">wfs:Transaction</span>&gt;</span><br></code></pre></td></tr></table></figure><p>示例</p><p>将CHINA改成中国</p><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/svAJ4Z.png" alt="svAJ4Z"></p><p>使用post发送下面的xml文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; ?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">wfs:Transaction</span></span><br><span class="hljs-tag">   <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;2.0.02.0.2&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">service</span>=<span class="hljs-string">&quot;WFS&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.someserver.example.com/myns&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">xmlns:fes</span>=<span class="hljs-string">&quot;http://www.opengis.net/fes/2.0&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">xmlns:wfs</span>=<span class="hljs-string">&quot;http://www.opengis.net/wfs/2.0&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.opengis.net/wfs/2.0</span></span><br><span class="hljs-tag"><span class="hljs-string">                       http://schemas.opengis.net/wfs/2.0.02.0/wfs.xsd&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">wfs:Update</span> <span class="hljs-attr">typeName</span>=<span class="hljs-string">&quot;cesium:0&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">wfs:Property</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">wfs:ValueReference</span>&gt;</span>水流<span class="hljs-tag">&lt;/<span class="hljs-name">wfs:ValueReference</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">wfs:Value</span>&gt;</span>不不不<span class="hljs-tag">&lt;/<span class="hljs-name">wfs:Value</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">wfs:Property</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">fes:Filter</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">fes:ResourceId</span> <span class="hljs-attr">rid</span>=<span class="hljs-string">&quot;0.142&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">fes:Filter</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">wfs:Update</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">wfs:Transaction</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/2tbSGG.png" alt="2tbSGG"></p><p>刷新后即可看到修改成功</p><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/Mjdj1M.png" alt="Mjdj1M"></p><h3 id="同时更新多个feature"><a href="#同时更新多个feature" class="headerlink" title="同时更新多个feature"></a>同时更新多个feature</h3><p>官方示例</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; ?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">wfs:Transaction</span></span><br><span class="hljs-tag">   <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;2.0.02.0.2&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">service</span>=<span class="hljs-string">&quot;WFS&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.someserver.example.com/myns&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">xmlns:fes</span>=<span class="hljs-string">&quot;http://www.opengis.net/fes/2.0&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">xmlns:wfs</span>=<span class="hljs-string">&quot;http://www.opengis.net/wfs/2.0&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.opengis.net/wfs/2.0</span></span><br><span class="hljs-tag"><span class="hljs-string">                       http://schemas.opengis.net/wfs/2.0.02.0/wfs.xsd&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">wfs:Update</span> <span class="hljs-attr">typeName</span>=<span class="hljs-string">&quot;BuiltUpA_1M&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">wfs:Property</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">wfs:ValueReference</span>&gt;</span>populationType<span class="hljs-tag">&lt;/<span class="hljs-name">wfs:ValueReference</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">wfs:Value</span>&gt;</span>CITY<span class="hljs-tag">&lt;/<span class="hljs-name">wfs:Value</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">wfs:Property</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">fes:Filter</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">fes:ResourceId</span> <span class="hljs-attr">rid</span>=<span class="hljs-string">&quot;BuiltUpA_1M.1013&quot;</span>/&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">fes:ResourceId</span> <span class="hljs-attr">rid</span>=<span class="hljs-string">&quot;BuiltUpA_1M.34&quot;</span>/&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">fes:ResourceId</span> <span class="hljs-attr">rid</span>=<span class="hljs-string">&quot;BuiltUpA_1M.24256&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">fes:Filter</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">wfs:Update</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">wfs:Transaction</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在<code>&lt;fes:ResoureId&gt;&lt;/fes:ResourId&gt;</code>中添加多个<code>rid</code>即可。</p><p>示例</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; ?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">wfs:Transaction</span></span><br><span class="hljs-tag">   <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;2.0.02.0.2&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">service</span>=<span class="hljs-string">&quot;WFS&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.someserver.example.com/myns&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">xmlns:fes</span>=<span class="hljs-string">&quot;http://www.opengis.net/fes/2.0&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">xmlns:wfs</span>=<span class="hljs-string">&quot;http://www.opengis.net/wfs/2.0&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.opengis.net/wfs/2.0</span></span><br><span class="hljs-tag"><span class="hljs-string">                       http://schemas.opengis.net/wfs/2.0.02.0/wfs.xsd&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">wfs:Update</span> <span class="hljs-attr">typeName</span>=<span class="hljs-string">&quot;cesium:0&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">wfs:Property</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">wfs:ValueReference</span>&gt;</span>NAME_0<span class="hljs-tag">&lt;/<span class="hljs-name">wfs:ValueReference</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">wfs:Value</span>&gt;</span>中国<span class="hljs-tag">&lt;/<span class="hljs-name">wfs:Value</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">wfs:Property</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">fes:Filter</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">fes:ResourceId</span> <span class="hljs-attr">rid</span>=<span class="hljs-string">&quot;0.142&quot;</span>/&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">fes:ResourceId</span> <span class="hljs-attr">rid</span>=<span class="hljs-string">&quot;0.132&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">fes:Filter</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">wfs:Update</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">wfs:Transaction</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/Qb5aBC.png" alt="Qb5aBC"></p><p>结果</p><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/x5hMbi.png" alt="x5hMbi"></p><h3 id="删除feature"><a href="#删除feature" class="headerlink" title="删除feature"></a>删除feature</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; ?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">wfs:Transaction</span></span><br><span class="hljs-tag">   <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;2.0.02.0.2&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">service</span>=<span class="hljs-string">&quot;WFS&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.someserver.example.com/myns&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">xmlns:fes</span>=<span class="hljs-string">&quot;http://www.opengis.net/fes/2.0&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">xmlns:wfs</span>=<span class="hljs-string">&quot;http://www.opengis.net/wfs/2.0&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.opengis.net/wfs/2.0</span></span><br><span class="hljs-tag"><span class="hljs-string">                       http://schemas.opengis.net/wfs/2.0.02.0/wfs.xsd&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">wfs:Delete</span> <span class="hljs-attr">typeName</span>=<span class="hljs-string">&quot;InWaterA_1M&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">fes:Filter</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">fes:ResourceId</span> <span class="hljs-attr">rid</span>=<span class="hljs-string">&quot;InWaterA_1M.1013&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">fes:Filter</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">wfs:Delete</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">wfs:Transaction</span>&gt;</span><br></code></pre></td></tr></table></figure><p>该功能很简单，我们先保存一个feature的xml文档</p><p>发送下面请求获取一个feature</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">http</span>://localhost:<span class="hljs-number">8080</span>/geoserver/cesium/wms?request=GetFeature&amp;typeNames=cesium:<span class="hljs-number">0</span>&amp;featureID=<span class="hljs-number">0</span>.<span class="hljs-number">134</span>&amp;service=wfs&amp;version=<span class="hljs-number">2</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>该feature如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">wfs:FeatureCollection</span> <span class="hljs-attr">xmlns:xs</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span> <span class="hljs-attr">xmlns:cesium</span>=<span class="hljs-string">&quot;http://geoserver.org/cesium&quot;</span> <span class="hljs-attr">xmlns:wfs</span>=<span class="hljs-string">&quot;http://www.opengis.net/wfs/2.0&quot;</span> <span class="hljs-attr">xmlns:gml</span>=<span class="hljs-string">&quot;http://www.opengis.net/gml/3.2&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="hljs-attr">numberMatched</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">numberReturned</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">timeStamp</span>=<span class="hljs-string">&quot;2020-09-21T02:38:52.053Z&quot;</span> <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.opengis.net/wfs/2.0 http://localhost:8080/geoserver/schemas/wfs/2.0/wfs.xsd http://geoserver.org/cesium http://localhost:8080/geoserver/cesium/wfs?service=WFS<span class="hljs-symbol">&amp;amp;</span>version=2.0.0<span class="hljs-symbol">&amp;amp;</span>request=DescribeFeatureType<span class="hljs-symbol">&amp;amp;</span>typeName=cesium%3A0 http://www.opengis.net/gml/3.2 http://localhost:8080/geoserver/schemas/gml/3.2.1/gml.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">wfs:member</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">cesium:0</span> <span class="hljs-attr">gml:id</span>=<span class="hljs-string">&quot;0.134&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:the_geom</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">gml:MultiSurface</span> <span class="hljs-attr">srsName</span>=<span class="hljs-string">&quot;urn:ogc:def:crs:EPSG::4326&quot;</span> <span class="hljs-attr">srsDimension</span>=<span class="hljs-string">&quot;2&quot;</span> <span class="hljs-attr">gml:id</span>=<span class="hljs-string">&quot;0.134.the_geom&quot;</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">gml:surfaceMember</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">gml:Polygon</span> <span class="hljs-attr">gml:id</span>=<span class="hljs-string">&quot;0.134.the_geom.1&quot;</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">gml:exterior</span>&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">gml:LinearRing</span>&gt;</span><br>                                    <span class="hljs-tag">&lt;<span class="hljs-name">gml:posList</span>&gt;</span>29.81506157 115.72956848 29.82217026 115.71960449 29.82777786 115.71416473 29.83111763 115.70983887 29.8347168 115.70683289 29.84010124 115.70166016 29.8450222 115.69623566 29.84768677 115.69246674 29.85103226 115.6884079 29.85296249 115.68280792 29.85422516 115.67776489 29.8561573 115.67216492 29.85637283 115.67055511 29.85693741 115.66633606 29.85682869 115.66159821 29.85533524 115.65663147 29.85359573 115.65088654 29.85184669 115.64487457 29.85085487 115.64173889 29.850317 115.63832855 29.84844398 115.63366699 29.84682655 115.63008118 29.84588623 115.62283325 29.84552193 115.61641693 29.84498024 115.61184692 29.84428978 115.60660553 29.84382057 115.60006714 29.84374237 115.59405518 29.84334183 115.58800507 29.84311485 115.58010101 29.84339333 115.57376099 29.84266853 115.5676651 29.84222984 115.5619812 29.84182549 115.55593109 29.84131622 115.55099487 29.84058762 115.54489899 29.84057808 115.53814697 29.84034729 115.53024292 29.84062576 115.52390289 29.84190559 115.5173111 29.84304619 115.5121994 29.84264565 115.50952911 29.8418293 115.5051651 29.84661865 115.49472809 29.8494339 115.4878006 29.85424423 115.47364807 29.85790634 115.46347809 29.85978699 115.4585495 29.86179924 115.45496368 29.86443138 115.45159912 29.86746979 115.44799042 29.87176514 115.44335938 29.8758812 115.44062805 29.88026619 115.43777466 29.88619232 115.43497467 29.89163589 115.43313599 29.89594841 115.43138885 29.89977646 115.42862701 29.90291214 115.42562103 29.90578842 115.42156219 29.90798187 115.41753387 29.90940475 115.41378784 29.91155434 115.41007233 29.91537285 115.40641022 29.91927528 115.40319824 29.9222374 115.40179443 29.92589378 115.4012146 29.9312458 115.40172577 29.93623543 115.40338135 29.94021988 115.40458679 29.9441433 115.40550995 29.94849586 115.40536499 29.95268631 115.40349579 29.95589828 115.39878082 29.95940971 115.39259338 29.96587372 115.38524628 29.96989059 115.38088989 29.97303009 115.37814331 29.97774506 115.37429047 29.98273277 115.37200928 29.98750496 115.37026215 29.99247169 115.3671875 29.99629021 115.364151 30.00214005 115.35973358 30.00527573 115.35671997 30.00772858 115.35415649 30.01029205 115.35151672 30.01271057 115.34900665 30.01479149 115.3460083 30.01750183 115.34176636 30.01949883 115.33831024 30.0214901 115.33486176 30.02381134 115.33204651 30.02626038 115.32923889 30.02857971 115.32642365 30.03138161 115.32395935 30.03614426 115.3211441 30.04019165 115.31912994 30.04350662 115.31806183 30.04650116 115.31768799 30.04898453 115.31725311 30.05270004 115.31741333 30.05552483 115.31746674 30.05999184 115.31786346 30.06435966 115.31798553 30.06869698 115.31730652 30.07304955 115.31715393 30.0772171 115.31658173 30.08354378 115.31494904 30.08725166 115.31381989 30.09217262 115.3120575 30.09922218 115.30818939 30.1111927 115.30123138 30.11541557 115.29863739 30.11912155 115.29613495 30.12313652 115.29307556 30.12813759 115.28910065 30.13327789 115.28499603 30.13906097 115.28050995 30.1444664 115.27688599 30.14805031 115.27358246 30.15231323 115.26999664 30.15721703 115.26261902 30.16082573 115.26143646 30.16357231 115.25817108 30.16630936 115.25383759 30.16820335 115.25177765 30.17579651 115.24555969 30.18298531 115.23720551 30.1863575 115.23271942 30.18650627 115.23258972 30.18887138 115.22937775 30.18951416 115.22852325 30.18955421 115.22844696 30.1897068 115.2282486 30.19566727 115.22171021 30.19865799 115.21778107 30.20532036 115.21072388 30.20846367 115.20822906 30.21140099 115.20653534 30.21600151 115.20415497 30.21641541 115.19683075 30.21702385 115.19389343 30.21808243 115.19068146 30.21912956 115.18693542 30.22018433 115.18345642 30.22079849 115.18078613 30.2216568 115.17864227 30.22237015 115.17385864 30.22171402 115.16978455 30.22035789 115.16635895 30.21869469 115.16233826 30.2174511 115.16030121 30.21419525 115.15494537 30.21224022 115.15100861 30.21118164 115.14569092 30.21045685 115.139534 30.20988083 115.13457489 30.20967865 115.13114166 30.20977783 115.12582397 30.21059227 115.1197052 30.21143723 115.11495209 30.21263695 115.10855103 30.21364403 115.10348511 30.21801567 115.09468079 30.22067833 115.09085083 30.22369766 115.0873642 30.22710609 115.08446503 30.23121834 115.08100891 30.2366333 115.07662201 30.24075508 115.07371521 30.24587059 115.0712204 30.2492485 115.07103729 30.25103951 115.07094574 30.25465775 115.07079315 30.25707436 115.07108307 30.2598877 115.0712738 30.26357841 115.07171631 30.26795387 115.07238007 30.26827049 115.07242584 30.269207 115.07273102 30.27189636 115.0736084 30.27635765 115.0754776 30.28105927 115.07752228 30.28686714 115.08094788 30.29125786 115.08210754 30.29518127 115.0830307 30.2984314 115.08317566 30.3024826 115.08247375 30.30809975 115.08152008 30.3150444 115.08013153 30.32249641 115.07880402 30.33215523 115.0772934 30.3367691 115.07607269 30.34120369 115.07541656 30.34636307 115.07381439 30.35124588 115.07247162 30.35485649 115.07098389 30.35965157 115.06918335 30.36444664 115.06738281 30.36911201 115.06557465 30.37454796 115.0623703 30.38142204 115.05864716 30.38635254 115.05448914 30.39106178 115.05059814 30.39387131 115.04644012 30.39901924 115.03996277 30.40122986 115.03618622 30.40428543 115.03154755 30.40491867 115.02967834 30.40555573 115.02778625 30.40662766 115.02509308 30.40788078 115.02080536 30.40950584 115.01331329 30.4114933 115.01499176 30.41604424 115.01882172 30.42029572 115.0174408 30.43195534 115.01416016 30.43951225 115.01356506 30.44041443 115.01196289 30.43627548 115.00934601 30.4314537 115.00779724 30.4305191 115.00489044 30.43590927 115.00042725 30.4366684 114.99980164 30.44945145 114.99359131 30.4604969 114.99330139 30.46328545 114.9932251 30.46479607 114.99318695 30.4792614 114.99756622 30.48962593 115.00335693 30.49467087 115.00617981 30.50706863 115.010849 30.52150536 115.01151276 30.52701187 115.01279449 30.53433609 115.0121994 30.54283905 115.01610565 30.54654884 115.02244568 30.54818916 115.02826691 30.54707336 115.03279114 30.54345322 115.03945923 30.54190636 115.04823303 30.54606247 115.05297089 30.55020142 115.0555954 30.56005478 115.05630493 30.56394386 115.05521393 30.58938408 115.05738831 30.59676743 115.06034088 30.60109329 115.06207275 30.60916138 115.06996918 30.61017609 115.07056427 30.61694145 115.0676651 30.61940575 115.06716156 30.62244415 115.06725311 30.62530136 115.06654358 30.62855148 115.06503296 30.63042641 115.0631485 30.63228989 115.06033325 30.63437271 115.05685425 30.63593864 115.05351257 30.63746262 115.05117035 30.63938713 115.04921722 30.64126968 115.04818726 30.64367104 115.04735565 30.64582253 115.04520416 30.6463089 115.04221344 30.64674187 115.0402832 30.64569092 115.03817749 30.64394188 115.03601074 30.6415081 115.03419495 30.63867569 115.03231812 30.63664818 115.03063202 30.63381577 115.02888489 30.63018417 115.02661896 30.62762833 115.0240097 30.62446976 115.01908875 30.62252998 115.01481628 30.62059975 115.01186371 30.61806679 115.01077271 30.61542892 115.01095581 30.61220741 115.01033783 30.60972786 115.00912476 30.60780144 115.00637054 30.60673141 115.00314331 30.60467339 114.99880219 30.60320282 114.99591064 30.60191345 114.99347687 30.6000061 114.99211884 30.59815407 114.99128723 30.59591484 114.99105835 30.59356308 114.9906311 30.59021378 114.98856354 30.58720207 114.98642731 30.58471489 114.98461151 30.58280754 114.98358917 30.58032036 114.98203278 30.57777596 114.98028564 30.5759201 114.97806549 30.57375526 114.97518921 30.57201576 114.97270203 30.57036781 114.96934509 30.56889153 114.96625519 30.56850052 114.96255493 30.5684166 114.9601059 30.56821251 114.95738983 30.56674767 114.95483398 30.56534195 114.9526062 30.56394768 114.95117188 30.56215858 114.95027161 30.56070709 114.94863892 30.56056213 114.94632721 30.56070328 114.94380188 30.5607872 114.94115448 30.56126022 114.93796539 30.56133461 114.93471527 30.56244469 114.93138885 30.56385231 114.9291153 30.56530762 114.92650604 30.56614113 114.92390442 30.56593323 114.92119598 30.56537628 114.91841888 30.56494904 114.91590881 30.56533241 114.9145813 30.5662384 114.91383362 30.56761551 114.91347504 30.5697937 114.91310883 30.5716877 114.91320801 30.57398605 114.91383362 30.5759449 114.91432953 30.57818985 114.91488647 30.58019829 114.91551971 30.58215714 114.91614532 30.58433723 114.91603851 30.58668327 114.91553497 30.59006882 114.91514587 30.59332657 114.9148941 30.59520912 114.91413116 30.59664345 114.91364288 30.59771729 114.91255951 30.59798241 114.9106369 30.59794617 114.9082489 30.59786606 114.90606689 30.59771156 114.90322113 30.59778023 114.89904022 30.59866714 114.89650726 30.60064507 114.89442444 30.60285568 114.89232635 30.60513115 114.89083099 30.6073513 114.88933563 30.60996628 114.88762665 30.61218071 114.88573456 30.6145668 114.88383484 30.61659431 114.88108826 30.6166153 114.87843323 30.61629486 114.87578583 30.61545372 114.87242126 30.61478424 114.86972046 30.61411095 114.86647797 30.61286354 114.86299133 30.61115265 114.85930634 30.60944748 114.85595703 30.60698891 114.85222626 30.60474968 114.84775543 30.60252953 114.84442139 30.59949684 114.84043121 30.59700012 114.83835602 30.5942421 114.83847046 30.59139061 114.83924866 30.58829117 114.83904266 30.58494759 114.83777618 30.58251762 114.83656311 30.58192062 114.8342514 30.58137512 114.83240509 30.58020401 114.83030701 30.5783329 114.82788849 30.57622337 114.82484436 30.57367134 114.82085419 30.59084511 114.81065369 30.61187172 114.78574371 30.61618042 114.77648163 30.6186409 114.77120209 30.62172508 114.77833557 30.62757301 114.79185486 30.62856293 114.80326843 30.62611008 114.81394196 30.63005066 114.8239212 30.63604546 114.83177185 30.64387512 114.83818054 30.65648079 114.83547974 30.65700722 114.83522034 30.6672039 114.83031464 30.66731453 114.82255554 30.66734886 114.82021332 30.66472054 114.80696106 30.67109299 114.80210114 30.67680359 114.80017853 30.68320084 114.80218506 30.68833542 114.79758453 30.69790649 114.79558563 30.69954872 114.7959137 30.70626259 114.79199982 30.71751785 114.80033112 30.72039223 114.80447388 30.72372437 114.80860138 30.7279911 114.81322479 30.73113441 114.81868744 30.73430061 114.82494354 30.73602104 114.82888794 30.7577343 114.8487854 30.76602936 114.85406494 30.78707314 114.86351013 30.78794289 114.86329651 30.79253387 114.86338806 30.79556465 114.86512756 30.79862785 114.86794281 30.80100441 114.87077332 30.80246353 114.8736496 30.80348778 114.87733459 30.8031311 114.8808136 30.79932976 114.88415527 30.79732132 114.88610077 30.79416275 114.88781738 30.79101563 114.89006805 30.78858185 114.89309692 30.7860775 114.89543152 30.78285027 114.90223694 30.79527283 114.91991425 30.79388237 114.92255402 30.79473305 114.92347717 30.79781151 114.92681885 30.79909325 114.93156433 30.79595566 114.93408203 30.79210663 114.93582916 30.78782272 114.93838501 30.7835083 114.93988037 30.78133392 114.94485474 30.78114128 114.94529724 30.78123856 114.94875336 30.78340149 114.95213318 30.78476143 114.95207977 30.78546333 114.95205688 30.78796005 114.95116425 30.79182434 114.94995117 30.79570389 114.94926453 30.79935837 114.94886017 30.80126762 114.95145416 30.80125237 114.952034 30.80375671 114.95275116 30.80717087 114.9629364 30.81906319 114.98040009 30.82794571 114.98408508 30.83781242 114.98287964 30.85696411 114.98634338 30.86056519 114.99578857 30.86041069 114.99619293 30.86196136 114.99736023 30.86367989 115.00128937 30.86308098 115.00450897 30.86089516 115.00832367 30.8591671 115.01211548 30.85653114 115.01621246 30.85345268 115.02085876 30.85296249 115.02140045 30.8529892 115.02616119 30.86195564 115.04252625 30.86208534 115.04264832 30.86491013 115.04520416 30.86753082 115.04884338 30.86852646 115.05097961 30.87015915 115.05286407 30.87719536 115.06043243 30.89391327 115.07062531 30.89690018 115.06768799 30.89700508 115.06758118 30.89823341 115.06448364 30.89929008 115.06124878 30.90127182 115.0582428 30.90326691 115.05577087 30.90663528 115.05324554 30.9090519 115.04942322 30.91102219 115.04615021 30.9120636 115.04238129 30.91336632 115.03966522 30.91394806 115.03591156 30.91455269 115.03295898 30.91536331 115.02919769 30.9175663 115.02591705 30.92093086 115.02311707 30.92181969 115.02223206 30.92450714 115.01271057 30.92999268 115.00527954 30.93830109 115.00005341 30.95608711 114.99281311 30.95682144 114.99207306 30.95693779 114.99082947 30.95939636 114.98860168 30.96033669 114.9885025 30.96353722 114.98525238 30.97158432 114.98394775 30.97164345 114.98387146 30.97408676 114.98110962 30.97653198 114.97834778 30.97949409 114.97770691 30.98179245 114.97788239 30.98342514 114.97888947 30.98601341 114.98119354 30.98608971 114.98159027 30.99247742 114.98055267 31.01956558 114.97079468 31.01920891 114.96609497 31.01658058 114.96748352 31.01361656 114.96813202 31.01115036 114.97009277 31.00774574 114.97129059 31.0040741 114.97116852 31.00085068 114.97075653 30.99855232 114.97057343 30.99669075 114.9695816 30.99479675 114.96751404 30.99263763 114.96413422 30.99000359 114.96022797 30.98895073 114.95546722 30.98978424 114.95249939 30.99131203 114.9497757 30.99329758 114.94702911 30.99611282 114.94477081 31.00264549 114.93260193 31.00034523 114.91832733 30.99864197 114.91747284 30.99565506 114.91732025 30.99305916 114.91475677 30.99389839 114.91205597 30.9956665 114.90985107 30.99793053 114.90869904 30.99830627 114.90827179 30.99557495 114.90039063 30.99472237 114.89040375 31.00022888 114.88117218 31.00231171 114.87412262 31.00240135 114.87303925 31.00225449 114.86806488 30.99908829 114.86062622 30.99212074 114.85277557 30.98832512 114.85354614 30.98653412 114.85578156 30.9845829 114.85959625 30.98420906 114.8625412 30.98340797 114.86657715 30.98168373 114.87037659 30.97993088 114.87311554 30.97675514 114.87430573 30.97400856 114.87441254 30.9696331 114.87378693 30.96411324 114.87319946 30.96130753 114.8714447 30.95663452 114.86842346 30.95217514 114.86486816 30.94833755 114.85914612 30.94890213 114.8548584 30.94931221 114.85172272 30.94707108 114.84728241 30.95165253 114.82900238 30.95082855 114.82678223 30.95025253 114.82279968 30.95103455 114.8182373 30.9527092 114.81283569 30.95602036 114.80843353 30.9563961 114.80796814 30.95757484 114.8049469 30.9596405 114.8038559 30.96131897 114.80155945 30.96423912 114.79957581 30.9681015 114.7983551 30.9726696 114.79763794 30.97657585 114.79801941 30.98073006 114.79891968 30.98419571 114.79985046 30.98786354 114.79969788 30.98939323 114.79941559 31.00333023 114.78469086 31.00369453 114.78352356 31.00292969 114.78202057 30.99944687 114.78056335 30.99621773 114.77989197 30.9918499 114.77953339 30.98586273 114.77870178 30.97870827 114.7771225 30.97194481 114.77339172 30.96845627 114.77166748 30.96661568 114.77146912 30.96427727 114.76996613 30.96276665 114.7654953 30.96338272 114.76306915 30.96493721 114.76140594 30.96767044 114.76075745 30.97042465 114.76091766 30.9729538 114.76107788 30.97614479 114.76042175 30.97934341 114.76002502 30.98320389 114.75880432 30.9866066 114.75759888 30.99043846 114.75531006 30.99072647 114.74969482 30.98938751 114.74334717 30.98929214 114.74014282 30.98873901 114.73696899 30.98776627 114.73513794 30.98609352 114.73280334 30.98484039 114.72938538 30.98311806 114.72545624 30.98163033 114.72177887 30.98152733 114.71831512 30.98118591 114.71598053 30.98094559 114.71434021 30.98059464 114.71035004 30.97974205 114.70809937 30.97909927 114.70641327 30.97804642 114.70191956 30.97452354 114.6991272 30.97194672 114.69736481 30.96870041 114.69616699 30.96615791 114.69546509 30.96293449 114.69506836 30.95903206 114.69496155 30.95674133 114.6950531 30.95313454 114.69706726 30.94996262 114.69826508 30.94682503 114.70079041 30.94389153 114.70224762 30.94284439 114.69802094 30.94345665 114.69559479 30.94454956 114.69368744 30.94523621 114.69268036 30.94512367 114.67021179 30.94557762 114.66819763 30.94512367 114.66752625 30.94311905 114.66201019 30.9418354 114.65752411 30.94031334 114.65278625 30.93924141 114.64776611 30.93838882 114.64247131 30.93761635 114.6363678 30.93416786 114.63034058 30.9306221 114.62020874 30.93173218 114.60909271 30.94575691 114.59012604 30.95459747 114.58635712 30.96483421 114.58634949 30.96940422 114.58403015 30.96958351 114.58355713 30.97082329 114.57923126 30.97256088 114.57622528 30.97473526 114.57239532 30.97622871 114.56887054 30.9786644 114.56609344 30.9801693 114.56394196 30.98098755 114.56172943 30.99032593 114.5424881 31.0147953 114.50666809 31.02158737 114.49855804 31.03015137 114.49401855 31.04962158 114.49652863 31.08299065 114.51545715 31.10105515 114.52197266 31.12078285 114.51976013 31.12900925 114.51432037 31.13559341 114.50557709 31.139328 114.49550629 31.15138626 114.47747803 31.15525055 114.46746063 31.16874313 114.4500351 31.1769352 114.44445038 31.19674492 114.44618225 31.2046814 114.43972015 31.22733498 114.40280914 31.23546219 114.3968277 31.2449398 114.39897156 31.24708176 114.40052032 31.24877167 114.4005661 31.25383568 114.40114594 31.25824738 114.4028244 31.26288605 114.40449524 31.26727867 114.40563965 31.27168465 114.40705109 31.27539825 114.40849304 31.27981949 114.41043854 31.28426361 114.41318512 31.28923035 114.41778564 31.29349709 114.42214966 31.29812241 114.42524719 31.29912376 114.42591858 31.3047142 114.42861938 31.30963326 114.43188477 31.31271553 114.43495941 31.31509018 114.43753052 31.31768608 114.43982697 31.32091713 114.44049072 31.32461548 114.44139862 31.32806778 114.44178772 31.33149529 114.4413681 31.33490181 114.44041443 31.33785248 114.43948364 31.34032631 114.43803406 31.34347343 114.43602753 31.34613419 114.43323517 31.34924507 114.43015289 31.35097313 114.42685699 31.35430336 114.42350006 31.35793495 114.42227173 31.36298752 114.42258453 31.36532021 114.4238205 31.36790657 114.42584991 31.37047958 114.42734528 31.37301445 114.42777252 31.37626266 114.42897034 31.37950325 114.42989349 31.38321686 114.43134308 31.38629913 114.43441772 31.38730621 114.43732452 31.3876152 114.43972015 31.38816833 114.44264221 31.38938141 114.44473267 31.39150238 114.44651794 31.39453125 114.44799042 31.3968544 114.44896698 31.39870262 114.44941711 31.40146637 114.44983673 31.40556908 114.44911957 31.40945625 114.44868469 31.41286278 114.44773102 31.41563606 114.44841003 31.41736031 114.4520874 31.4172287 114.45503998 31.41497993 114.45648193 31.4125309 114.4587326 31.41030121 114.46070099 31.40787506 114.46376038 31.40687561 114.46835327 31.40723419 114.4723587 31.40891266 114.47470093 31.41125488 114.47620392 31.41449356 114.4771347 31.41976166 114.47690582 31.42478943 114.47642517 31.42866135 114.47572327 31.43185997 114.47531128 31.43507576 114.47544098 31.43782234 114.47532654 31.44243622 114.47619629 31.44499779 114.47742462 31.44800758 114.47836304 31.45196533 114.48033905 31.45497704 114.4812851 31.45915031 114.48271179 31.46284866 114.48361969 31.46585083 114.48429871 31.46820641 114.48633575 31.46759987 114.48877716 31.46605682 114.49072266 31.46429825 114.49320984 31.46255302 114.49597168 31.46175575 114.49975586 31.46209526 114.50322723 31.46357727 114.5066452 31.46569443 114.50816345 31.46939659 114.50934601 31.47237396 114.50921631 31.47623825 114.50824738 31.48124313 114.50695801 31.48350716 114.50605774 31.48667908 114.50485229 31.48984909 114.50363922 31.49391174 114.50158691 31.49774361 114.49954224 31.50137329 114.4983139 31.50502777 114.49788666 31.5089283 114.49799347 31.5118885 114.49732208 31.51602554 114.49768066 31.51834488 114.4983902 31.52135849 114.49960327 31.52349663 114.50192261 31.52611542 114.50502777 31.52939796 114.50730133 31.53173828 114.50881195 31.5340786 114.51032257 31.53617668 114.51129913 31.53944016 114.51303864 31.54358482 114.51366425 31.54634857 114.51408386 31.55025864 114.51445007 31.55460739 114.51426697 31.55788994 114.51654053 31.55800819 114.52029419 31.55789757 114.52405548 31.5568943 114.52866364 31.55591011 114.53379822 31.55515671 114.5389328 31.55482674 114.54296875 31.55588913 114.54776001 31.5601387 114.55160522 31.55871391 114.55729675 31.5561924 114.56465149 31.55766678 114.56781006 31.55799675 114.5710144 31.56111336 114.57544708 31.5637722 114.57989502 31.56613922 114.58221436 31.56833076 114.58641052 31.57286453 114.59212494 31.57833862 114.59860229 31.5835495 114.60402679 31.58661842 114.60684967 31.58925056 114.61049652 31.59048843 114.61339569 31.59175491 114.61737061 31.59115982 114.62034607 31.59123421 114.62275696 31.58824348 114.62986755 31.58538246 114.63374329 31.5807476 114.63957214 31.57788467 114.64344788 31.57498932 114.64625549 31.57323265 114.64874268 31.56985855 114.65076447 31.5667038 114.65250397 31.56330872 114.6539917 31.56035423 114.65491486 31.55787086 114.65609741 31.55607986 114.65750885 31.55270195 114.65953064 31.54914665 114.66316223 31.54876137 114.66559601 31.54862976 114.66882324 31.55016136 114.67385864 31.55093575 114.67677307 31.55084419 114.68134308 31.54937935 114.68596649 31.5490036 114.68865967 31.54659843 114.69252014 31.54336929 114.69184875 31.53970528 114.69199371 31.53667831 114.69051361 31.53412819 114.68954468 31.53255844 114.69068146 31.53173447 114.69366455 31.53004074 114.69829559 31.52900124 114.701828 31.52844238 114.70614624 31.52634811 114.71266937 31.52438927 114.7162323 31.5230999 114.71897125 31.52298164 114.72273254 31.52428818 114.7280426 31.52520943 114.73578644 31.52675247 114.7413559 31.52776146 114.74453735 31.52852821 114.74718475 31.52863121 114.75067139 31.52717209 114.7555542 31.52658272 114.75879669 31.52470589 114.76504517 31.52434349 114.76828003 31.52233696 114.77024078 31.52034378 114.77246857 31.51719284 114.77446747 31.51304626 114.77383423 31.50660324 114.77301788 31.50318527 114.7736969 31.49914169 114.77653503 31.49572563 114.77721405 31.49275589 114.77760315 31.4900322 114.77851868 31.4877739 114.77967834 31.48555756 114.78218079 31.48310852 114.78469086 31.48161888 114.78850555 31.4801178 114.79205322 31.4792881 114.79503632 31.47915268 114.79825592 31.47909355 114.80389404 31.47813416 114.81036377 31.47661018 114.81311035 31.47397423 114.8169632 31.46976471 114.82196045 31.4661808 114.82478333 31.46442604 114.82753754 31.46220589 114.83003235 31.46227074 114.83217621 31.46167183 114.83515167 31.4624424 114.8380661 31.46438217 114.84174347 31.46716881 114.8429718 31.47063828 114.84391022 31.47387314 114.84485626 31.4773407 114.84578705 31.4792347 114.84786224 31.48095131 114.85181427 31.4820385 114.85767365 31.48129654 114.86360168 31.47820663 114.86774445 31.47468567 114.87270355 31.47341728 114.87651062 31.47356224 114.88159943 31.47533035 114.88716125 31.47712517 114.8937912 31.47964478 114.90174103 31.48049355 114.90733337 31.48151779 114.91104889 31.48137283 114.91400146 31.48082542 114.91885376 31.48049736 114.92342377 31.48112297 114.9292984 31.48223877 114.93622589 31.48534393 114.9406662 31.48773384 114.94406128 31.48967743 114.94800568 31.49449539 114.95613098 31.4975853 114.96003723 31.49929237 114.96372223 31.50009346 114.96772003 31.49996948 114.97147369 31.49887848 114.9733963 31.49684906 114.97454834 31.49504662 114.97568512 31.49207687 114.97606659 31.48829842 114.97827911 31.48482895 114.97949219 31.47868919 114.98234558 31.47596359 114.9846344 31.47373772 114.98764038 31.47191048 114.99559021 31.47236824 114.99990082 31.47499847 115.00185394 31.48084641 115.00222778 31.48681641 115.00131989 31.49222946 115.00033569 31.49696922 115.00057983 31.50124168 115.0003891 31.5082531 115.00521851 31.5133419 115.0069046 31.51661682 115.00919342 31.5214901 115.0114212 31.52451324 115.01291656 31.5269165 115.01685333 31.52518082 115.020401 31.5243454 115.02338409 31.5219841 115.02910614 31.51888275 115.03298187 31.51424599 115.0393219 31.51167488 115.04586029 31.51063538 115.0496521 31.50936317 115.05345154 31.50951958 115.05908203 31.50919342 115.06391907 31.50934029 115.0692749 31.50875664 115.07305908 31.51010704 115.080513 31.5137825 115.08922577 31.5166626 115.09394836 31.52024841 115.09944916 31.52308846 115.10256195 31.52589417 115.10460663 31.52818298 115.10452271 31.5307045 115.10443115 31.53483963 115.10481262 31.54098511 115.10324097 31.54551888 115.10146332 31.54938507 115.10025024 31.55256653 115.09932709 31.55533028 115.09976196 31.55858612 115.10151672 31.56183052 115.10273743 31.56533623 115.10529327 31.56837845 115.10759735 31.57097054 115.11018372 31.57590675 115.11456299 31.57740021 115.11907196 31.58111382 115.12081146 31.58681679 115.11979675 31.592062 115.1187973 31.59459686 115.11923981 31.59712219 115.11942291 31.59877586 115.12123871 31.60043526 115.12332153 31.60254288 115.12485504 31.60445213 115.12773895 31.60687828 115.13275146 31.60725212 115.1381073 31.60695457 115.14402008 31.60669708 115.15155029 31.60568619 115.15668488 31.6026268 115.16217041 31.60023117 115.16681671 31.59638596 115.1688385 31.59394073 115.17160797 31.58986092 115.17337036 31.58576775 115.17459106 31.58072472 115.17450714 31.57598114 115.17709351 31.57194138 115.18045807 31.56930351 115.18457794 31.56596947 115.1884613 31.56331825 115.19231415 31.56096458 115.19856262 31.55818558 115.20617676 31.55636978 115.21537018 31.55682755 115.22420502 31.55713844 115.22741699 31.55583191 115.22987366 31.5533123 115.22996521 31.5500412 115.22766876 31.54703712 115.22669983 31.54126358 115.22502899 31.53333664 115.21994781 31.52431488 115.21678162 31.51785469 115.2151413 31.51342392 115.21234894 31.50993729 115.21059418 31.50374413 115.21028137 31.49916458 115.21044922 31.49297905 115.21067047 31.48519516 115.21094513 31.47946167 115.21088409 31.47509003 115.2102356 31.46889305 115.20992279 31.46384048 115.20956421 31.4576149 115.20818329 31.45414352 115.20696259 31.45088768 115.20520782 31.44760323 115.20237732 31.44504929 115.2011261 31.44071388 115.20182037 31.43849754 115.20458221 31.43511772 115.20684814 31.4315052 115.2091217 31.42792892 115.21246338 31.42479324 115.21525574 31.42398453 115.21929932 31.42281532 115.22711182 31.42510223 115.23561096 31.42472649 115.2388382 31.42339516 115.24049377 31.42050362 115.24381256 31.41919708 115.24653625 31.41627693 115.2487793 31.41261292 115.24891663 31.40846443 115.24798584 31.40431213 115.24706268 31.40179253 115.24715424 31.39632225 115.24842072 31.39384842 115.25011444 31.39341927 115.26004028 31.3977375 115.26738739 31.40084839 115.27236938 31.40166664 115.27742767 31.40315247 115.28166199 31.40301323 115.28514862 31.40146446 115.28734589 31.39970016 115.29008484 31.39321136 115.29621124 31.38600731 115.30128479 31.38445854 115.30348206 31.38546371 115.30692291 31.38830948 115.31057739 31.3909111 115.31369781 31.39279938 115.31577301 31.39538765 115.318367 31.39705658 115.32098389 31.39807129 115.3246994 31.39908028 115.32841492 31.40177917 115.335289 31.40188217 115.33930206 31.40040016 115.34417725 31.39962006 115.3495636 31.40183258 115.3553772 31.40309715 115.3601532 31.40503883 115.36437225 31.40400314 115.36869812 31.40295029 115.3724823 31.40097618 115.3760376 31.39877892 115.3795929 31.39610672 115.38289642 31.3943119 115.38430023 31.39158249 115.38519287 31.38948631 115.38392639 31.38739204 115.38265991 31.38504982 115.38059235 31.38248253 115.37880707 31.38083076 115.37699127 31.37872314 115.37519073 31.37685013 115.37364197 31.37476158 115.37264252 31.37246513 115.37245178 31.37062645 115.37225342 31.36833572 115.37232971 31.36536598 115.37269592 31.36174202 115.3744278 31.35310555 115.37739563 31.3474884 115.38187408 31.3457489 115.38568115 31.34493446 115.38972473 31.34456444 115.39321899 31.3439579 115.39645386 31.34333801 115.39914703 31.34317398 115.40183258 31.34535027 115.40631104 31.34729576 115.41079712 31.34947014 115.41527557 31.35112762 115.4173584 31.35302734 115.41997528 31.35399437 115.42208099 31.35336876 115.42451477 31.35210037 115.42884064 31.35008621 115.43078613 31.34763145 115.43354034 31.34538269 115.43522644 31.34243011 115.43639374 31.33970642 115.43755341 31.33628845 115.43820953 31.33285904 115.438591 31.32691002 115.4390564 31.32303047 115.43972015 31.31869888 115.4406662 31.31599426 115.44263458 31.31445122 115.44509125 31.31542778 115.44747162 31.3168602 115.4498291 31.31783676 115.45220947 31.31792259 115.45568085 31.31521416 115.4573822 31.31292343 115.4574585 31.30489922 115.4574585 31.2973156 115.45663452 31.29247475 115.45545959 31.28853416 115.45372009 31.28600121 115.45326996 31.28212166 115.45393372 31.27554512 115.45682526 31.27284813 115.45905304 31.27063751 115.46234131 31.26911926 115.46586609 31.26671982 115.47076416 31.26782417 115.47848511 31.26951218 115.48190308 31.27075768 115.48587799 31.27150917 115.48852539 31.27205086 115.49198914 31.27169037 115.49600983 31.27108383 115.49924469 31.27000809 115.50222015 31.26848984 115.50575256 31.26694489 115.50820923 31.26562881 115.51065826 31.26295853 115.51395416 31.2598114 115.51673126 31.2555809 115.52168274 31.25152779 115.52475739 31.24722862 115.52703857 31.24360085 115.52876282 31.23886681 115.53212738 31.23637581 115.53327179 31.23411179 115.5344162 31.2313652 115.53477478 31.22814751 115.53434753 31.22585106 115.53414917 31.22101784 115.53324127 31.21736908 115.5341568 31.21210861 115.5345993 31.20866585 115.53443909 31.20590401 115.53399658 31.20271873 115.53490448 31.19698906 115.53508759 31.19355965 115.53546906 31.18924713 115.53720856 31.18383408 115.54086304 31.17932129 115.54394531 31.17616081 115.54592133 31.17212296 115.5495224 31.16782951 115.55207062 31.16487503 115.55323029 31.1626091 115.55437469 31.15970039 115.55741119 31.15793228 115.56013489 31.15527344 115.56396484 31.1528492 115.5680542 31.14931297 115.57350922 31.14755058 115.57649994 31.14650154 115.58054352 31.14654732 115.58267975 31.14731407 115.58586121 31.14945221 115.58899689 31.15249062 115.59157562 31.15527725 115.59308624 31.1580658 115.59460449 31.1606102 115.59558868 31.16568947 115.59703064 31.16958046 115.59690857 31.17327118 115.59786224 31.17604065 115.59857178 31.17722893 115.60041046 31.17825127 115.60491943 31.17949104 115.60888672 31.18027306 115.61286926 31.18196487 115.61656189 31.18340683 115.61945343 31.18694878 115.62388611 31.19137001 115.6266861 31.19390869 115.62741089 31.19853973 115.62940216 31.20224762 115.63115692 31.2050457 115.63320923 31.20855141 115.63603973 31.21043968 115.63838196 31.21186829 115.64074707 31.21266174 115.64526367 31.21323013 115.65006256 31.21287346 115.65435028 31.2124958 115.65783691 31.21187592 115.66079712 31.21086884 115.6667099 31.20986366 115.67288971 31.20755386 115.68205261 31.20628166 115.68663025 31.20478821 115.69149017 31.20327759 115.69554901 31.20080566 115.69776154 31.19631767 115.70191193 31.19294357 115.70468903 31.18802071 115.70991516 31.1830883 115.7148819 31.18151855 115.71652985 31.17996407 115.71871948 31.17839622 115.72036743 31.17684937 115.72281647 31.1736908 115.72505188 31.16868973 115.72681427 31.16505432 115.72825623 31.16075325 115.73078918 31.15827751 115.73274231 31.15512466 115.73523712 31.1531353 115.7385025 31.15181541 115.74095154 31.15027237 115.7436676 31.14894295 115.74558258 31.1462326 115.74753571 31.14469528 115.7505188 31.13764763 115.75313568 31.13083458 115.75601196 31.12628937 115.75775146 31.1235466 115.75810242 31.1203537 115.75873566 31.11743164 115.76148987 31.11521339 115.76476288 31.11419487 115.770401 31.11449051 115.77333069 31.11569977 115.77622986 31.11828041 115.77882385 31.1204071 115.78170013 31.1218338 115.78406525 31.12484169 115.78530884 31.12671852 115.78712463 31.12836456 115.78920746 31.13004684 115.79263306 31.13061333 115.79742432 31.13137627 115.8008728 31.13236809 115.80431366 31.13313866 115.80802917 31.13230324 115.8117981 31.13145065 115.8147583 31.12970924 115.81881714 31.1293087 115.82150269 31.12867546 115.8239212 31.12850761 115.82686615 31.12857246 115.82980347 31.12932014 115.83245087 31.13123512 115.83613586 31.13382339 115.83926392 31.13849258 115.84313202 31.14271927 115.84781647 31.14555931 115.85201263 31.14820862 115.85781097 31.14967537 115.86204529 31.14994812 115.86417389 31.14889717 115.86847687 31.14667511 115.87174988 31.14422417 115.87502289 31.13877869 115.87758636 31.13514137 115.87902832 31.12969017 115.88132477 31.12419128 115.88148499 31.1200695 115.88159943 31.11572266 115.88199615 31.11160278 115.88237762 31.10776711 115.88516235 31.10438156 115.88766479 31.10124016 115.89096069 31.09749794 115.89801025 31.09305573 115.90454102 31.08924294 115.90866089 31.08475685 115.91332245 31.07918358 115.92069244 31.07744789 115.92527771 31.07502937 115.93015289 31.07418633 115.93364716 31.07147598 115.93559265 31.06783485 115.93676758 31.06302643 115.93717194 31.05957031 115.936203 31.05520439 115.93579102 31.05220604 115.93480682 31.04965591 115.93354034 31.04626083 115.93550873 31.04538345 115.93740082 31.04477692 115.94115448 31.04772949 115.95094299 31.0492115 115.95597839 31.04861832 115.96053314 31.04781342 115.96588898 31.04604912 115.9691391 31.04611588 115.97234344 31.04548836 115.97529602 31.04418182 115.97853851 31.04037857 115.98317719 31.03682899 115.98888397 31.03670883 115.99395752 31.03794479 115.99845886 31.03685951 116.00141907 31.03230476 116.00288391 31.02819252 116.00353241 31.02316284 116.0042038 31.01950836 116.00483704 31.01678085 116.00598145 31.01521873 116.00788879 31.01410866 116.00978851 31.0137043 116.01246643 31.01377106 116.01566315 31.01504135 116.02176666 31.01766777 116.02676392 31.01845169 116.03154755 31.01901245 116.03659821 31.01725006 116.04011536 31.01390076 116.04447937 31.01005363 116.04698181 31.00688171 116.04866791 31.00301743 116.05037689 30.99803162 116.05317688 30.99029732 116.05605316 30.98438072 116.05834961 30.97984314 116.06060791 30.97553635 116.06311798 30.972826 116.06506348 30.97012138 116.06726837 30.9664917 116.06922913 30.96191025 116.06935883 30.95867538 116.0681076 30.95498276 116.06687927 30.95516777 116.06473541 30.95650482 116.06283569 30.95804596 116.0595932 30.95882034 116.05264282 30.95875168 116.04917908 30.95890045 116.04517365 30.95858383 116.04091644 30.95804214 116.03692627 30.95706177 116.03376007 30.95559883 116.02926636 30.95436859 116.02529907 30.95337677 116.02159119 30.95236588 116.01708984 30.95158768 116.01258087 30.95106697 116.00965881 30.95029831 116.0056839 30.9495163 116.0011673 30.94851112 115.99693298 30.94706726 115.99350739 30.94447517 115.9901123 30.94205856 115.98404694 30.93475151 115.97438812 30.93159866 115.96620941 30.92757034 115.95993042 30.92291069 115.95632935 30.91804123 115.95379639 30.91411972 115.95257568 30.91059494 115.94841003 30.90888405 115.94339752 30.90741158 115.93890381 30.90574837 115.9360199 30.90104294 115.93029022 30.89752007 115.9263916 30.89470482 115.92327881 30.89167023 115.92070007 30.88933372 115.91863251 30.88734245 115.91123199 30.88537216 115.90489197 30.88288689 115.89590454 30.88178444 115.887146 30.87862778 115.87897491 30.8757267 115.87213135 30.87311554 115.86794281 30.86841202 115.86248779 30.86256027 115.85706329 30.85881805 115.85370636 30.85461617 115.85009766 30.85040474 115.84622955 30.84620285 115.84262085 30.84270096 115.83979797 30.839674 115.8377533 30.83667946 115.83704376 30.83235931 115.83876801 30.82829666 115.8415451 30.82489395 115.84324646 30.82173157 115.84546661 30.81882477 115.84874725 30.81705475 115.85173035 30.81413269 115.85447693 30.81118965 115.8561554 30.80842972 115.85570526 30.80474091 115.85475159 30.80174255 115.85403442 30.79759789 115.85309601 30.7925396 115.85243988 30.78889084 115.85334778 30.78618622 115.85555267 30.78466415 115.85932159 30.78311348 115.861763 30.78108788 115.86341858 30.77738571 115.86193085 30.77527618 115.85986328 30.77315712 115.85726166 30.77148247 115.85411835 30.76911736 115.8507309 30.76396179 115.84555817 30.76032257 115.83634949 30.75831985 115.82868958 30.75589943 115.82290649 30.75417137 115.81736755 30.75404358 115.81151581 30.75441933 115.8077774 30.75660896 115.80319214 30.75927162 115.79912567 30.76079178 115.79534912 30.76164246 115.79239655 30.76198959 115.78733063 30.76235199 115.7830658 30.75997734 115.77941132 30.75713921 115.77550507 30.75318527 115.77295685 30.74604225 115.7713089 30.73980713 115.76937103 30.73423767 115.76634216 30.72496986 115.76210022 30.71757889 115.75965881 30.71203041 115.75769806 30.7060585 115.75708008 30.69709778 115.75628662 30.69156837 115.75511932 30.68675041 115.75499725 30.68127632 115.75622559 30.67651939 115.75876617 30.67427635 115.76095581 30.67192459 115.76847076 30.66674423 115.77261353 30.66476059 115.77613068 30.66326141 115.78096008 30.66176414 115.78578949 30.659338 115.79011536 30.65552711 115.79395294 30.65147972 115.79753113 30.64764977 115.80056763 30.64152145 115.80340576 30.63604736 115.80462646 30.62940025 115.80482483 30.6259346 115.8035965 30.62107086 115.80135345 30.61577606 115.80044556 30.61279869 115.80053711 30.60755348 115.80175018 30.6027813 115.80375671 30.59803391 115.8068161 30.59672165 115.80950928 30.59655952 115.81270599 30.59891129 115.81529236 30.60103607 115.81815338 30.60287285 115.81809998 30.6047039 115.81804657 30.60726547 115.81983185 30.61004257 115.82107544 30.61013794 115.82532501 30.60863113 115.82988739 30.6073513 115.83417511 30.60559845 115.83794403 30.60227966 115.84335327 30.60004616 115.84607697 30.59828949 115.84958649 30.59652519 115.85282135 30.59478378 115.85712433 30.59237862 115.86250305 30.59107208 115.86573029 30.58883858 115.86845398 30.58658218 115.87010956 30.58135986 115.87239075 30.57679939 115.87358093 30.57130814 115.87400818 30.5664959 115.87414551 30.56282806 115.87425232 30.55714035 115.87627411 30.55312157 115.88117218 30.55064011 115.88310242 30.54841042 115.88608551 30.53985214 115.89323425 30.53465652 115.89683533 30.52989578 115.89936066 30.52673912 115.90184021 30.52475739 115.90560913 30.52342033 115.90750885 30.52046585 115.90865326 30.51794624 115.90872955 30.51540184 115.90773773 30.51194191 115.90677643 30.50777245 115.9047699 30.50263214 115.90040588 30.49818993 115.89628601 30.49399567 115.89321899 30.49051666 115.8914566 30.48635674 115.88972473 30.48130608 115.88960266 30.4783802 115.89207458 30.47566986 115.89400482 30.47114563 115.89678955 30.4683857 115.89633942 30.46421432 115.89433289 30.45818138 115.89105988 30.45540237 115.88980865 30.4524765 115.89228058 30.45004082 115.89633179 30.44759941 115.90011597 30.44607162 115.90361023 30.44405365 115.90578461 30.44203758 115.90796661 30.43751526 115.91101074 30.43479538 115.91241455 30.43281174 115.91618347 30.43291855 115.92121887 30.43323326 115.92519379 30.43309593 115.92943573 30.43271255 115.93289948 30.43141937 115.93691254 30.42939186 115.93856049 30.42733955 115.93914795 30.42406464 115.93605804 30.42003441 115.92980957 30.41713524 115.92299652 30.41568947 115.91958618 30.4137001 115.91248322 30.41132355 115.90857697 30.40755081 115.90364838 30.4046917 115.89868927 30.40119362 115.89587402 30.39908028 115.89354706 30.39509964 115.88967896 30.39273834 115.88656616 30.39013672 115.88292694 30.38755989 115.88035583 30.38500977 115.87910461 30.37997437 115.87950897 30.37225151 115.88291168 30.36613464 115.88626862 30.35936928 115.89150238 30.35396385 115.89589691 30.34972763 115.90158081 30.34659576 115.90511322 30.34344673 115.9081192 30.34073639 115.91004944 30.33778572 115.91146088 30.33389854 115.91183472 30.33067894 115.91139984 30.32696342 115.90937805 30.3248291 115.90599823 30.32130241 115.9018631 30.31848335 115.89875793 30.31639862 115.89775848 30.31276321 115.89945221 30.31080437 115.90428162 30.30883408 115.90856934 30.30686951 115.91313171 30.30396843 115.91692352 30.30589485 115.92110443 30.30762672 115.92714691 30.30960274 115.93371582 30.30924416 115.93849182 30.30934334 115.94326019 30.30900574 115.94882965 30.30795288 115.95336151 30.30642319 115.95684814 30.3042202 115.96115112 30.30268478 115.96437073 30.30119133 115.9697113 30.29964828 115.97267151 30.29834175 115.97588348 30.29586792 115.97833252 30.29361343 115.9802475 30.29087639 115.98085785 30.28766251 115.98068237 30.28263855 115.98161316 30.27692604 115.98256683 30.27419853 115.98370361 30.26961136 115.98382568 30.26596642 115.98472595 30.26255417 115.98613739 30.25758553 115.98972321 30.25511932 115.99243927 30.2531395 115.99645996 30.25253487 116.00045013 30.25260162 116.00362396 30.25198364 116.00708008 30.25043869 116.00977325 30.24644279 116.01623535 30.24421692 116.01947021 30.24219322 116.02137756 30.23649597 116.02312469 30.23376465 116.02399445 30.23126411 116.0251236 30.22945786 116.02648926 30.22905922 116.02941895 30.22798729 116.03314972 30.22691345 116.03662109 30.22631264 116.04087067 30.22499084 116.04355621 30.22231102 116.04706573 30.21893883 116.05033112 30.2178421 116.052742 30.21445465 116.05522156 30.21196747 116.05713654 30.20925522 116.05905914 30.20698738 116.06018066 30.20401001 116.06026459 30.19595146 116.05862427 30.19176674 116.05582428 30.18711853 116.05278015 30.18340683 116.05075836 30.17997169 116.05085754 30.17378807 116.05128479 30.16832542 116.05328369 30.16149521 116.05558014 30.15807724 116.05673218 30.15397263 116.05789948 30.14648819 116.06180573 30.14355278 116.06399536 30.14105797 116.06539154 30.1390419 116.06755829 30.13587379 116.06975555 30.13365746 116.07351685 30.13209724 116.07594299 30.12850952 116.07974243 30.12280464 116.0812149 30.11801529 116.08239746 30.11252594 116.08306885 30.10953522 116.08262634 30.10563469 116.0824585 30.10285759 116.0812149 30.10053825 116.07995605 30.09798622 116.07843781 30.09545326 116.07797241 30.09223557 116.07752991 30.08879852 116.07762146 30.08469772 116.07905579 30.08219337 116.07991028 30.07828712 116.07949066 30.07294273 116.07592773 30.0685463 116.07393646 30.06440926 116.07351685 30.05961609 116.0746994 30.05690575 116.07662201 30.05305672 116.07910156 30.04786682 116.08320618 30.04309845 116.08544159 30.03853035 116.08635712 30.03438759 116.0856781 30.03208542 116.08520508 30.0293045 116.08369446 30.02765656 116.08162689 30.02508736 116.07932281 30.020895 116.0759964 30.01649475 116.0737381 30.01257706 116.07305145 30.00937653 116.0734024 30.0061779 116.07401276 30.00161743 116.07518768 29.99382591 116.07540131 29.98948669 116.0763092 29.98650742 116.0763855 29.98397446 116.0759201 29.97957993 116.07392883 29.97724152 116.07187653 29.97514343 116.07009125 29.97236061 116.06858063 29.96937752 116.06838989 29.96571541 116.0687561 29.96231079 116.07042694 29.95845795 116.07264709 29.9578228 116.07530212 29.9548912 116.07849884 29.95311165 116.08044434 29.94814491 116.08426666 29.94115639 116.09026337 29.93483162 116.09490967 29.92917442 116.09875488 29.92264175 116.1044693 29.91676712 116.10884857 29.90865898 116.11618805 29.90369987 116.1205368 29.90004158 116.12245178 29.89893341 116.12303162 29.89621735 116.12468719 29.89122009 116.12718964 29.88756752 116.12781525 29.88504791 116.12814331 29.88231277 116.12874603 29.8798008 116.1293335 29.87726784 116.12887573 29.87380791 116.1279068 29.87058067 116.12693787 29.86757469 116.12569427 29.86480713 116.12497711 29.86228943 116.12504578 29.8588562 116.12539673 29.85427666 116.1257782 29.84671974 116.12624359 29.84078026 116.12745667 29.8339119 116.12789154 29.82485008 116.12962341 29.82421875 116.12970734 29.82066536 116.12059784 29.81477737 116.11170959 29.79938507 116.0978241 29.76622963 116.05888367 29.76525879 116.05774689 29.75039101 116.04251099 29.745924 116.03296661 29.74394798 116.02223206 29.73869133 116.00779724 29.74310493 116.00341797 29.73211479 115.95598602 29.73175049 115.95488739 29.7285881 115.94628906 29.72634506 115.93791962 29.72527695 115.93083954 29.7247448 115.92301178 29.72516441 115.91889954 29.72561264 115.914505 29.7277298 115.90628052 29.72938538 115.89807129 29.73038864 115.89469147 29.73151016 115.89091492 29.73320961 115.88400269 29.73513222 115.87762451 29.73709679 115.87309265 29.73905754 115.86829376 29.74145126 115.86243439 29.74337387 115.85605621 29.74557495 115.85177612 29.74840736 115.84510803 29.75036621 115.84030914 29.75235176 115.83520508 29.75279427 115.8340683 29.75448036 115.82939148 29.75777817 115.82297516 29.76020813 115.81894684 29.7628994 115.81438446 29.76563263 115.80986023 29.76821518 115.8068161 29.76990891 115.80290985 29.77264023 115.79838562 29.77537346 115.79386139 29.77900124 115.78683472 29.78302383 115.77909851 29.78862762 115.76856995 29.79297447 115.76087952 29.79703522 115.75276947 29.80242157 115.74446106 29.81014061 115.73499298 29.81506157 115.72956848<span class="hljs-tag">&lt;/<span class="hljs-name">gml:posList</span>&gt;</span><br>                                <span class="hljs-tag">&lt;/<span class="hljs-name">gml:LinearRing</span>&gt;</span><br>                            <span class="hljs-tag">&lt;/<span class="hljs-name">gml:exterior</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">gml:Polygon</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">gml:surfaceMember</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">gml:MultiSurface</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">cesium:the_geom</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:GID_0</span>&gt;</span>CHN<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:GID_0</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:NAME_0</span>&gt;</span>China<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:NAME_0</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:GID_1</span>&gt;</span>CHN.13_1<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:GID_1</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:NAME_1</span>&gt;</span>Hubei<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:NAME_1</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:NL_NAME_1</span>&gt;</span>湖北<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:NL_NAME_1</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:GID_2</span>&gt;</span>CHN.13.3_1<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:GID_2</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:NAME_2</span>&gt;</span>Huanggang<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:NAME_2</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:VARNAME_2</span>&gt;</span>Huánggāng<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:VARNAME_2</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:NL_NAME_2</span>&gt;</span>黄冈市<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:NL_NAME_2</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:TYPE_2</span>&gt;</span>Dìjíshì<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:TYPE_2</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:ENGTYPE_2</span>&gt;</span>Prefecture City<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:ENGTYPE_2</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:CC_2</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:HASC_2</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">cesium:0</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">wfs:member</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">wfs:FeatureCollection</span>&gt;</span><br></code></pre></td></tr></table></figure><p>发送下面xml文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; ?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">wfs:Transaction</span></span><br><span class="hljs-tag">   <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;2.0.2&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">service</span>=<span class="hljs-string">&quot;WFS&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.someserver.example.com/myns&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">xmlns:fes</span>=<span class="hljs-string">&quot;http://www.opengis.net/fes/2.0&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">xmlns:wfs</span>=<span class="hljs-string">&quot;http://www.opengis.net/wfs/2.0&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://schemas.opengis.net/wfs/2.0.02.0/wfs.xsd&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">wfs:Delete</span> <span class="hljs-attr">typeName</span>=<span class="hljs-string">&quot;cesium:0&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">fes:Filter</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">fes:ResourceId</span> <span class="hljs-attr">rid</span>=<span class="hljs-string">&quot;0.134&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">fes:Filter</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">wfs:Delete</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">wfs:Transaction</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/9KpQKt.png" alt="9KpQKt"></p><p>我们再去查询一下featureid=0.134的feature</p><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/w0RSZX.png" alt="w0RSZX"></p><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/skTU6D.png" alt="skTU6D"></p><h3 id="插入feature"><a href="#插入feature" class="headerlink" title="插入feature"></a>插入feature</h3><p>我们把刚刚删除的feature再添加进去。</p><p>官方示例</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">wfs:Transaction</span></span><br><span class="hljs-tag">   <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;2.0.2&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">service</span>=<span class="hljs-string">&quot;WFS&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.someserver.example.com/myns&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">xmlns:gml</span>=<span class="hljs-string">&quot;http://www.opengis.net/gml/3.2&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">xmlns:wfs</span>=<span class="hljs-string">&quot;http://www.opengis.net/wfs/2.0&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.someserver.example.com/myns ./SampleSchema.xsd</span></span><br><span class="hljs-tag"><span class="hljs-string">                       http://www.opengis.net/wfs/2.0</span></span><br><span class="hljs-tag"><span class="hljs-string">                       http://schemas.opengis.net/wfs/2.0/wfs.xsd</span></span><br><span class="hljs-tag"><span class="hljs-string">                       http://www.opengis.net/gml/3.2</span></span><br><span class="hljs-tag"><span class="hljs-string">                       http://schemas.opengis.net/gml/3.2.1/gml.xsd&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">wfs:Insert</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">InWaterA_1M</span> <span class="hljs-attr">gml:id</span>=<span class="hljs-string">&quot;F1&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">wkbGeom</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">gml:Polygon</span> <span class="hljs-attr">srsName</span>=<span class="hljs-string">&quot;urn:ogc:def:crs:EPSG::4326&quot;</span> <span class="hljs-attr">gml:id</span>=<span class="hljs-string">&quot;P1&quot;</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">gml:exterior</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">gml:LinearRing</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">gml:posList</span>&gt;</span>-30.93597221374512 117.6290588378906 -30.94830513000489 117.6447219848633 -30.95219421386719 117.6465530395508 -30.95219421386719 117.6431121826172 -30.94802856445312 117.6386108398438 -30.94799995422363 117.6314163208008 -30.946138381958 117.62850189209 -30.94430541992188 117.6295852661133 -30.93280601501464 117.6240539550781 -30.92869377136231 117.624641418457 -30.92386054992676 117.6201400756836 -30.92111206054688 117.6206970214844 -30.92458343505859 117.6275863647461 -30.93597221374512 117.6290588378906<span class="hljs-tag">&lt;/<span class="hljs-name">gml:posList</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">gml:LinearRing</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">gml:exterior</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">gml:Polygon</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">wkbGeom</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>28022<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">fCode</span>&gt;</span>BH000<span class="hljs-tag">&lt;/<span class="hljs-name">fCode</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">hyc</span>&gt;</span>6<span class="hljs-tag">&lt;/<span class="hljs-name">hyc</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">tileId</span>&gt;</span>177<span class="hljs-tag">&lt;/<span class="hljs-name">tileId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">facId</span>&gt;</span>132<span class="hljs-tag">&lt;/<span class="hljs-name">facId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">InWaterA_1M</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">InWaterA_1M</span> <span class="hljs-attr">gml:id</span>=<span class="hljs-string">&quot;F2&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">wkbGeom</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">gml:Polygon</span> <span class="hljs-attr">srsName</span>=<span class="hljs-string">&quot;urn:ogc:def:crs:EPSG::4326&quot;</span> <span class="hljs-attr">gml:id</span>=<span class="hljs-string">&quot;P2&quot;</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">gml:exterior</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">gml:LinearRing</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">gml:posList</span>&gt;</span>-30.92013931274414 117.6552810668945 -30.92383384704589 117.661361694336 -30.93005561828613 117.6666412353516 -30.93280601501464 117.6663589477539 -30.93186187744141 117.6594467163086 -30.93780517578125 117.6541137695312 -30.94397163391114 117.6519470214844 -30.94255638122559 117.6455535888672 -30.93402862548828 117.6336364746094 -30.92874908447266 117.6355285644531 -30.92138862609864 117.6326370239258 -30.92236137390137 117.6395568847656 -30.91708374023438 117.6433029174805 -30.91711044311523 117.6454467773437 -30.92061042785645 117.6484985351563 -30.92061042785645 117.6504135131836 -30.91638946533203 117.6504440307617 -30.92013931274414 117.6552810668945 <span class="hljs-tag">&lt;/<span class="hljs-name">gml:posList</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">gml:LinearRing</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">gml:exterior</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">gml:Polygon</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">wkbGeom</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>28021<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">fCode</span>&gt;</span>BH000<span class="hljs-tag">&lt;/<span class="hljs-name">fCode</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">hyc</span>&gt;</span>6<span class="hljs-tag">&lt;/<span class="hljs-name">hyc</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">tileId</span>&gt;</span>177<span class="hljs-tag">&lt;/<span class="hljs-name">tileId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">facId</span>&gt;</span>131<span class="hljs-tag">&lt;/<span class="hljs-name">facId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">InWaterA_1M</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">wfs:Insert</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">wfs:Transaction</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们发送下面xml文件。</p><blockquote><p>⚠️ 注意这里需要指定<code>cesium</code>的命名空间，即添加<code>xmlns:cesium=&quot;http://geoserver.org/cesium&quot;</code>到首部</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">wfs:Transaction</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;2.0.2&quot;</span> <span class="hljs-attr">service</span>=<span class="hljs-string">&quot;WFS&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:cesium</span>=<span class="hljs-string">&quot;http://geoserver.org/cesium&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://localhost:8080/geoserver/cesium&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:gml</span>=<span class="hljs-string">&quot;http://www.opengis.net/gml/3.2&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:wfs</span>=<span class="hljs-string">&quot;http://www.opengis.net/wfs/2.0&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>  <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;</span></span><br><span class="hljs-tag"><span class="hljs-string">    http://www.opengis.net/wfs/2.0</span></span><br><span class="hljs-tag"><span class="hljs-string">    http://localhost:8080/geoserver/schemas/wfs/2.0/wfs.xsd</span></span><br><span class="hljs-tag"><span class="hljs-string">    http://geoserver.org/cesium http://localhost:8080/geoserver/cesium/wfs?service=WFS<span class="hljs-symbol">&amp;amp;</span>version=2.0.0<span class="hljs-symbol">&amp;amp;</span>request=DescribeFeatureType<span class="hljs-symbol">&amp;amp;</span>typeName=cesium%3A0</span></span><br><span class="hljs-tag"><span class="hljs-string">    http://www.opengis.net/gml/3.2 http://localhost:8080/geoserver/schemas/gml/3.2.1/gml.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">wfs:Insert</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">cesium:0</span> <span class="hljs-attr">gml:id</span>=<span class="hljs-string">&quot;0.133&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:the_geom</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">gml:MultiSurface</span> <span class="hljs-attr">srsName</span>=<span class="hljs-string">&quot;urn:ogc:def:crs:EPSG::4326&quot;</span> <span class="hljs-attr">srsDimension</span>=<span class="hljs-string">&quot;2&quot;</span> <span class="hljs-attr">gml:id</span>=<span class="hljs-string">&quot;0.133.the_geom&quot;</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">gml:surfaceMember</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">gml:Polygon</span> <span class="hljs-attr">gml:id</span>=<span class="hljs-string">&quot;0.133.the_geom.1&quot;</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">gml:exterior</span>&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">gml:LinearRing</span>&gt;</span><br>                                    <span class="hljs-tag">&lt;<span class="hljs-name">gml:posList</span>&gt;</span>30.25465775 115.07079315 30.25456238 115.06994629 30.2590847 115.0690918 30.26287651 115.05915833 30.26636124 115.0373764 30.26559639 115.02616882 30.26219177 115.01602173 30.24378777 115.01037598 30.23891258 115.00079346 30.2325573 114.99259949 30.22265625 114.99238586 30.21601677 114.98714447 30.21361542 114.97647095 30.21756935 114.95479584 30.21509171 114.94419098 30.21652412 114.9338913 30.22030449 114.92395782 30.22470665 114.90261841 30.23828316 114.8738327 30.237463 114.86690521 30.24502373 114.85974121 30.26275063 114.85244751 30.27095985 114.84703064 30.27897072 114.84107971 30.28544044 114.83226776 30.31149673 114.81967163 30.31545067 114.80973816 30.31489944 114.79901123 30.30734825 114.75548553 30.30898285 114.74446869 30.31279564 114.73446655 30.32083511 114.728508 30.3254776 114.71905518 30.32468033 114.70842743 30.31648254 114.70349121 30.30724144 114.70632935 30.29900169 114.71166992 30.29092407 114.71338654 30.2834053 114.70578766 30.27821732 114.69649506 30.26984024 114.66522217 30.26228333 114.65762329 30.25385284 114.65278625 30.24425125 114.65103912 30.22662354 114.65866089 30.21840668 114.66404724 30.21080589 114.67111969 30.1901722 114.69676971 30.18137741 114.70079803 30.17220116 114.69802856 30.16435051 114.69155121 30.15465546 114.69039154 30.14727783 114.69818115 30.14146996 114.70727539 30.13384056 114.71439362 30.1242466 114.71257019 30.11707115 114.72077942 30.10812569 114.72307587 30.09960556 114.71850586 30.07957649 114.71770477 30.07112122 114.72245026 30.06212807 114.72244263 30.04593849 114.69551849 30.04584122 114.68448639 30.04269409 114.67558289 30.03408623 114.67113495 30.02782249 114.65065765 30.02654648 114.64027405 30.02986717 114.63014984 30.03682518 114.62254333 30.04561043 114.61869812 30.0521698 114.61106873 30.05439758 114.60043335 30.05428886 114.58940887 30.04920769 114.56819916 30.05509186 114.5532608 30.06316757 114.54646301 30.06556892 114.53590393 30.08077812 114.52945709 30.09724998 114.51882172 30.11962128 114.4966507 30.12949181 114.49556732 30.16864777 114.49947357 30.18676567 114.50556946 30.20768929 114.52744293 30.22538757 114.53474426 30.24469757 114.53747559 30.25306511 114.54249573 30.25988579 114.55049896 30.27596855 114.56256104 30.29089546 114.57728577 30.30810165 114.58521271 30.33786583 114.58705902 30.40586662 114.57727051 30.41341209 114.58026123 30.42062187 114.57582092 30.44076347 114.57483673 30.45099258 114.57481384 30.47934532 114.58094788 30.48887062 114.57894897 30.49550056 114.57282257 30.49972153 114.56293488 30.50855637 114.56085205 30.53451347 114.57071686 30.54680061 114.59066772 30.56194687 114.60480499 30.55775261 114.62402344 30.5594101 114.63503265 30.57954979 114.67248535 30.59669876 114.71140289 30.60749054 114.74160767 30.61718369 114.76052856 30.6186409 114.77120209 30.61618042 114.77648163 30.61187172 114.78574371 30.59084511 114.81065369 30.57367134 114.82085419 30.57622337 114.82484436 30.5783329 114.82788849 30.58020401 114.83030701 30.58137512 114.83240509 30.58192062 114.8342514 30.58251762 114.83656311 30.58494759 114.83777618 30.58829117 114.83904266 30.59139061 114.83924866 30.5942421 114.83847046 30.59700012 114.83835602 30.59949684 114.84043121 30.60252953 114.84442139 30.60474968 114.84775543 30.60698891 114.85222626 30.60944748 114.85595703 30.61115265 114.85930634 30.61286354 114.86299133 30.61411095 114.86647797 30.61478424 114.86972046 30.61545372 114.87242126 30.61629486 114.87578583 30.6166153 114.87843323 30.61659431 114.88108826 30.6145668 114.88383484 30.61218071 114.88573456 30.60996628 114.88762665 30.6073513 114.88933563 30.60513115 114.89083099 30.60285568 114.89232635 30.60064507 114.89442444 30.59866714 114.89650726 30.59778023 114.89904022 30.59771156 114.90322113 30.59786606 114.90606689 30.59794617 114.9082489 30.59798241 114.9106369 30.59771729 114.91255951 30.59664345 114.91364288 30.59520912 114.91413116 30.59332657 114.9148941 30.59006882 114.91514587 30.58668327 114.91553497 30.58433723 114.91603851 30.58215714 114.91614532 30.58019829 114.91551971 30.57818985 114.91488647 30.5759449 114.91432953 30.57398605 114.91383362 30.5716877 114.91320801 30.5697937 114.91310883 30.56761551 114.91347504 30.5662384 114.91383362 30.56533241 114.9145813 30.56494904 114.91590881 30.56537628 114.91841888 30.56593323 114.92119598 30.56614113 114.92390442 30.56530762 114.92650604 30.56385231 114.9291153 30.56244469 114.93138885 30.56133461 114.93471527 30.56126022 114.93796539 30.5607872 114.94115448 30.56070328 114.94380188 30.56056213 114.94632721 30.56070709 114.94863892 30.56215858 114.95027161 30.56394768 114.95117188 30.56534195 114.9526062 30.56674767 114.95483398 30.56821251 114.95738983 30.5684166 114.9601059 30.56850052 114.96255493 30.56889153 114.96625519 30.57036781 114.96934509 30.57201576 114.97270203 30.57375526 114.97518921 30.5759201 114.97806549 30.57777596 114.98028564 30.58032036 114.98203278 30.58280754 114.98358917 30.58471489 114.98461151 30.58720207 114.98642731 30.59021378 114.98856354 30.59356308 114.9906311 30.59591484 114.99105835 30.59815407 114.99128723 30.6000061 114.99211884 30.60191345 114.99347687 30.60320282 114.99591064 30.60467339 114.99880219 30.60673141 115.00314331 30.60780144 115.00637054 30.60972786 115.00912476 30.61220741 115.01033783 30.61542892 115.01095581 30.61806679 115.01077271 30.62059975 115.01186371 30.62252998 115.01481628 30.62446976 115.01908875 30.62762833 115.0240097 30.63018417 115.02661896 30.63381577 115.02888489 30.63664818 115.03063202 30.63867569 115.03231812 30.6415081 115.03419495 30.64394188 115.03601074 30.64569092 115.03817749 30.64674187 115.0402832 30.6463089 115.04221344 30.64582253 115.04520416 30.64367104 115.04735565 30.64126968 115.04818726 30.63938713 115.04921722 30.63746262 115.05117035 30.63593864 115.05351257 30.63437271 115.05685425 30.63228989 115.06033325 30.63042641 115.0631485 30.62855148 115.06503296 30.62530136 115.06654358 30.62244415 115.06725311 30.61940575 115.06716156 30.61694145 115.0676651 30.61017609 115.07056427 30.60916138 115.06996918 30.60109329 115.06207275 30.59676743 115.06034088 30.58938408 115.05738831 30.56394386 115.05521393 30.56005478 115.05630493 30.55020142 115.0555954 30.54606247 115.05297089 30.54190636 115.04823303 30.54345322 115.03945923 30.54707336 115.03279114 30.54818916 115.02826691 30.54654884 115.02244568 30.54283905 115.01610565 30.53433609 115.0121994 30.52701187 115.01279449 30.52150536 115.01151276 30.50706863 115.010849 30.49467087 115.00617981 30.48962593 115.00335693 30.4792614 114.99756622 30.46479607 114.99318695 30.46328545 114.9932251 30.4604969 114.99330139 30.44945145 114.99359131 30.4366684 114.99980164 30.43590927 115.00042725 30.4305191 115.00489044 30.4314537 115.00779724 30.43627548 115.00934601 30.44041443 115.01196289 30.43951225 115.01356506 30.43195534 115.01416016 30.42029572 115.0174408 30.41604424 115.01882172 30.4114933 115.01499176 30.40950584 115.01331329 30.40788078 115.02080536 30.40662766 115.02509308 30.40555573 115.02778625 30.40491867 115.02967834 30.40428543 115.03154755 30.40122986 115.03618622 30.39901924 115.03996277 30.39387131 115.04644012 30.39106178 115.05059814 30.38635254 115.05448914 30.38142204 115.05864716 30.37454796 115.0623703 30.36911201 115.06557465 30.36444664 115.06738281 30.35965157 115.06918335 30.35485649 115.07098389 30.35124588 115.07247162 30.34636307 115.07381439 30.34120369 115.07541656 30.3367691 115.07607269 30.33215523 115.0772934 30.32249641 115.07880402 30.3150444 115.08013153 30.30809975 115.08152008 30.3024826 115.08247375 30.2984314 115.08317566 30.29518127 115.0830307 30.29125786 115.08210754 30.28686714 115.08094788 30.28105927 115.07752228 30.27635765 115.0754776 30.27189636 115.0736084 30.269207 115.07273102 30.26827049 115.07242584 30.26795387 115.07238007 30.26357841 115.07171631 30.2598877 115.0712738 30.25707436 115.07108307 30.25465775 115.07079315<span class="hljs-tag">&lt;/<span class="hljs-name">gml:posList</span>&gt;</span><br>                                <span class="hljs-tag">&lt;/<span class="hljs-name">gml:LinearRing</span>&gt;</span><br>                            <span class="hljs-tag">&lt;/<span class="hljs-name">gml:exterior</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">gml:Polygon</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">gml:surfaceMember</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">gml:MultiSurface</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">cesium:the_geom</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:GID_0</span>&gt;</span>CHN<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:GID_0</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:NAME_0</span>&gt;</span>China<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:NAME_0</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:GID_1</span>&gt;</span>CHN.13_1<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:GID_1</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:NAME_1</span>&gt;</span>Hubei<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:NAME_1</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:NL_NAME_1</span>&gt;</span>湖北<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:NL_NAME_1</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:GID_2</span>&gt;</span>CHN.13.2_1<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:GID_2</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:NAME_2</span>&gt;</span>Ezhou by emhui<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:NAME_2</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:VARNAME_2</span>&gt;</span>Èzhōu<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:VARNAME_2</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:NL_NAME_2</span>&gt;</span>鄂州市<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:NL_NAME_2</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:TYPE_2</span>&gt;</span>Dìjíshì<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:TYPE_2</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:ENGTYPE_2</span>&gt;</span>Prefecture City<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:ENGTYPE_2</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:CC_2</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:HASC_2</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">cesium:0</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">wfs:Insert</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">wfs:Transaction</span>&gt;</span><br></code></pre></td></tr></table></figure><p>插入结果如图所示，插入成功，但是feaureid好像是系统自动分配的</p><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/Drk4uR.png" alt="Drk4uR"></p><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/nzIcHX.png" alt="nzIcHX"></p><p>其他</p><blockquote><p> 查询需要添加一句话到xml中</p></blockquote><blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">xmlns:cesium=&quot;http://geoserver.org/cesium&quot;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p><code>xmlns:cesium</code>是一个命名空间，如果不添加这句话，那么下面的<code>&lt;cesium:xxx&gt;&lt;/cesium:xxx&gt;</code>都无法解析</p></blockquote><blockquote><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/ZVwnjv.png" alt="ZVwnjv"></p></blockquote><p>测试</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">wfs:Transaction</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;2.0.2&quot;</span> <span class="hljs-attr">service</span>=<span class="hljs-string">&quot;WFS&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:cesium</span>=<span class="hljs-string">&quot;http://geoserver.org/cesium&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://localhost:8080/geoserver/cesium&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:gml</span>=<span class="hljs-string">&quot;http://www.opengis.net/gml/3.2&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:wfs</span>=<span class="hljs-string">&quot;http://www.opengis.net/wfs/2.0&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>  <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;</span></span><br><span class="hljs-tag"><span class="hljs-string">    http://www.opengis.net/wfs/2.0</span></span><br><span class="hljs-tag"><span class="hljs-string">    http://localhost:8080/geoserver/schemas/wfs/2.0/wfs.xsd</span></span><br><span class="hljs-tag"><span class="hljs-string">    http://geoserver.org/cesium http://localhost:8080/geoserver/cesium/wfs?service=WFS<span class="hljs-symbol">&amp;amp;</span>version=2.0.0<span class="hljs-symbol">&amp;amp;</span>request=DescribeFeatureType<span class="hljs-symbol">&amp;amp;</span>typeName=cesium%3A0</span></span><br><span class="hljs-tag"><span class="hljs-string">    http://www.opengis.net/gml/3.2 http://localhost:8080/geoserver/schemas/gml/3.2.1/gml.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">wfs:Insert</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">cesium:0</span> <span class="hljs-attr">gml:id</span>=<span class="hljs-string">&quot;1.123&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:the_geom</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">gml:MultiSurface</span> <span class="hljs-attr">srsName</span>=<span class="hljs-string">&quot;urn:ogc:def:crs:EPSG::4326&quot;</span> <span class="hljs-attr">srsDimension</span>=<span class="hljs-string">&quot;2&quot;</span> <span class="hljs-attr">gml:id</span>=<span class="hljs-string">&quot;1.123.the_geom&quot;</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">gml:surfaceMember</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">gml:Polygon</span> <span class="hljs-attr">gml:id</span>=<span class="hljs-string">&quot;0.133.the_geom.1&quot;</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">gml:exterior</span>&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">gml:LinearRing</span>&gt;</span><br>                                    <span class="hljs-tag">&lt;<span class="hljs-name">gml:posList</span>&gt;</span><br>                                        50.75596883266384 103.3116295189964<br>                                    <span class="hljs-tag">&lt;/<span class="hljs-name">gml:posList</span>&gt;</span><br>                                <span class="hljs-tag">&lt;/<span class="hljs-name">gml:LinearRing</span>&gt;</span><br>                            <span class="hljs-tag">&lt;/<span class="hljs-name">gml:exterior</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">gml:Polygon</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">gml:surfaceMember</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">gml:MultiSurface</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">cesium:the_geom</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:GID_0</span>&gt;</span>CHN<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:GID_0</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:NAME_0</span>&gt;</span>China<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:NAME_0</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:GID_1</span>&gt;</span>CHN.13_1<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:GID_1</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:NAME_1</span>&gt;</span>CUG<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:NAME_1</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:NL_NAME_1</span>&gt;</span>中国地质大学<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:NL_NAME_1</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:GID_2</span>&gt;</span>CHN.13.2_1<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:GID_2</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:NAME_2</span>&gt;</span>Ezhou by emhui<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:NAME_2</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:VARNAME_2</span>&gt;</span>Geo<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:VARNAME_2</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:NL_NAME_2</span>&gt;</span>中国地质大学市<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:NL_NAME_2</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:TYPE_2</span>&gt;</span>Da<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:TYPE_2</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:ENGTYPE_2</span>&gt;</span>Prefecture City<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:ENGTYPE_2</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:CC_2</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:HASC_2</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">cesium:0</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">wfs:Insert</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">wfs:Transaction</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><p>先保留id为<code>0.102</code>的元素数据，等会再插入进去</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">wfs:FeatureCollection</span> <span class="hljs-attr">xmlns:xs</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span> <span class="hljs-attr">xmlns:cesium</span>=<span class="hljs-string">&quot;http://geoserver.org/cesium&quot;</span> <span class="hljs-attr">xmlns:wfs</span>=<span class="hljs-string">&quot;http://www.opengis.net/wfs/2.0&quot;</span> <span class="hljs-attr">xmlns:gml</span>=<span class="hljs-string">&quot;http://www.opengis.net/gml/3.2&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="hljs-attr">numberMatched</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">numberReturned</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">timeStamp</span>=<span class="hljs-string">&quot;2020-10-21T05:46:20.854Z&quot;</span> <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.opengis.net/wfs/2.0 http://localhost:8080/geoserver/schemas/wfs/2.0/wfs.xsd http://geoserver.org/cesium http://localhost:8080/geoserver/cesium/wfs?service=WFS<span class="hljs-symbol">&amp;amp;</span>version=2.0.0<span class="hljs-symbol">&amp;amp;</span>request=DescribeFeatureType<span class="hljs-symbol">&amp;amp;</span>typeName=cesium%3A0 http://www.opengis.net/gml/3.2 http://localhost:8080/geoserver/schemas/gml/3.2.1/gml.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">wfs:member</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">cesium:0</span> <span class="hljs-attr">gml:id</span>=<span class="hljs-string">&quot;0.102&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:the_geom</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">gml:MultiSurface</span> <span class="hljs-attr">srsName</span>=<span class="hljs-string">&quot;urn:ogc:def:crs:EPSG::4326&quot;</span> <span class="hljs-attr">srsDimension</span>=<span class="hljs-string">&quot;2&quot;</span> <span class="hljs-attr">gml:id</span>=<span class="hljs-string">&quot;0.102.the_geom&quot;</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">gml:surfaceMember</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">gml:Polygon</span> <span class="hljs-attr">gml:id</span>=<span class="hljs-string">&quot;0.102.the_geom.1&quot;</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">gml:exterior</span>&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">gml:LinearRing</span>&gt;</span><br>                                    <span class="hljs-tag">&lt;<span class="hljs-name">gml:posList</span>&gt;</span>52.87590027 125.72106171 52.87631226 125.72225189 52.88783264 125.75554657 52.89224243 125.764328 52.89488983 125.7745285 52.89529037 125.78442383 52.896492 125.81410217 52.89524078 125.83249664 52.89196014 125.83946228 52.88703156 125.84554291 52.87664032 125.84452057 52.87240982 125.84525299 52.86016083 125.84910583 52.8502121 125.85823822 52.84778976 125.86045837 52.83636093 125.87821198 52.83235931 125.88729095 52.82593918 125.8939209 52.80849075 125.91542816 52.79116058 125.92941284 52.7725296 125.95012665 52.76522446 125.96109772 52.76082993 125.96769714 52.76063919 125.98059082 52.76224136 125.98866272 52.76686096 126.0015564 52.77236938 126.00979614 52.77455902 126.01432037 52.77589035 126.01785278 52.78863144 126.03088379 52.79095078 126.03325653 52.79547882 126.04283142 52.79640961 126.04923248 52.79468918 126.05885315 52.78869629 126.0717392 52.78517151 126.07932281 52.77574539 126.09641266 52.7726593 126.10201263 52.76383972 126.11279297 52.75654221 126.10933685 52.74768066 126.09442139 52.74520111 126.08686066 52.74556351 126.07211304 52.74491119 126.06838226 52.74302673 126.05756378 52.74243927 126.04737854 52.73875046 126.04234314 52.73246002 126.04145813 52.71908569 126.04541779 52.71452332 126.04907227 52.70608139 126.05583954 52.69290924 126.06349182 52.69031906 126.06529999 52.67987823 126.0612793 52.67793274 126.06053162 52.67624664 126.05988312 52.67142868 126.05570984 52.67074966 126.05439758 52.66882324 126.0506897 52.66833878 126.04975891 52.66824341 126.0484848 52.66770172 126.04132843 52.66749191 126.03855896 52.6676178 126.03557587 52.66808319 126.0245285 52.67086411 126.00449371 52.66779327 125.99062347 52.66372681 125.97955322 52.65679169 125.97042847 52.647789 125.96539307 52.63829041 125.96382904 52.6240654 125.96531677 52.62253952 125.96547699 52.60788345 125.97412872 52.59682465 125.98561096 52.58967209 125.99310303 52.585289 125.99677277 52.58097076 126.00572205 52.58272171 126.0329361 52.58744049 126.04354095 52.59114838 126.04823303 52.59743881 126.05819702 52.59880066 126.06402588 52.60015869 126.06984711 52.59307861 126.08294678 52.58863068 126.08965302 52.58499146 126.10262299 52.56912994 126.13548279 52.5561409 126.15809631 52.55437469 126.16126251 52.54172516 126.18392944 52.53516006 126.19391632 52.52664948 126.20195007 52.52629089 126.20210266 52.51834869 126.20542145 52.5013504 126.19664764 52.49483871 126.19084167 52.48332977 126.18566132 52.48165894 126.18490601 52.47868347 126.18482971 52.47293091 126.18467712 52.46583176 126.1891098 52.46239853 126.20199585 52.46405411 126.2103653 52.4681015 126.2308197 52.46928406 126.24416351 52.46891403 126.25847626 52.45798874 126.27282715 52.43928146 126.29168701 52.42892075 126.30406189 52.42092514 126.31637573 52.41634369 126.32343292 52.41387939 126.32723236 52.39595032 126.34368134 52.38718033 126.34778595 52.37871933 126.35177612 52.36703873 126.35231781 52.36366653 126.35355377 52.34489059 126.34986877 52.33483124 126.35057068 52.32474899 126.34641266 52.31212997 126.33402252 52.30638123 126.32837677 52.29935074 126.33920288 52.29716873 126.35408783 52.29674911 126.36348724 52.29473877 126.3731308 52.29474258 126.38474274 52.29456711 126.39484406 52.29444122 126.40196228 52.2919693 126.42025757 52.29092026 126.4230957 52.28876114 126.42894745 52.28483963 126.43284607 52.284729 126.43959808 52.27436447 126.4257431 52.27056122 126.41020966 52.26525879 126.38932037 52.25489044 126.34854889 52.25144958 126.34008026 52.24515915 126.32977295 52.23178864 126.31151581 52.2234993 126.30290222 52.22328186 126.30267334 52.21572876 126.29889679 52.21130753 126.29862213 52.20675659 126.29833221 52.20487213 126.30098724 52.19971848 126.3082962 52.19490433 126.31886292 52.18843842 126.33305359 52.1817894 126.36309052 52.18046951 126.38202667 52.17932129 126.39849091 52.17782974 126.40426636 52.17742157 126.40585327 52.17720795 126.40973663 52.17578125 126.43553925 52.17034149 126.45848083 52.16846085 126.46639252 52.15779495 126.49472046 52.15632629 126.49604034 52.15385056 126.4982605 52.1477356 126.51048279 52.14263916 126.52066803 52.13064957 126.54882813 52.13016891 126.54995728 52.12087631 126.55645752 52.10924149 126.55768585 52.10704041 126.55502319 52.10092163 126.54767609 52.09401703 126.54486084 52.07162094 126.53572083 52.06470871 126.53472137 52.05416107 126.52191925 52.04748917 126.51729584 52.03342056 126.51571655 52.02902985 126.50630188 52.028862 126.49443054 52.03126144 126.48229218 52.03084946 126.47454834 52.03079224 126.46118164 52.02825928 126.45262909 52.02186966 126.44481659 52.01605606 126.44325256 52.0060997 126.44558716 52.00541687 126.44574738 51.99919891 126.44716644 51.98892975 126.45504761 51.97336197 126.46427155 51.95381927 126.45921326 51.94272232 126.46186829 51.93531036 126.46920776 51.93198013 126.4756012 51.92747879 126.48677063 51.92549133 126.49170685 51.91908646 126.49756622 51.909729 126.5061264 51.89935684 126.51386261 51.8944397 126.52307129 51.89051056 126.53042603 51.88995743 126.53146362 51.88882828 126.53260803 51.87733078 126.54429626 51.86809921 126.55161285 51.85640335 126.56086731 51.83979034 126.56851959 51.83467102 126.57087708 51.82268143 126.5739975 51.80533981 126.59337616 51.79030991 126.59984589 51.7828598 126.60661316 51.78023148 126.6089859 51.77146149 126.62124634 51.76145935 126.64070892 51.75664139 126.65392303 51.74295044 126.65982056 51.73701859 126.65789795 51.73140335 126.65572357 51.72661209 126.65691376 51.72369003 126.66078949 51.72128677 126.66825104 51.72270966 126.6786499 51.72069168 126.71335602 51.71342087 126.72354889 51.70373535 126.72705078 51.69779968 126.72602844 51.69771957 126.72601318 51.6920929 126.72171021 51.69031906 126.72035217 51.67741394 126.71911621 51.66592789 126.72322083 51.65882111 126.72749329 51.65858078 126.72766876 51.6475296 126.73561096 51.63954926 126.73667145 51.63279724 126.73461914 51.63142776 126.73253632 51.62857056 126.72817993 51.61809921 126.7118988 51.61271667 126.7052536 51.60774994 126.6889801 51.60272598 126.68045044 51.59516144 126.67594147 51.58526993 126.6798172 51.57971954 126.68792725 51.57567978 126.69399261 51.57139969 126.70449066 51.57077026 126.70820618 51.56853104 126.71530914 51.56731796 126.71925354 51.56486893 126.72484589 51.55844116 126.74260712 51.55466843 126.75936127 51.55263901 126.76837158 51.54499054 126.79840851 51.53752899 126.8184967 51.53118134 126.82923889 51.52653885 126.83277893 51.5180397 126.83242035 51.50726318 126.82794189 51.48564529 126.80396271 51.48271179 126.80278778 51.47718048 126.80059052 51.4642334 126.7954483 51.46060181 126.79400635 51.45281219 126.78954315 51.44799042 126.78502655 51.44036484 126.78382111 51.42922592 126.78879547 51.42758179 126.78952789 51.41687012 126.80448914 51.41358948 126.81664276 51.40718079 126.8533783 51.40335846 126.88684082 51.39736176 126.90445709 51.38801193 126.91363525 51.38576889 126.91583252 51.3727951 126.92144775 51.3678093 126.92360687 51.35659409 126.9239502 51.34836578 126.91988373 51.34331131 126.91503143 51.33750916 126.90442657 51.33502197 126.89597321 51.33753967 126.84552002 51.33433914 126.83204651 51.32218933 126.81861877 51.30900192 126.81630707 51.29687119 126.81678772 51.28210068 126.81942749 51.27231979 126.82544708 51.26358414 126.83396912 51.25592041 126.84143829 51.24687958 126.85756683 51.24261856 126.86871338 51.24144745 126.8772583 51.24150848 126.88308716 51.24364853 126.90289307 51.24961853 126.9107666 51.25273132 126.91487885 51.26441956 126.91485596 51.26712418 126.91279602 51.27480698 126.9069519 51.29574966 126.87650299 51.30630112 126.87185669 51.31003952 126.87320709 51.31946945 126.89211273 51.32014465 126.89595032 51.32331085 126.9139328 51.32506943 126.92175293 51.32585144 126.9373703 51.32633209 126.95632935 51.32514954 126.96488953 51.31987762 126.97432709 51.30776978 126.97986603 51.29138947 126.97318268 51.29086685 126.9728241 51.26647949 126.95622253 51.25538254 126.94384766 51.25119019 126.93917084 51.24597931 126.93225098 51.23915863 126.92317963 51.23791504 126.92227936 51.23273087 126.91851807 51.22598267 126.91645813 51.2025032 126.90084839 51.18836594 126.89791107 51.18774033 126.89804077 51.15409088 126.9048233 51.12990952 126.91191101 51.12837982 126.91205597 51.11531067 126.91339874 51.10058975 126.91707611 51.07971954 126.91718292 51.06199265 126.92015839 51.05799866 126.92285156 51.05142975 126.93348694 51.0464592 126.94429779 51.03083801 126.96961212 51.02141953 126.98487091 51.0120697 126.99511719 51.00599289 127.00061798 51.00318146 127.0031662 51.00043869 127.00565338 50.9928894 127.01058197 50.98195648 127.02148438 50.97803497 127.02539825 50.97168732 127.03173065 50.96573257 127.04118347 50.95992279 127.05800629 50.95709991 127.06617737 50.93721008 127.10488892 50.93387222 127.11181641 50.92562866 127.121521 50.90480042 127.14109039 50.89715958 127.14679718 50.82955933 127.19722748 50.81772995 127.20249176 50.8290062 127.1934433 50.84143066 127.18460846 50.8509903 127.17686462 50.86335754 127.16628265 50.87846756 127.1550293 50.89469147 127.14411926 50.90481186 127.1367569 50.91569901 127.12320709 50.92816925 127.10733795 50.9373436 127.09216309 50.94043732 127.08535004 50.94525909 127.07228088 50.95055771 127.05697632 50.95501328 127.04130554 50.95893097 127.0344162 50.96425247 127.02828979 50.97383881 127.01743317 50.97483063 127.01677704 50.9727478 127.01443481 50.96881104 127.0100174 50.96577835 127.00613403 50.96249771 127.00196075 50.96134567 127.00049591 50.95464325 126.99638367 50.95064545 126.99305725 50.94421387 126.98770142 50.93795776 126.98285675 50.93370056 126.97395325 50.92806625 126.96474457 50.92312241 126.95587158 50.91993713 126.94258881 50.92022324 126.93171692 50.91953278 126.91725922 50.91687012 126.89382172 50.91635895 126.87646484 50.91648102 126.86994171 50.91445541 126.84431458 50.91308975 126.83097839 50.91116714 126.81185913 50.91139221 126.7980957 50.91049576 126.78582001 50.90964508 126.76304626 50.91085052 126.75322723 50.91019821 126.72899628 50.91067505 126.71703339 50.91034317 126.68554688 50.90908813 126.66677856 50.90808105 126.64907837 50.90955734 126.62982941 50.90919876 126.61029816 50.90846252 126.5954895 50.90641022 126.58363342 50.90483856 126.57320404 50.90386581 126.55804443 50.90472031 126.5428009 50.90435791 126.53593445 50.90330505 126.51679993 50.90257645 126.50271606 50.90236664 126.49222565 50.9033699 126.48493958 50.90555191 126.47940826 50.90907288 126.47236633 50.91281509 126.46459198 50.91748047 126.45748901 50.92059326 126.4529953 50.92720413 126.44001007 50.93205261 126.4307251 50.93820572 126.41811371 50.9431572 126.40229797 50.94868469 126.39297485 50.95284653 126.38371277 50.95550156 126.37923431 50.95859528 126.3736496 50.96419144 126.36756897 50.96996689 126.35895538 50.97477722 126.34819794 50.97891235 126.33784485 50.97994995 126.3356781 50.97982788 126.33287048 50.98060989 126.32783508 50.98106003 126.32662201 50.98625565 126.31998444 50.99028778 126.31083679 50.99201202 126.29992676 50.99075699 126.28835297 50.98873901 126.26882172 50.99270248 126.25314331 50.99448013 126.24766541 50.99892807 126.2355957 51.00014496 126.22033691 50.99439621 126.21720886 50.9814682 126.20519257 50.97307587 126.18981171 50.96608353 126.1772995 50.9648819 126.1678772 50.96528625 126.16680908 50.96580505 126.15122223 50.96826553 126.14544678 50.96892929 126.14389038 50.96986771 126.1253891 50.96960831 126.12360382 50.95794678 126.12140656 50.95501709 126.12338257 50.95301819 126.12469482 50.95140839 126.12574768 50.94734573 126.12850952 50.94320297 126.12728119 50.93739319 126.12361145 50.93211746 126.11302948 50.9274292 126.09842682 50.92007828 126.08724213 50.91493988 126.07303619 50.91330338 126.0615387 50.91288757 126.05358887 50.91337204 126.0448761 50.91464233 126.0306778 50.91737366 126.01282501 50.92559052 126.01356506 50.92775345 126.01615906 50.93208694 126.02135468 50.93081284 126.02971649 50.92565536 126.0354538 50.92313766 126.03825378 50.92521667 126.03946686 50.92728424 126.0406723 50.93482971 126.04046631 50.94166183 126.03810883 50.94568634 126.04560089 50.94914246 126.05202484 50.95256805 126.05157471 50.95941162 126.0503006 50.9619751 126.05421448 50.95911407 126.06407166 50.95949173 126.0669632 50.95986938 126.06985474 50.96079254 126.07091522 50.96197128 126.07378387 50.96657181 126.07619476 50.96672821 126.0745163 50.96718216 126.06965637 50.96733475 126.06312561 50.97328186 126.06296539 50.97466278 126.06105042 50.97620392 126.05889893 50.97563171 126.04876709 50.97806168 126.04145813 50.9809494 126.04037476 50.98329926 126.03949738 50.9884758 126.04147339 50.98950195 126.04186249 50.99836349 126.03726959 51.00282669 126.02771759 51.00533295 126.02692413 51.00854492 126.02792358 51.01338959 126.03141785 51.01610184 126.02880096 51.02079773 126.03156281 51.02140045 126.03192139 51.02312469 126.04239655 51.02641296 126.03842163 51.02650833 126.03830719 51.03010178 126.03276825 51.0349617 126.0377121 51.03113937 126.04486847 51.0284729 126.04986572 51.03128433 126.0555954 51.03695679 126.05281067 51.03833008 126.05213928 51.04117584 126.04153442 51.04175949 126.03244781 51.04172134 126.02916718 51.04167175 126.02519226 51.04389572 126.01968384 51.04613876 126.02201843 51.04898834 126.02498627 51.05376434 126.02304077 51.05222321 126.00856018 51.05679321 126.0044632 51.06391525 126.01113892 51.06535721 126.00455475 51.06472778 126.00376129 51.0617485 126 51.07627106 125.98672485 51.08142853 125.97301483 51.08511353 125.97464752 51.08472443 125.98296356 51.08680344 125.98679352 51.08995819 125.98358154 51.09184647 125.97545624 51.09569931 125.973526 51.10979843 125.98777008 51.11581421 125.99384308 51.12041473 125.99200439 51.11642838 125.98077393 51.12343979 125.97563934 51.12371826 125.96970367 51.10895157 125.9469986 51.10687256 125.94380188 51.10811615 125.93320465 51.11288071 125.92779541 51.11592865 125.92696381 51.12005234 125.91909027 51.12304688 125.91944122 51.12399292 125.93149567 51.12687302 125.93422699 51.12848282 125.93202972 51.139534 125.90465546 51.13484573 125.89215851 51.13511658 125.88621521 51.13973618 125.87678528 51.14009857 125.87604523 51.13984299 125.86525726 51.14316177 125.85847473 51.14839935 125.85909271 51.1529274 125.87516022 51.15999222 125.86881256 51.16757965 125.86730957 51.17341995 125.85484314 51.18464661 125.8561554 51.20015335 125.8460083 51.20912933 125.84705353 51.21651459 125.83355713 51.22052765 125.82803345 51.22411728 125.81528473 51.22247314 125.78517151 51.22388077 125.76933289 51.2255249 125.75080872 51.22953415 125.7452774 51.24406815 125.75653076 51.25844955 125.75458527 51.2642746 125.74208069 51.27442932 125.73365784 51.27939606 125.72344208 51.28538132 125.72412872 51.29863739 125.71365356 51.30295944 125.70095825 51.31038666 125.70300293 51.33047867 125.69090271 51.33454132 125.68416595 51.33488464 125.68043518 51.33597183 125.66873169 51.34622192 125.65789032 51.34878159 125.65097809 51.3569603 125.65310669 51.3590889 125.6389389 51.37233353 125.6284256 51.38204193 125.61270905 51.38704681 125.61151123 51.38888168 125.61107635 51.39070892 125.61181641 51.39700699 125.61438751 51.39728165 125.61236572 51.39923096 125.59781647 51.41701126 125.58659363 51.42192459 125.57776642 51.43087387 125.56169128 51.43910217 125.56260681 51.44398117 125.57157135 51.45022964 125.56625366 51.45133591 125.55796051 51.45992661 125.55049896 51.46128845 125.53620911 51.48515701 125.52321625 51.49158478 125.5128479 51.49664688 125.50467682 51.51098633 125.48152161 51.51797485 125.47626495 51.53258896 125.45489502 51.54430008 125.4377594 51.55322266 125.42469788 51.55554581 125.42249298 51.56575012 125.41279602 51.57954407 125.38657379 51.58615112 125.37400818 51.59233856 125.37206268 51.59757614 125.37041473 51.60856247 125.36265564 51.61027145 125.3614502 51.61604309 125.35317993 51.62217712 125.34353638 51.61994553 125.33113861 51.61970139 125.33011627 51.6163826 125.31748962 51.61348343 125.31406403 51.6115799 125.31181335 51.60829163 125.30813599 51.61278152 125.29942322 51.63233566 125.28128052 51.63581848 125.2746582 51.6350975 125.26425934 51.63000107 125.26003265 51.62871933 125.25215912 51.6360054 125.23300171 51.6371994 125.2298584 51.63894272 125.22083282 51.63664246 125.21543121 51.62950134 125.21060944 51.62907791 125.2101059 51.62643814 125.20697021 51.63657379 125.1717453 51.63764954 125.1680069 51.63730621 125.15950012 51.63521576 125.15448761 51.63389969 125.14646149 51.63282013 125.13986969 51.63241196 125.12730408 51.6372261 125.12154388 51.64611435 125.12284088 51.65122223 125.12117004 51.65721893 125.12032318 51.65872955 125.11434174 51.65912247 125.11277771 51.65959167 125.10103607 51.65655899 125.09076691 51.64537811 125.08370972 51.63869095 125.07896423 51.63430023 125.07408905 51.63167572 125.07086945 51.62865448 125.06613922 51.62277603 125.0640564 51.61386108 125.06349945 51.60992432 125.05867767 51.60387421 125.05510712 51.59869385 125.05272675 51.59505844 125.05198669 51.57658768 125.06111908 51.56917953 125.06293488 51.56382751 125.06495667 51.56013489 125.06567383 51.55168533 125.06480408 51.53707886 125.05152893 51.53335953 125.04710388 51.52792358 125.03956604 51.52719498 125.03249359 51.52692795 125.02990723 51.52540588 125.01615143 51.52738571 125.00106812 51.52769089 124.99874878 51.52355576 124.99317932 51.52145767 124.9881897 51.51473618 124.98420715 51.50981522 124.98088837 51.50959778 124.98074341 51.50680161 124.97605133 51.50614929 124.96964264 51.50597 124.96788788 51.50311279 124.94702911 51.50080872 124.93540955 51.49910736 124.92606354 51.49633408 124.92063904 51.49072647 124.91751099 51.48337173 124.9178772 51.48034668 124.91316986 51.4784584 124.90857697 51.47289276 124.91022491 51.47034454 124.91693878 51.46819687 124.92576599 51.46816635 124.92589569 51.46783447 124.92612457 51.4625206 124.92974091 51.45624161 124.93204498 51.44682693 124.93482208 51.44603729 124.93505859 51.44087219 124.9323349 51.43622971 124.92784119 51.43576431 124.92681122 51.43242645 124.91938782 51.43136978 124.91121674 51.42896271 124.9021759 51.42349243 124.895401 51.4164505 124.88773346 51.41140747 124.88173676 51.40612411 124.87608337 51.40018845 124.87549591 51.39483261 124.87753296 51.3870163 124.87779999 51.38656998 124.87781525 51.38610077 124.87696838 51.38185501 124.86928558 51.3789978 124.85987091 51.37818909 124.85720825 51.37857437 124.84698486 51.37985229 124.84172058 51.38074875 124.83804321 51.38352966 124.82512665 51.38742447 124.80682373 51.38769913 124.80357361 51.38831329 124.80194855 51.38784409 124.80185699 51.38825226 124.79701233 51.38916016 124.78501129 51.38981247 124.78104401 51.39064407 124.77600098 51.38854218 124.76480865 51.38343811 124.75405884 51.37872696 124.75141144 51.37371445 124.75055695 51.36507797 124.74863434 51.36257935 124.74781799 51.35873413 124.74655914 51.3554039 124.74367523 51.35071945 124.73406982 51.34473801 124.72216034 51.34182358 124.71419525 51.33924484 124.70955658 51.33768082 124.70314026 51.33705139 124.70056152 51.33161926 124.6861496 51.33226395 124.66864777 51.33401871 124.65820313 51.33438873 124.647995 51.33335876 124.63838196 51.32852173 124.63280487 51.32537079 124.62483215 51.32724762 124.61732483 51.33467102 124.60850525 51.33944702 124.60309601 51.34399796 124.59766388 51.34804916 124.59327698 51.35533905 124.58809662 51.36227417 124.57995605 51.36889648 124.56774902 51.37078476 124.55987549 51.3739357 124.54844666 51.37194443 124.53361511 51.37291336 124.51905823 51.37762833 124.50887299 51.37839127 124.50015259 51.37979889 124.49259186 51.37877274 124.48261261 51.36436844 124.4750824 51.36063766 124.4703598 51.35946655 124.46387482 51.35929108 124.46291351 51.3590889 124.44898987 51.35633087 124.43592834 51.35197449 124.42932129 51.34415436 124.42350006 51.33600235 124.420578 51.33010483 124.41896057 51.32408905 124.42061615 51.3063736 124.42269897 51.3022728 124.42196655 51.29950714 124.42245483 51.29280853 124.41506195 51.29265976 124.41490173 51.28971863 124.41390991 51.28095627 124.40882874 51.27780914 124.40700531 51.27030563 124.39867401 51.26983261 124.39241791 51.27410126 124.38146973 51.27765656 124.35767365 51.27022552 124.34021759 51.27499008 124.33478546 51.27985382 124.33338165 51.28414917 124.33258057 51.28654099 124.33213806 51.29181671 124.3318634 51.29057312 124.32810211 51.28995895 124.32520294 51.28938675 124.3225174 51.28757477 124.31505585 51.28793716 124.30412292 51.29032516 124.30200195 51.29431534 124.29846191 51.29589081 124.29238129 51.30002975 124.28316498 51.30331802 124.27584076 51.30668259 124.2640686 51.3107872 124.26478577 51.31754303 124.26134491 51.32339859 124.25745392 51.32703018 124.25154877 51.33491135 124.24177551 51.34303665 124.23169708 51.34580231 124.22425079 51.34638214 124.2226181 51.34776688 124.21871185 51.34832382 124.2171402 51.3483696 124.21578979 51.34854889 124.21021271 51.34716797 124.20350647 51.34243393 124.1939621 51.33694077 124.17960358 51.3387146 124.16731262 51.34146118 124.16022491 51.3441658 124.15460205 51.34147263 124.14559937 51.33802032 124.1317749 51.34180832 124.12831116 51.34462738 124.12574005 51.34571838 124.12034607 51.34415436 124.11342621 51.34310913 124.10878754 51.34246826 124.0999527 51.34113312 124.09143066 51.33958435 124.08252716 51.33288193 124.07722473 51.32447052 124.07508087 51.31908798 124.06403351 51.3191452 124.05490112 51.31951904 124.03555298 51.32150269 124.01596832 51.32133865 123.99707031 51.32125092 123.98706818 51.3199234 123.97818756 51.31649017 123.96292877 51.3146553 123.94815826 51.31168747 123.93257904 51.30643463 123.92449188 51.30298996 123.92176056 51.29927444 123.91881561 51.30457687 123.91009521 51.31143951 123.89527893 51.31798935 123.88298798 51.32297516 123.87715912 51.33005142 123.87039948 51.33431625 123.86560822 51.34205246 123.85982513 51.34274673 123.85930634 51.35495758 123.84927368 51.3592453 123.84375 51.36613846 123.83512878 51.36730194 123.82679749 51.36727524 123.81984711 51.36339951 123.81150055 51.36107635 123.80474091 51.35974121 123.79549408 51.35975266 123.78986359 51.35976028 123.78707886 51.36007309 123.78627014 51.36347198 123.77748108 51.36620712 123.77000427 51.3670845 123.76662445 51.36956024 123.75708008 51.37265778 123.74953461 51.37349701 123.74749756 51.37965012 123.7406311 51.38448334 123.73184204 51.39038086 123.72569275 51.39052963 123.72550201 51.39560699 123.71912384 51.39767838 123.71086121 51.39673996 123.70346832 51.39359283 123.70140076 51.39213562 123.70023346 51.3895607 123.69817352 51.3842392 123.69192505 51.38023758 123.68760681 51.37736893 123.68373871 51.37250519 123.67752838 51.36679459 123.67710876 51.35670853 123.67746735 51.35017014 123.67369843 51.34738159 123.66691589 51.34588623 123.66007233 51.34535217 123.65762329 51.34135818 123.65294647 51.33587265 123.65254974 51.32686615 123.65451813 51.32458115 123.65502167 51.31772614 123.65452576 51.31805801 123.64248657 51.31849289 123.63520813 51.31561661 123.62368774 51.31189728 123.60877991 51.31171799 123.59854126 51.31060791 123.58895874 51.30804062 123.5821991 51.3054924 123.57507324 51.3006897 123.57473755 51.29920578 123.57485199 51.29334641 123.57530975 51.29159546 123.57226563 51.28894424 123.56038666 51.28736115 123.55114746 51.28713989 123.54527283 51.2869606 123.54052734 51.28658295 123.53759003 51.28601456 123.53315735 51.28585434 123.52974701 51.28543472 123.52069855 51.28577805 123.5079422 51.28909683 123.49502563 51.29019165 123.47975922 51.2880249 123.46646118 51.28511047 123.45530701 51.27881622 123.45085907 51.27270126 123.44824982 51.27068329 123.44332123 51.27054596 123.44299316 51.26922226 123.43231964 51.27032852 123.42508698 51.27243042 123.41464233 51.27699661 123.40655518 51.27600861 123.39916229 51.27487946 123.39071655 51.27349091 123.38787842 51.2687912 123.37825775 51.26531982 123.37072754 51.26555634 123.36161804 51.26853561 123.35232544 51.27077103 123.34553528 51.27088547 123.33203125 51.268013 123.3187027 51.26488495 123.31066895 51.2634964 123.30709839 51.25801849 123.29724884 51.25429535 123.29044342 51.25106812 123.2853775 51.24944687 123.28282928 51.250103 123.27484894 51.25091171 123.27196503 51.25361633 123.26229858 51.25709534 123.25120544 51.25798416 123.24832916 51.26008224 123.24154663 51.26398468 123.23194122 51.26715088 123.22411346 51.27150726 123.22200012 51.27248001 123.2215271 51.27768326 123.2240448 51.27985764 123.21943665 51.28114319 123.21367645 51.28162766 123.20311737 51.28029251 123.19208527 51.28284836 123.18092346 51.28562164 123.17050934 51.28624725 123.16897583 51.28999329 123.15982056 51.29083252 123.15912628 51.29666138 123.15433502 51.29925156 123.14615631 51.2977562 123.13181305 51.29723358 123.12797546 51.29619598 123.12039948 51.29944992 123.11438751 51.30002213 123.11332703 51.30592728 123.10565186 51.30869675 123.09486389 51.30963898 123.08396149 51.31406021 123.07107544 51.31930542 123.06188965 51.32022476 123.05171204 51.31822968 123.0388031 51.31509018 123.02583313 51.31254578 123.01691437 51.30841446 123.00717163 51.31021881 122.99814606 51.31145096 122.99420166 51.31851196 122.98583984 51.32096481 122.98282623 51.32675171 122.97572327 51.33358383 122.96698761 51.34031677 122.9626236 51.34451294 122.95921326 51.35353088 122.95534515 51.36021805 122.95317078 51.36510468 122.95345306 51.36616135 122.9535141 51.37297058 122.95610046 51.38047791 122.95836639 51.38550186 122.95902252 51.39290619 122.95542145 51.39743805 122.94726563 51.40378571 122.9395752 51.40607071 122.92945862 51.40798569 122.92102051 51.40885544 122.91717529 51.40924072 122.90987396 51.41050339 122.90445709 51.41526413 122.89593506 51.41875076 122.89356995 51.42612076 122.89142609 51.43067169 122.89277649 51.43795776 122.89465332 51.44208145 122.89387512 51.44393539 122.89352417 51.4475441 122.88530731 51.44814682 122.88214111 51.45037842 122.87044525 51.45372009 122.86403656 51.46290588 122.86271667 51.46731949 122.85966492 51.47043228 122.85324097 51.47515869 122.84875488 51.47627258 122.84770203 51.47875595 122.8493042 51.48246002 122.85830688 51.48471069 122.85990143 51.49074554 122.86683655 51.49523544 122.87112427 51.49839783 122.8731308 51.50197601 122.8769989 51.50515366 122.87657166 51.50771713 122.8762207 51.51173782 122.87021637 51.51302719 122.86727905 51.51582336 122.86090088 51.5233345 122.85214996 51.52787781 122.85386658 51.53168106 122.85811615 51.5322876 122.86182404 51.53614426 122.87272644 51.53639221 122.87342834 51.5410881 122.87846375 51.54776764 122.87664032 51.55472565 122.87225342 51.55987549 122.86703491 51.56376648 122.86004639 51.56820679 122.8520813 51.57373428 122.83953094 51.57776642 122.8327713 51.58364868 122.82501221 51.58864212 122.82712555 51.59399796 122.83367157 51.60044479 122.84284973 51.60283279 122.84602356 51.60534668 122.84937286 51.61069489 122.84525299 51.61907959 122.83837128 51.62260056 122.83415222 51.62334061 122.83242798 51.62861633 122.82013702 51.63172531 122.81369019 51.6386528 122.8107605 51.64618301 122.81191254 51.65379333 122.809021 51.66209412 122.80256653 51.66263962 122.80213928 51.67008972 122.79592896 51.67329025 122.79286194 51.67919159 122.78721619 51.68478775 122.78237152 51.6908493 122.77680206 51.69667053 122.77196503 51.70248032 122.76786041 51.71144104 122.76613617 51.7190094 122.76543427 51.72546768 122.76284027 51.73180389 122.75881195 51.73242188 122.75842285 51.73802567 122.75283051 51.73905945 122.75041962 51.74235153 122.74273682 51.74599457 122.7436676 51.75095749 122.74725342 51.75544357 122.7515564 51.75746918 122.75350189 51.76532364 122.76130676 51.77122116 122.76383209 51.77806473 122.76494598 51.78014374 122.76340485 51.78317642 122.7611618 51.78918076 122.75852966 51.79423141 122.75769806 51.80187607 122.75331116 51.80680084 122.74729919 51.81257248 122.74465942 51.81744385 122.74159241 51.82304764 122.73599243 51.83221436 122.72528076 51.83837891 122.724617 51.84194183 122.72647095 51.84472275 122.7279129 51.85319519 122.72762299 51.85943222 122.72463226 51.86773682 122.72137451 51.87671661 122.71852875 51.88193893 122.7113266 51.88521194 122.70567322 51.88697815 122.70246124 51.88877106 122.69920349 51.89356232 122.70029449 51.89719772 122.7011261 51.90602112 122.70639801 51.91224289 122.71560669 51.91601944 122.72135925 51.92169189 122.72388458 51.92557907 122.72409058 51.93178177 122.72294617 51.94072342 122.71842194 51.94171906 122.7179184 51.94192886 122.71794128 51.94765472 122.71860504 51.95448685 122.72045135 51.96156311 122.72119904 51.96659088 122.72146606 51.97074509 122.719841 51.9773941 122.71907806 51.97880936 122.70544434 51.9787941 122.70536804 51.97529602 122.68598938 51.97318649 122.67699432 51.97880936 122.67024231 51.98372269 122.66457367 51.98647308 122.66434479 51.9906044 122.66381836 51.99547577 122.66036987 52 122.65620422 52.00377274 122.65630341 52.01563644 122.65661621 52.02223969 122.65458679 52.03017807 122.64881897 52.03607941 122.64532471 52.05776596 122.64362335 52.06200409 122.63424683 52.06246185 122.62804413 52.06280136 122.62347412 52.06570816 122.61746979 52.06813431 122.61857605 52.08637619 122.62689972 52.08723831 122.62723541 52.09348679 122.62966919 52.09685898 122.63158417 52.10222244 122.63462067 52.10818863 122.63705444 52.11804581 122.63014984 52.12132645 122.62786102 52.12860107 122.62276459 52.13523483 122.62368774 52.13673782 122.63589478 52.13674927 122.63633728 52.13710785 122.64924622 52.13875961 122.67823792 52.13907242 122.68371582 52.14299011 122.68732452 52.14496231 122.70100403 52.14771652 122.71562958 52.14858246 122.72021484 52.15211868 122.730896 52.15670776 122.7326355 52.15761948 122.73297882 52.16085434 122.73590088 52.1652298 122.73984528 52.16667557 122.74314117 52.1699028 122.75049591 52.17710495 122.76294708 52.19541931 122.7665863 52.19720078 122.76646423 52.20409775 122.76599884 52.20934296 122.76550293 52.21777725 122.76306152 52.22686005 122.75725555 52.23122025 122.75901031 52.23847961 122.77996826 52.2385025 122.78003693 52.24378586 122.78288269 52.24982834 122.78064728 52.25130081 122.78009796 52.25352859 122.77445984 52.25554657 122.77031708 52.26094437 122.76125336 52.26546097 122.75592804 52.26495361 122.75073242 52.25885773 122.73487854 52.25737 122.7230072 52.25611496 122.71187592 52.25489044 122.70371246 52.2602272 122.68906403 52.26914215 122.6895752 52.27535629 122.67190552 52.27552032 122.64434814 52.27249527 122.63884735 52.27082825 122.63293457 52.26926422 122.6151123 52.26820374 122.60136414 52.26529312 122.58618164 52.2652092 122.57911682 52.28137589 122.55369568 52.28374863 122.54133606 52.28527069 122.53459167 52.28672791 122.52262115 52.28715134 122.50026703 52.29067993 122.48973083 52.2947998 122.47097778 52.29953003 122.46560669 52.30251312 122.46662903 52.31331253 122.47151184 52.317173 122.4695282 52.32353973 122.46708679 52.32860947 122.47028351 52.33526993 122.47342682 52.34011841 122.477005 52.34648895 122.47494507 52.35300827 122.46615601 52.36201859 122.45542908 52.3697319 122.45070648 52.37929535 122.44815826 52.38611221 122.44495392 52.39244843 122.43989563 52.39212418 122.43243408 52.37988663 122.42201233 52.3726387 122.40918732 52.37618637 122.40048218 52.38412857 122.39611816 52.39113617 122.39028168 52.39320755 122.37341309 52.39657974 122.3691864 52.40702057 122.36398315 52.41222 122.35969543 52.40995026 122.34333801 52.41145706 122.33618927 52.41644669 122.33339691 52.42739105 122.33152008 52.43345642 122.32383728 52.43984222 122.32286835 52.44417191 122.32196808 52.45807266 122.31886292 52.46755219 122.30992889 52.47386169 122.30334473 52.47622681 122.29241943 52.47534561 122.27823639 52.47029877 122.26008606 52.46966171 122.24739075 52.46944046 122.23168945 52.47046661 122.22341919 52.46785355 122.20069885 52.47492218 122.18397522 52.48261261 122.17807007 52.48640442 122.17193604 52.49411011 122.16751862 52.51208496 122.16195679 52.51341248 122.15891266 52.51352692 122.15142059 52.51127243 122.13802338 52.50729752 122.13219452 52.5009346 122.13468933 52.49339676 122.13498688 52.48500061 122.12371826 52.47452927 122.12637329 52.47050476 122.11717987 52.46580505 122.10876465 52.45683289 122.10501099 52.45104218 122.1000061 52.44258118 122.08464813 52.43874359 122.07321167 52.43172836 122.0776062 52.42565536 122.08383942 52.41933823 122.07437897 52.41397476 122.05292511 52.41160583 122.03322601 52.40206146 122.03661346 52.39343643 122.04032898 52.37610245 122.02835846 52.37000275 122.0185318 52.36644745 122.01047516 52.36427689 122.00347137 52.34928894 121.98134613 52.34550095 121.97330475 52.34246826 121.96970367 52.33601379 121.96625519 52.32611847 121.96220398 52.32320023 121.95152283 52.3195076 121.94944763 52.31607056 121.94884491 52.31079102 121.94758606 52.30413437 121.9460144 52.29719162 121.94072723 52.28450394 121.92004395 52.28109741 121.90790558 52.28031158 121.90198517 52.2794838 121.89382172 52.28013611 121.87852478 52.28320694 121.8578949 52.28259277 121.84898376 52.28141785 121.83413696 52.28245544 121.82813263 52.28511047 121.82316589 52.2949791 121.79998016 52.29912949 121.78935242 52.3014946 121.78104401 52.30470657 121.76895905 52.30686569 121.76215363 52.3105011 121.74855804 52.31122208 121.73809052 52.31462097 121.71183014 52.31681442 121.70687103 52.32000351 121.7063446 52.32825851 121.70780182 52.34175491 121.70825958 52.35145569 121.7014389 52.35480499 121.69717407 52.35857773 121.69139099 52.36670685 121.68613434 52.37652969 121.67369843 52.38296509 121.6636734 52.38913727 121.65141296 52.39790726 121.65582275 52.41854858 121.67160034 52.420578 121.6700058 52.4260788 121.65888977 52.43202209 121.64700317 52.43743896 121.64336395 52.44127655 121.64092255 52.4431839 121.63298035 52.44163513 121.61212158 52.44039917 121.59573364 52.44198227 121.58330536 52.44508362 121.57828522 52.45200729 121.57006836 52.45908356 121.55810547 52.46002579 121.54795837 52.45695877 121.53203583 52.45304108 121.51914978 52.45540237 121.51154327 52.47140503 121.50057983 52.47831345 121.49197388 52.48141861 121.47608948 52.4817276 121.46896362 52.48815155 121.45887756 52.49555206 121.4303894 52.49942017 121.41856384 52.50108719 121.41098022 52.50522614 121.40139008 52.5227356 121.39702606 52.5251236 121.39089966 52.52794266 121.38399506 52.52833176 121.37010956 52.5273056 121.35443115 52.53381348 121.34880829 52.54822922 121.32848358 52.55691528 121.31785583 52.56469727 121.31815338 52.56943893 121.31562805 52.58124161 121.28079224 52.5825882 121.26946259 52.58137512 121.25602722 52.57913208 121.24790955 52.57759476 121.2405014 52.57542419 121.22562408 52.57429886 121.21631622 52.57751846 121.20711517 52.58719254 121.19039154 52.59436798 121.18431854 52.6023407 121.19284058 52.61600876 121.22053528 52.62124252 121.22960663 52.62863159 121.23254395 52.63394165 121.24498749 52.63703537 121.26058197 52.64124298 121.27497864 52.64737701 121.28326416 52.65605927 121.2831192 52.66143036 121.28806305 52.67110062 121.3119278 52.67564392 121.32106018 52.67958069 121.33361816 52.67853546 121.33818817 52.68067169 121.36288452 52.68286133 121.36914825 52.68738174 121.37716675 52.69363022 121.3809433 52.70005417 121.39261627 52.71429062 121.41702271 52.72293091 121.42556763 52.72872925 121.44067383 52.74807739 121.45842743 52.75805283 121.46540833 52.7651329 121.46501923 52.76938248 121.47156525 52.77290726 121.47627258 52.77653885 121.49716949 52.77851868 121.50460052 52.78294754 121.50888062 52.79135895 121.51785278 52.79555893 121.52214813 52.8102417 121.54737854 52.81600189 121.56102753 52.81802368 121.57110596 52.82241821 121.57350922 52.83471298 121.59437561 52.84121704 121.5996933 52.8468132 121.60506439 52.85200119 121.61347198 52.86354828 121.60758972 52.86753082 121.60058594 52.87271118 121.5969162 52.87802505 121.59966278 52.88241577 121.60207367 52.88605118 121.60075378 52.88991165 121.59941864 52.89271545 121.60266876 52.89448166 121.62298584 52.89869308 121.62805939 52.90638733 121.63597107 52.90821838 121.64797974 52.91521835 121.65555573 52.9217453 121.66203308 52.93283844 121.66864777 52.93903732 121.66985321 52.94658661 121.67022705 52.94961166 121.6730957 52.95449448 121.67739105 52.96125412 121.68424225 52.96795654 121.68806458 52.97607422 121.69447327 52.98235321 121.7002182 52.98830795 121.70067596 52.99271393 121.70424652 52.9964447 121.70822144 52.99886322 121.71529388 53.00113297 121.72692871 53.00292587 121.73744965 53.00701523 121.74861145 53.01152802 121.75786591 53.01898575 121.77871704 53.02705383 121.78249359 53.03258896 121.78526306 53.04154205 121.78749084 53.04892731 121.79130554 53.05334854 121.79564667 53.05900955 121.80561829 53.06410599 121.80916595 53.07141876 121.79629517 53.07641602 121.7816391 53.08210754 121.78022766 53.09283447 121.76642609 53.10255051 121.772789 53.10823441 121.77098846 53.11434555 121.76765442 53.12070465 121.76544952 53.14125443 121.75115204 53.14728546 121.74325562 53.14403152 121.72782898 53.14403915 121.71566772 53.1573143 121.69181824 53.15982437 121.67914581 53.16305161 121.66833496 53.16819382 121.66236877 53.1804657 121.64614105 53.18638992 121.64508057 53.19430923 121.65303802 53.19711685 121.66849518 53.20461655 121.66621399 53.21922302 121.66470337 53.22732925 121.67038727 53.23693466 121.6706543 53.24071884 121.66513062 53.24679565 121.65986633 53.2592392 121.62874603 53.25549698 121.61254883 53.26008606 121.60125732 53.26659775 121.59519958 53.2808609 121.57614136 53.28640747 121.56745911 53.29027939 121.55504608 53.29430008 121.55025482 53.30279922 121.54064178 53.30764771 121.53160095 53.31093216 121.51272583 53.31388855 121.50035095 53.32069397 121.49768829 53.33117294 121.48937988 53.33171082 121.4916153 53.33651733 121.51165771 53.34218597 121.5328598 53.34404373 121.54516602 53.34518814 121.55725861 53.34834671 121.5776062 53.35329056 121.59860992 53.35608673 121.60636902 53.36282349 121.62303925 53.36841583 121.63904572 53.37254333 121.65176392 53.37667084 121.66448212 53.3829155 121.67571259 53.38708496 121.68605804 53.38842392 121.69149017 53.38851166 121.69239044 53.38658905 121.70263672 53.38446808 121.71477509 53.38409042 121.71692657 53.38557434 121.72969818 53.38652039 121.73781586 53.38963318 121.74781036 53.39178085 121.75470734 53.39884949 121.77041626 53.40736008 121.79219818 53.41492081 121.81532288 53.41559219 121.83596039 53.41947556 121.84533691 53.42313385 121.85909271 53.42275238 121.8663559 53.42190552 121.88240051 53.42162704 121.90441895 53.42597961 121.9211731 53.4287796 121.95095062 53.42958069 121.96868896 53.42782211 121.9803009 53.42742157 121.98294067 53.42414093 122.00457764 53.41909027 122.03315735 53.42060089 122.04703522 53.42110443 122.05168152 53.42201233 122.06004333 53.42113876 122.07605743 53.42776871 122.09909821 53.43735123 122.10041809 53.45944214 122.1251297 53.46541595 122.13204193 53.46744919 122.13835144 53.46937943 122.14663696 53.46962357 122.15667725 53.46918106 122.16464996 53.46903992 122.16723633 53.46683884 122.17822266 53.46457291 122.19052124 53.46229935 122.20281982 53.46123886 122.21465302 53.46129608 122.2154007 53.46216202 122.22677612 53.46385956 122.23902893 53.46863556 122.25311279 53.47373962 122.2612381 53.48388672 122.27883148 53.4958992 122.30539703 53.49818039 122.31442261 53.49834061 122.31556702 53.49842072 122.31632233 53.49848938 122.31707001 53.49853897 122.31781769 53.49858093 122.318573 53.49860001 122.31933594 53.49861145 122.32009125 53.49860001 122.32084656 53.49858093 122.32160187 53.49853897 122.32235718 53.49848175 122.32311249 53.49840927 122.32386017 53.49832916 122.32460785 53.49822998 122.32534027 53.49811172 122.32608032 53.49798203 122.32681274 53.49784851 122.32752228 53.4977951 122.32774353 53.49768066 122.32823181 53.497509 122.32892609 53.49732208 122.32962036 53.49195862 122.34010315 53.4871788 122.34732819 53.48414993 122.35186005 53.47637939 122.36160278 53.45452881 122.38260651 53.4446106 122.40040588 53.44166183 122.41371155 53.44141006 122.43136597 53.44181061 122.44115448 53.44184875 122.44212341 53.44481659 122.45142365 53.44935226 122.46391296 53.4500885 122.46620941 53.45233154 122.47322083 53.45617294 122.48267365 53.45588684 122.48757172 53.45558167 122.49285889 53.45473862 122.5074234 53.453022 122.52184296 53.45308304 122.5224762 53.45627975 122.55619049 53.45755768 122.56991577 53.46058655 122.60249329 53.46113586 122.61339569 53.46260834 122.64251709 53.45979309 122.66596985 53.45914459 122.6713562 53.45809937 122.68884277 53.46032333 122.71142578 53.46192932 122.72770691 53.46170425 122.7387085 53.46147919 122.74970245 53.45867538 122.79628754 53.45854568 122.79699707 53.45605469 122.81054688 53.45290375 122.83354187 53.45600891 122.85466766 53.45933533 122.87052917 53.46144867 122.8806076 53.46646118 122.89911652 53.47536087 122.92568207 53.48159409 122.9385376 53.48203659 122.94114685 53.48545074 122.96128845 53.48958969 122.97968292 53.49332047 122.98817444 53.49477768 122.99149323 53.50064468 123.00060272 53.50743103 123.02068329 53.5112114 123.03752899 53.51126099 123.04968262 53.50770187 123.06793976 53.50759506 123.06851959 53.50483322 123.08338165 53.50284958 123.09406281 53.50025177 123.10977936 53.5002861 123.12193298 53.50144577 123.12778473 53.50333023 123.13730621 53.50814056 123.1503067 53.5166893 123.16532135 53.51755142 123.1668396 53.52817154 123.17684174 53.54323196 123.19304657 53.55138016 123.2039566 53.55459213 123.21669769 53.55770874 123.2307663 53.56003952 123.24471283 53.56085968 123.25701904 53.55974197 123.27437592 53.55833435 123.27954102 53.55764008 123.28209686 53.55183029 123.29724884 53.54699707 123.30988312 53.54261017 123.32798004 53.54111862 123.33851624 53.53660965 123.35941315 53.53268051 123.37932587 53.53144073 123.39827728 53.53128433 123.42499542 53.53126907 123.42772675 53.53031158 123.44230652 53.52548981 123.44876862 53.51633453 123.45445251 53.50650024 123.45704651 53.49811172 123.46433258 53.49570084 123.47419739 53.49661255 123.48318481 53.49676514 123.48471069 53.50331879 123.49182892 53.50881958 123.48842621 53.51644135 123.47953033 53.52202988 123.47467804 53.52820206 123.47434998 53.53601074 123.47580719 53.54536057 123.4805069 53.55096054 123.48892975 53.552742 123.49917603 53.554142 123.50723267 53.55404282 123.50871277 53.55316925 123.52179718 53.55210495 123.52354431 53.54430008 123.53636932 53.53707123 123.53942871 53.5309906 123.53829193 53.51460266 123.52046967 53.50881958 123.51496124 53.50101089 123.5134964 53.4958992 123.52433777 53.4944458 123.53291321 53.49594498 123.53606415 53.49983978 123.54424286 53.50437164 123.55539703 53.50918961 123.56220245 53.51671219 123.56804657 53.52442169 123.57097626 53.53348923 123.56678772 53.54043198 123.56809235 53.54233551 123.56957245 53.54544067 123.57199097 53.54756165 123.57977295 53.54716873 123.58558655 53.54636765 123.5881424 53.53710938 123.61763 53.53033829 123.63993835 53.52618027 123.64948273 53.51787949 123.65526581 53.5078392 123.66072845 53.49587631 123.66876221 53.48926163 123.67782593 53.49303055 123.69338989 53.49368286 123.69687653 53.49539185 123.70598602 53.49736023 123.71852112 53.49729919 123.72525787 53.49666977 123.73458862 53.49638367 123.73612976 53.49473953 123.74501801 53.49082565 123.76113892 53.48797226 123.77340698 53.4860611 123.78383636 53.48590851 123.79190826 53.48611832 123.79374695 53.4874115 123.80502319 53.48835754 123.81465149 53.48854065 123.8295517 53.48871994 123.84442139 53.48677826 123.85168457 53.48546219 123.85661316 53.4797287 123.86966705 53.47026062 123.89008331 53.46088028 123.9091568 53.45399094 123.9213028 53.44911194 123.92775726 53.44721985 123.93750763 53.44068146 123.95038605 53.43400192 123.96526337 53.42809296 123.97486877 53.4214325 123.9836731 53.41110229 124 53.4100914 124.00113678 53.40883636 124.00254059 53.39640045 124.01850891 53.39157486 124.03140259 53.39157486 124.03172302 53.39172363 124.06253052 53.38573837 124.07234192 53.3780632 124.08190918 53.36703873 124.09564972 53.36292648 124.09648895 53.3555603 124.09799194 53.3499794 124.10416412 53.34791946 124.10644531 53.34746933 124.10694122 53.34368134 124.11501312 53.34395218 124.11872864 53.34498978 124.13301086 53.34697342 124.14213562 53.34828186 124.14816284 53.35659027 124.162323 53.36458588 124.19235992 53.36795044 124.20871735 53.36809921 124.2208786 53.36550903 124.24575043 53.34767532 124.27121735 53.34381866 124.27750397 53.32810211 124.30310822 53.32522964 124.30797577 53.31835938 124.31962585 53.30099869 124.33158875 53.29381943 124.33300781 53.28723526 124.34023285 53.28705978 124.34042358 53.2816391 124.34571838 53.27301788 124.35519409 53.27156067 124.35679626 53.26771927 124.36100006 53.26529694 124.36116791 53.26153946 124.36141968 53.25342941 124.36720276 53.24618149 124.37548828 53.24123001 124.39711761 53.23981094 124.40660095 53.23441315 124.41726685 53.23251724 124.42101288 53.22950363 124.42311859 53.21815872 124.43105316 53.21672058 124.43206024 53.20864868 124.45197296 53.20743942 124.4572525 53.20050049 124.48757172 53.19688034 124.51541901 53.19488907 124.53032684 53.19607162 124.55459595 53.20063019 124.5916214 53.19974136 124.62853241 53.19947052 124.63965607 53.20096207 124.6481781 53.19919205 124.66304016 53.19225311 124.69127655 53.18904877 124.70430756 53.1815033 124.71526337 53.17921829 124.71598816 53.1758728 124.71705627 53.15644836 124.715271 53.15433121 124.71795654 53.15097046 124.72098541 53.14955902 124.72225952 53.14122009 124.74213409 53.13861847 124.74833679 53.13441467 124.77507782 53.13550949 124.80581665 53.13809204 124.81266785 53.13269043 124.83304596 53.12458801 124.84287262 53.12417221 124.84337616 53.10868073 124.8543396 53.10462189 124.85720825 53.098629 124.86400604 53.09429169 124.87509155 53.0951004 124.88754272 53.09767914 124.89546967 53.10647202 124.89998627 53.116436 124.90126038 53.13264084 124.89605713 53.13740921 124.89290619 53.14850998 124.88556671 53.15481949 124.88368225 53.16117096 124.88941193 53.16376114 124.89391327 53.1737709 124.91734314 53.179245 124.94020081 53.18193054 124.95141602 53.18925095 124.97189331 53.19285202 124.98197174 53.19417953 125 53.19617081 125.02688599 53.19567108 125.04830933 53.19543076 125.05873871 53.19496155 125.09513092 53.19739914 125.12298584 53.195858 125.14312744 53.19499969 125.15437317 53.19158936 125.18820953 53.18939209 125.20082092 53.18619156 125.21041107 53.18335724 125.21891022 53.1832428 125.21925354 53.17911911 125.23162842 53.158535 125.27539063 53.14844894 125.29682922 53.14422989 125.31009674 53.14267349 125.31498718 53.1385231 125.3259964 53.13660431 125.34731293 53.13001633 125.36522675 53.12852478 125.36927795 53.12382507 125.38646698 53.12279129 125.394104 53.12049103 125.41105652 53.11325073 125.42758179 53.10512924 125.44603729 53.10109329 125.46273041 53.10079956 125.46325684 53.09590149 125.47203827 53.09030914 125.48206329 53.07427216 125.49223328 53.07328033 125.49286652 53.05847931 125.49494171 53.0496788 125.5013504 53.04771805 125.50556946 53.04642105 125.50836182 53.04938889 125.52348328 53.05499268 125.53663635 53.06348038 125.54820251 53.07085037 125.56004333 53.07337952 125.56408691 53.07620239 125.57006836 53.08073044 125.57965851 53.07954025 125.58370209 53.07460022 125.60045624 53.06935883 125.61274719 53.06105042 125.61981201 53.05806732 125.62612152 53.05656052 125.62930298 53.05337143 125.62980652 53.04725647 125.63493347 53.04154968 125.6397171 53.02671814 125.65113831 53.02090454 125.65561676 53.00746536 125.66919708 53.00041962 125.68210602 52.99713898 125.69291687 52.99431229 125.71229553 52.99401855 125.71431732 52.99288177 125.71729279 52.98809433 125.72985077 52.98784256 125.7305069 52.98450851 125.73636627 52.97937012 125.7387085 52.97262192 125.73712921 52.96917725 125.73484802 52.9582901 125.72763824 52.94122314 125.72618103 52.93411636 125.72238159 52.92868042 125.70388794 52.9270401 125.68744659 52.92121887 125.67433929 52.92004395 125.67173767 52.91595078 125.66265869 52.90872955 125.65699005 52.8925705 125.65162659 52.8839798 125.65377045 52.87100983 125.65585327 52.8601265 125.66835785 52.85681915 125.67215729 52.86124039 125.68888855 52.86379623 125.6944046 52.87514877 125.71888733 52.87590027 125.72106171<span class="hljs-tag">&lt;/<span class="hljs-name">gml:posList</span>&gt;</span><br>                                <span class="hljs-tag">&lt;/<span class="hljs-name">gml:LinearRing</span>&gt;</span><br>                            <span class="hljs-tag">&lt;/<span class="hljs-name">gml:exterior</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">gml:Polygon</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">gml:surfaceMember</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">gml:MultiSurface</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">cesium:the_geom</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:GID_0</span>&gt;</span>CHN<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:GID_0</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:NAME_0</span>&gt;</span>China<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:NAME_0</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:GID_1</span>&gt;</span>CHN.11_1<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:GID_1</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:NAME_1</span>&gt;</span>Heilongjiang<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:NAME_1</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:NL_NAME_1</span>&gt;</span>黑龙江省|黑龍江省<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:NL_NAME_1</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:GID_2</span>&gt;</span>CHN.11.2_1<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:GID_2</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:NAME_2</span>&gt;</span>Daxing&#x27;anling<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:NAME_2</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:VARNAME_2</span>&gt;</span>Dàxīng&#x27;ānlǐng<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:VARNAME_2</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:NL_NAME_2</span>&gt;</span>大兴安岭地区<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:NL_NAME_2</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:TYPE_2</span>&gt;</span>Dìqu<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:TYPE_2</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:ENGTYPE_2</span>&gt;</span>Prefecture<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:ENGTYPE_2</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:CC_2</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:HASC_2</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">cesium:0</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">wfs:member</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">wfs:FeatureCollection</span>&gt;</span><br></code></pre></td></tr></table></figure><p>插入操作</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">wfs:Transaction</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;2.0.2&quot;</span> <span class="hljs-attr">service</span>=<span class="hljs-string">&quot;WFS&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:cesium</span>=<span class="hljs-string">&quot;http://geoserver.org/cesium&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://localhost:8080/geoserver/cesium&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:gml</span>=<span class="hljs-string">&quot;http://www.opengis.net/gml/3.2&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:wfs</span>=<span class="hljs-string">&quot;http://www.opengis.net/wfs/2.0&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>  <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;</span></span><br><span class="hljs-tag"><span class="hljs-string">    http://www.opengis.net/wfs/2.0</span></span><br><span class="hljs-tag"><span class="hljs-string">    http://localhost:8080/geoserver/schemas/wfs/2.0/wfs.xsd</span></span><br><span class="hljs-tag"><span class="hljs-string">    http://geoserver.org/cesium http://localhost:8080/geoserver/cesium/wfs?service=WFS<span class="hljs-symbol">&amp;amp;</span>version=2.0.0<span class="hljs-symbol">&amp;amp;</span>request=DescribeFeatureType<span class="hljs-symbol">&amp;amp;</span>typeName=cesium%3A0</span></span><br><span class="hljs-tag"><span class="hljs-string">    http://www.opengis.net/gml/3.2 http://localhost:8080/geoserver/schemas/gml/3.2.1/gml.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">wfs:Insert</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">cesium:0</span> <span class="hljs-attr">gml:id</span>=<span class="hljs-string">&quot;0.133&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:the_geom</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">gml:MultiSurface</span> <span class="hljs-attr">srsName</span>=<span class="hljs-string">&quot;urn:ogc:def:crs:EPSG::4326&quot;</span> <span class="hljs-attr">srsDimension</span>=<span class="hljs-string">&quot;2&quot;</span> <span class="hljs-attr">gml:id</span>=<span class="hljs-string">&quot;0.133.the_geom&quot;</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">gml:surfaceMember</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">gml:Polygon</span> <span class="hljs-attr">gml:id</span>=<span class="hljs-string">&quot;0.133.the_geom.1&quot;</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">gml:exterior</span>&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">gml:LinearRing</span>&gt;</span><br>                                    <span class="hljs-tag">&lt;<span class="hljs-name">gml:posList</span>&gt;</span>30.25465775 115.07079315 30.25456238 115.06994629 30.2590847 115.0690918 30.26287651 115.05915833 30.26636124 115.0373764 30.26559639 115.02616882 30.26219177 115.01602173 30.24378777 115.01037598 30.23891258 115.00079346 30.2325573 114.99259949 30.22265625 114.99238586 30.21601677 114.98714447 30.21361542 114.97647095 30.21756935 114.95479584 30.21509171 114.94419098 30.21652412 114.9338913 30.22030449 114.92395782 30.22470665 114.90261841 30.23828316 114.8738327 30.237463 114.86690521 30.24502373 114.85974121 30.26275063 114.85244751 30.27095985 114.84703064 30.27897072 114.84107971 30.28544044 114.83226776 30.31149673 114.81967163 30.31545067 114.80973816 30.31489944 114.79901123 30.30734825 114.75548553 30.30898285 114.74446869 30.31279564 114.73446655 30.32083511 114.728508 30.3254776 114.71905518 30.32468033 114.70842743 30.31648254 114.70349121 30.30724144 114.70632935 30.29900169 114.71166992 30.29092407 114.71338654 30.2834053 114.70578766 30.27821732 114.69649506 30.26984024 114.66522217 30.26228333 114.65762329 30.25385284 114.65278625 30.24425125 114.65103912 30.22662354 114.65866089 30.21840668 114.66404724 30.21080589 114.67111969 30.1901722 114.69676971 30.18137741 114.70079803 30.17220116 114.69802856 30.16435051 114.69155121 30.15465546 114.69039154 30.14727783 114.69818115 30.14146996 114.70727539 30.13384056 114.71439362 30.1242466 114.71257019 30.11707115 114.72077942 30.10812569 114.72307587 30.09960556 114.71850586 30.07957649 114.71770477 30.07112122 114.72245026 30.06212807 114.72244263 30.04593849 114.69551849 30.04584122 114.68448639 30.04269409 114.67558289 30.03408623 114.67113495 30.02782249 114.65065765 30.02654648 114.64027405 30.02986717 114.63014984 30.03682518 114.62254333 30.04561043 114.61869812 30.0521698 114.61106873 30.05439758 114.60043335 30.05428886 114.58940887 30.04920769 114.56819916 30.05509186 114.5532608 30.06316757 114.54646301 30.06556892 114.53590393 30.08077812 114.52945709 30.09724998 114.51882172 30.11962128 114.4966507 30.12949181 114.49556732 30.16864777 114.49947357 30.18676567 114.50556946 30.20768929 114.52744293 30.22538757 114.53474426 30.24469757 114.53747559 30.25306511 114.54249573 30.25988579 114.55049896 30.27596855 114.56256104 30.29089546 114.57728577 30.30810165 114.58521271 30.33786583 114.58705902 30.40586662 114.57727051 30.41341209 114.58026123 30.42062187 114.57582092 30.44076347 114.57483673 30.45099258 114.57481384 30.47934532 114.58094788 30.48887062 114.57894897 30.49550056 114.57282257 30.49972153 114.56293488 30.50855637 114.56085205 30.53451347 114.57071686 30.54680061 114.59066772 30.56194687 114.60480499 30.55775261 114.62402344 30.5594101 114.63503265 30.57954979 114.67248535 30.59669876 114.71140289 30.60749054 114.74160767 30.61718369 114.76052856 30.6186409 114.77120209 30.61618042 114.77648163 30.61187172 114.78574371 30.59084511 114.81065369 30.57367134 114.82085419 30.57622337 114.82484436 30.5783329 114.82788849 30.58020401 114.83030701 30.58137512 114.83240509 30.58192062 114.8342514 30.58251762 114.83656311 30.58494759 114.83777618 30.58829117 114.83904266 30.59139061 114.83924866 30.5942421 114.83847046 30.59700012 114.83835602 30.59949684 114.84043121 30.60252953 114.84442139 30.60474968 114.84775543 30.60698891 114.85222626 30.60944748 114.85595703 30.61115265 114.85930634 30.61286354 114.86299133 30.61411095 114.86647797 30.61478424 114.86972046 30.61545372 114.87242126 30.61629486 114.87578583 30.6166153 114.87843323 30.61659431 114.88108826 30.6145668 114.88383484 30.61218071 114.88573456 30.60996628 114.88762665 30.6073513 114.88933563 30.60513115 114.89083099 30.60285568 114.89232635 30.60064507 114.89442444 30.59866714 114.89650726 30.59778023 114.89904022 30.59771156 114.90322113 30.59786606 114.90606689 30.59794617 114.9082489 30.59798241 114.9106369 30.59771729 114.91255951 30.59664345 114.91364288 30.59520912 114.91413116 30.59332657 114.9148941 30.59006882 114.91514587 30.58668327 114.91553497 30.58433723 114.91603851 30.58215714 114.91614532 30.58019829 114.91551971 30.57818985 114.91488647 30.5759449 114.91432953 30.57398605 114.91383362 30.5716877 114.91320801 30.5697937 114.91310883 30.56761551 114.91347504 30.5662384 114.91383362 30.56533241 114.9145813 30.56494904 114.91590881 30.56537628 114.91841888 30.56593323 114.92119598 30.56614113 114.92390442 30.56530762 114.92650604 30.56385231 114.9291153 30.56244469 114.93138885 30.56133461 114.93471527 30.56126022 114.93796539 30.5607872 114.94115448 30.56070328 114.94380188 30.56056213 114.94632721 30.56070709 114.94863892 30.56215858 114.95027161 30.56394768 114.95117188 30.56534195 114.9526062 30.56674767 114.95483398 30.56821251 114.95738983 30.5684166 114.9601059 30.56850052 114.96255493 30.56889153 114.96625519 30.57036781 114.96934509 30.57201576 114.97270203 30.57375526 114.97518921 30.5759201 114.97806549 30.57777596 114.98028564 30.58032036 114.98203278 30.58280754 114.98358917 30.58471489 114.98461151 30.58720207 114.98642731 30.59021378 114.98856354 30.59356308 114.9906311 30.59591484 114.99105835 30.59815407 114.99128723 30.6000061 114.99211884 30.60191345 114.99347687 30.60320282 114.99591064 30.60467339 114.99880219 30.60673141 115.00314331 30.60780144 115.00637054 30.60972786 115.00912476 30.61220741 115.01033783 30.61542892 115.01095581 30.61806679 115.01077271 30.62059975 115.01186371 30.62252998 115.01481628 30.62446976 115.01908875 30.62762833 115.0240097 30.63018417 115.02661896 30.63381577 115.02888489 30.63664818 115.03063202 30.63867569 115.03231812 30.6415081 115.03419495 30.64394188 115.03601074 30.64569092 115.03817749 30.64674187 115.0402832 30.6463089 115.04221344 30.64582253 115.04520416 30.64367104 115.04735565 30.64126968 115.04818726 30.63938713 115.04921722 30.63746262 115.05117035 30.63593864 115.05351257 30.63437271 115.05685425 30.63228989 115.06033325 30.63042641 115.0631485 30.62855148 115.06503296 30.62530136 115.06654358 30.62244415 115.06725311 30.61940575 115.06716156 30.61694145 115.0676651 30.61017609 115.07056427 30.60916138 115.06996918 30.60109329 115.06207275 30.59676743 115.06034088 30.58938408 115.05738831 30.56394386 115.05521393 30.56005478 115.05630493 30.55020142 115.0555954 30.54606247 115.05297089 30.54190636 115.04823303 30.54345322 115.03945923 30.54707336 115.03279114 30.54818916 115.02826691 30.54654884 115.02244568 30.54283905 115.01610565 30.53433609 115.0121994 30.52701187 115.01279449 30.52150536 115.01151276 30.50706863 115.010849 30.49467087 115.00617981 30.48962593 115.00335693 30.4792614 114.99756622 30.46479607 114.99318695 30.46328545 114.9932251 30.4604969 114.99330139 30.44945145 114.99359131 30.4366684 114.99980164 30.43590927 115.00042725 30.4305191 115.00489044 30.4314537 115.00779724 30.43627548 115.00934601 30.44041443 115.01196289 30.43951225 115.01356506 30.43195534 115.01416016 30.42029572 115.0174408 30.41604424 115.01882172 30.4114933 115.01499176 30.40950584 115.01331329 30.40788078 115.02080536 30.40662766 115.02509308 30.40555573 115.02778625 30.40491867 115.02967834 30.40428543 115.03154755 30.40122986 115.03618622 30.39901924 115.03996277 30.39387131 115.04644012 30.39106178 115.05059814 30.38635254 115.05448914 30.38142204 115.05864716 30.37454796 115.0623703 30.36911201 115.06557465 30.36444664 115.06738281 30.35965157 115.06918335 30.35485649 115.07098389 30.35124588 115.07247162 30.34636307 115.07381439 30.34120369 115.07541656 30.3367691 115.07607269 30.33215523 115.0772934 30.32249641 115.07880402 30.3150444 115.08013153 30.30809975 115.08152008 30.3024826 115.08247375 30.2984314 115.08317566 30.29518127 115.0830307 30.29125786 115.08210754 30.28686714 115.08094788 30.28105927 115.07752228 30.27635765 115.0754776 30.27189636 115.0736084 30.269207 115.07273102 30.26827049 115.07242584 30.26795387 115.07238007 30.26357841 115.07171631 30.2598877 115.0712738 30.25707436 115.07108307 30.25465775 115.07079315<span class="hljs-tag">&lt;/<span class="hljs-name">gml:posList</span>&gt;</span><br>                                <span class="hljs-tag">&lt;/<span class="hljs-name">gml:LinearRing</span>&gt;</span><br>                            <span class="hljs-tag">&lt;/<span class="hljs-name">gml:exterior</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">gml:Polygon</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">gml:surfaceMember</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">gml:MultiSurface</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">cesium:the_geom</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:GID_0</span>&gt;</span>CHN<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:GID_0</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:NAME_0</span>&gt;</span>China<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:NAME_0</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:GID_1</span>&gt;</span>CHN.13_1<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:GID_1</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:NAME_1</span>&gt;</span>Hubei<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:NAME_1</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:NL_NAME_1</span>&gt;</span>湖北<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:NL_NAME_1</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:GID_2</span>&gt;</span>CHN.13.2_1<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:GID_2</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:NAME_2</span>&gt;</span>Ezhou by emhui<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:NAME_2</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:VARNAME_2</span>&gt;</span>Èzhōu<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:VARNAME_2</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:NL_NAME_2</span>&gt;</span>鄂州市<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:NL_NAME_2</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:TYPE_2</span>&gt;</span>Dìjíshì<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:TYPE_2</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:ENGTYPE_2</span>&gt;</span>Prefecture City<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:ENGTYPE_2</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:CC_2</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:HASC_2</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">cesium:0</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">wfs:Insert</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">wfs:Transaction</span>&gt;</span><br></code></pre></td></tr></table></figure><p>插入该元素</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">wfs:Transaction</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;2.0.2&quot;</span> <span class="hljs-attr">service</span>=<span class="hljs-string">&quot;WFS&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xmlns:cesium</span>=<span class="hljs-string">&quot;http://geoserver.org/cesium&quot;</span> <span class="hljs-attr">xmlns:wfs</span>=<span class="hljs-string">&quot;http://www.opengis.net/wfs/2.0&quot;</span> <span class="hljs-attr">xmlns:gml</span>=<span class="hljs-string">&quot;http://www.opengis.net/gml/3.2&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="hljs-attr">numberMatched</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">numberReturned</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">timeStamp</span>=<span class="hljs-string">&quot;2020-10-21T05:46:20.854Z&quot;</span> <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.opengis.net/wfs/2.0 http://localhost:8080/geoserver/schemas/wfs/2.0/wfs.xsd http://geoserver.org/cesium http://localhost:8080/geoserver/cesium/wfs?service=WFS<span class="hljs-symbol">&amp;amp;</span>version=2.0.0<span class="hljs-symbol">&amp;amp;</span>request=DescribeFeatureType<span class="hljs-symbol">&amp;amp;</span>typeName=cesium%3A0 http://www.opengis.net/gml/3.2 http://localhost:8080/geoserver/schemas/gml/3.2.1/gml.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">wfs:Insert</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">cesium:0</span> <span class="hljs-attr">gml:id</span>=<span class="hljs-string">&quot;0.102&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:the_geom</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">gml:MultiSurface</span> <span class="hljs-attr">srsName</span>=<span class="hljs-string">&quot;urn:ogc:def:crs:EPSG::4326&quot;</span> <span class="hljs-attr">srsDimension</span>=<span class="hljs-string">&quot;2&quot;</span> <span class="hljs-attr">gml:id</span>=<span class="hljs-string">&quot;0.102.the_geom&quot;</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">gml:surfaceMember</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">gml:Polygon</span> <span class="hljs-attr">gml:id</span>=<span class="hljs-string">&quot;0.102.the_geom.1&quot;</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">gml:exterior</span>&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">gml:LinearRing</span>&gt;</span><br>                                    <span class="hljs-tag">&lt;<span class="hljs-name">gml:posList</span>&gt;</span>52.87590027 125.72106171 52.87631226 125.72225189 52.88783264 125.75554657 52.89224243 125.764328 52.89488983 125.7745285 52.89529037 125.78442383 52.896492 125.81410217 52.89524078 125.83249664 52.89196014 125.83946228 52.88703156 125.84554291 52.87664032 125.84452057 52.87240982 125.84525299 52.86016083 125.84910583 52.8502121 125.85823822 52.84778976 125.86045837 52.83636093 125.87821198 52.83235931 125.88729095 52.82593918 125.8939209 52.80849075 125.91542816 52.79116058 125.92941284 52.7725296 125.95012665 52.76522446 125.96109772 52.76082993 125.96769714 52.76063919 125.98059082 52.76224136 125.98866272 52.76686096 126.0015564 52.77236938 126.00979614 52.77455902 126.01432037 52.77589035 126.01785278 52.78863144 126.03088379 52.79095078 126.03325653 52.79547882 126.04283142 52.79640961 126.04923248 52.79468918 126.05885315 52.78869629 126.0717392 52.78517151 126.07932281 52.77574539 126.09641266 52.7726593 126.10201263 52.76383972 126.11279297 52.75654221 126.10933685 52.74768066 126.09442139 52.74520111 126.08686066 52.74556351 126.07211304 52.74491119 126.06838226 52.74302673 126.05756378 52.74243927 126.04737854 52.73875046 126.04234314 52.73246002 126.04145813 52.71908569 126.04541779 52.71452332 126.04907227 52.70608139 126.05583954 52.69290924 126.06349182 52.69031906 126.06529999 52.67987823 126.0612793 52.67793274 126.06053162 52.67624664 126.05988312 52.67142868 126.05570984 52.67074966 126.05439758 52.66882324 126.0506897 52.66833878 126.04975891 52.66824341 126.0484848 52.66770172 126.04132843 52.66749191 126.03855896 52.6676178 126.03557587 52.66808319 126.0245285 52.67086411 126.00449371 52.66779327 125.99062347 52.66372681 125.97955322 52.65679169 125.97042847 52.647789 125.96539307 52.63829041 125.96382904 52.6240654 125.96531677 52.62253952 125.96547699 52.60788345 125.97412872 52.59682465 125.98561096 52.58967209 125.99310303 52.585289 125.99677277 52.58097076 126.00572205 52.58272171 126.0329361 52.58744049 126.04354095 52.59114838 126.04823303 52.59743881 126.05819702 52.59880066 126.06402588 52.60015869 126.06984711 52.59307861 126.08294678 52.58863068 126.08965302 52.58499146 126.10262299 52.56912994 126.13548279 52.5561409 126.15809631 52.55437469 126.16126251 52.54172516 126.18392944 52.53516006 126.19391632 52.52664948 126.20195007 52.52629089 126.20210266 52.51834869 126.20542145 52.5013504 126.19664764 52.49483871 126.19084167 52.48332977 126.18566132 52.48165894 126.18490601 52.47868347 126.18482971 52.47293091 126.18467712 52.46583176 126.1891098 52.46239853 126.20199585 52.46405411 126.2103653 52.4681015 126.2308197 52.46928406 126.24416351 52.46891403 126.25847626 52.45798874 126.27282715 52.43928146 126.29168701 52.42892075 126.30406189 52.42092514 126.31637573 52.41634369 126.32343292 52.41387939 126.32723236 52.39595032 126.34368134 52.38718033 126.34778595 52.37871933 126.35177612 52.36703873 126.35231781 52.36366653 126.35355377 52.34489059 126.34986877 52.33483124 126.35057068 52.32474899 126.34641266 52.31212997 126.33402252 52.30638123 126.32837677 52.29935074 126.33920288 52.29716873 126.35408783 52.29674911 126.36348724 52.29473877 126.3731308 52.29474258 126.38474274 52.29456711 126.39484406 52.29444122 126.40196228 52.2919693 126.42025757 52.29092026 126.4230957 52.28876114 126.42894745 52.28483963 126.43284607 52.284729 126.43959808 52.27436447 126.4257431 52.27056122 126.41020966 52.26525879 126.38932037 52.25489044 126.34854889 52.25144958 126.34008026 52.24515915 126.32977295 52.23178864 126.31151581 52.2234993 126.30290222 52.22328186 126.30267334 52.21572876 126.29889679 52.21130753 126.29862213 52.20675659 126.29833221 52.20487213 126.30098724 52.19971848 126.3082962 52.19490433 126.31886292 52.18843842 126.33305359 52.1817894 126.36309052 52.18046951 126.38202667 52.17932129 126.39849091 52.17782974 126.40426636 52.17742157 126.40585327 52.17720795 126.40973663 52.17578125 126.43553925 52.17034149 126.45848083 52.16846085 126.46639252 52.15779495 126.49472046 52.15632629 126.49604034 52.15385056 126.4982605 52.1477356 126.51048279 52.14263916 126.52066803 52.13064957 126.54882813 52.13016891 126.54995728 52.12087631 126.55645752 52.10924149 126.55768585 52.10704041 126.55502319 52.10092163 126.54767609 52.09401703 126.54486084 52.07162094 126.53572083 52.06470871 126.53472137 52.05416107 126.52191925 52.04748917 126.51729584 52.03342056 126.51571655 52.02902985 126.50630188 52.028862 126.49443054 52.03126144 126.48229218 52.03084946 126.47454834 52.03079224 126.46118164 52.02825928 126.45262909 52.02186966 126.44481659 52.01605606 126.44325256 52.0060997 126.44558716 52.00541687 126.44574738 51.99919891 126.44716644 51.98892975 126.45504761 51.97336197 126.46427155 51.95381927 126.45921326 51.94272232 126.46186829 51.93531036 126.46920776 51.93198013 126.4756012 51.92747879 126.48677063 51.92549133 126.49170685 51.91908646 126.49756622 51.909729 126.5061264 51.89935684 126.51386261 51.8944397 126.52307129 51.89051056 126.53042603 51.88995743 126.53146362 51.88882828 126.53260803 51.87733078 126.54429626 51.86809921 126.55161285 51.85640335 126.56086731 51.83979034 126.56851959 51.83467102 126.57087708 51.82268143 126.5739975 51.80533981 126.59337616 51.79030991 126.59984589 51.7828598 126.60661316 51.78023148 126.6089859 51.77146149 126.62124634 51.76145935 126.64070892 51.75664139 126.65392303 51.74295044 126.65982056 51.73701859 126.65789795 51.73140335 126.65572357 51.72661209 126.65691376 51.72369003 126.66078949 51.72128677 126.66825104 51.72270966 126.6786499 51.72069168 126.71335602 51.71342087 126.72354889 51.70373535 126.72705078 51.69779968 126.72602844 51.69771957 126.72601318 51.6920929 126.72171021 51.69031906 126.72035217 51.67741394 126.71911621 51.66592789 126.72322083 51.65882111 126.72749329 51.65858078 126.72766876 51.6475296 126.73561096 51.63954926 126.73667145 51.63279724 126.73461914 51.63142776 126.73253632 51.62857056 126.72817993 51.61809921 126.7118988 51.61271667 126.7052536 51.60774994 126.6889801 51.60272598 126.68045044 51.59516144 126.67594147 51.58526993 126.6798172 51.57971954 126.68792725 51.57567978 126.69399261 51.57139969 126.70449066 51.57077026 126.70820618 51.56853104 126.71530914 51.56731796 126.71925354 51.56486893 126.72484589 51.55844116 126.74260712 51.55466843 126.75936127 51.55263901 126.76837158 51.54499054 126.79840851 51.53752899 126.8184967 51.53118134 126.82923889 51.52653885 126.83277893 51.5180397 126.83242035 51.50726318 126.82794189 51.48564529 126.80396271 51.48271179 126.80278778 51.47718048 126.80059052 51.4642334 126.7954483 51.46060181 126.79400635 51.45281219 126.78954315 51.44799042 126.78502655 51.44036484 126.78382111 51.42922592 126.78879547 51.42758179 126.78952789 51.41687012 126.80448914 51.41358948 126.81664276 51.40718079 126.8533783 51.40335846 126.88684082 51.39736176 126.90445709 51.38801193 126.91363525 51.38576889 126.91583252 51.3727951 126.92144775 51.3678093 126.92360687 51.35659409 126.9239502 51.34836578 126.91988373 51.34331131 126.91503143 51.33750916 126.90442657 51.33502197 126.89597321 51.33753967 126.84552002 51.33433914 126.83204651 51.32218933 126.81861877 51.30900192 126.81630707 51.29687119 126.81678772 51.28210068 126.81942749 51.27231979 126.82544708 51.26358414 126.83396912 51.25592041 126.84143829 51.24687958 126.85756683 51.24261856 126.86871338 51.24144745 126.8772583 51.24150848 126.88308716 51.24364853 126.90289307 51.24961853 126.9107666 51.25273132 126.91487885 51.26441956 126.91485596 51.26712418 126.91279602 51.27480698 126.9069519 51.29574966 126.87650299 51.30630112 126.87185669 51.31003952 126.87320709 51.31946945 126.89211273 51.32014465 126.89595032 51.32331085 126.9139328 51.32506943 126.92175293 51.32585144 126.9373703 51.32633209 126.95632935 51.32514954 126.96488953 51.31987762 126.97432709 51.30776978 126.97986603 51.29138947 126.97318268 51.29086685 126.9728241 51.26647949 126.95622253 51.25538254 126.94384766 51.25119019 126.93917084 51.24597931 126.93225098 51.23915863 126.92317963 51.23791504 126.92227936 51.23273087 126.91851807 51.22598267 126.91645813 51.2025032 126.90084839 51.18836594 126.89791107 51.18774033 126.89804077 51.15409088 126.9048233 51.12990952 126.91191101 51.12837982 126.91205597 51.11531067 126.91339874 51.10058975 126.91707611 51.07971954 126.91718292 51.06199265 126.92015839 51.05799866 126.92285156 51.05142975 126.93348694 51.0464592 126.94429779 51.03083801 126.96961212 51.02141953 126.98487091 51.0120697 126.99511719 51.00599289 127.00061798 51.00318146 127.0031662 51.00043869 127.00565338 50.9928894 127.01058197 50.98195648 127.02148438 50.97803497 127.02539825 50.97168732 127.03173065 50.96573257 127.04118347 50.95992279 127.05800629 50.95709991 127.06617737 50.93721008 127.10488892 50.93387222 127.11181641 50.92562866 127.121521 50.90480042 127.14109039 50.89715958 127.14679718 50.82955933 127.19722748 50.81772995 127.20249176 50.8290062 127.1934433 50.84143066 127.18460846 50.8509903 127.17686462 50.86335754 127.16628265 50.87846756 127.1550293 50.89469147 127.14411926 50.90481186 127.1367569 50.91569901 127.12320709 50.92816925 127.10733795 50.9373436 127.09216309 50.94043732 127.08535004 50.94525909 127.07228088 50.95055771 127.05697632 50.95501328 127.04130554 50.95893097 127.0344162 50.96425247 127.02828979 50.97383881 127.01743317 50.97483063 127.01677704 50.9727478 127.01443481 50.96881104 127.0100174 50.96577835 127.00613403 50.96249771 127.00196075 50.96134567 127.00049591 50.95464325 126.99638367 50.95064545 126.99305725 50.94421387 126.98770142 50.93795776 126.98285675 50.93370056 126.97395325 50.92806625 126.96474457 50.92312241 126.95587158 50.91993713 126.94258881 50.92022324 126.93171692 50.91953278 126.91725922 50.91687012 126.89382172 50.91635895 126.87646484 50.91648102 126.86994171 50.91445541 126.84431458 50.91308975 126.83097839 50.91116714 126.81185913 50.91139221 126.7980957 50.91049576 126.78582001 50.90964508 126.76304626 50.91085052 126.75322723 50.91019821 126.72899628 50.91067505 126.71703339 50.91034317 126.68554688 50.90908813 126.66677856 50.90808105 126.64907837 50.90955734 126.62982941 50.90919876 126.61029816 50.90846252 126.5954895 50.90641022 126.58363342 50.90483856 126.57320404 50.90386581 126.55804443 50.90472031 126.5428009 50.90435791 126.53593445 50.90330505 126.51679993 50.90257645 126.50271606 50.90236664 126.49222565 50.9033699 126.48493958 50.90555191 126.47940826 50.90907288 126.47236633 50.91281509 126.46459198 50.91748047 126.45748901 50.92059326 126.4529953 50.92720413 126.44001007 50.93205261 126.4307251 50.93820572 126.41811371 50.9431572 126.40229797 50.94868469 126.39297485 50.95284653 126.38371277 50.95550156 126.37923431 50.95859528 126.3736496 50.96419144 126.36756897 50.96996689 126.35895538 50.97477722 126.34819794 50.97891235 126.33784485 50.97994995 126.3356781 50.97982788 126.33287048 50.98060989 126.32783508 50.98106003 126.32662201 50.98625565 126.31998444 50.99028778 126.31083679 50.99201202 126.29992676 50.99075699 126.28835297 50.98873901 126.26882172 50.99270248 126.25314331 50.99448013 126.24766541 50.99892807 126.2355957 51.00014496 126.22033691 50.99439621 126.21720886 50.9814682 126.20519257 50.97307587 126.18981171 50.96608353 126.1772995 50.9648819 126.1678772 50.96528625 126.16680908 50.96580505 126.15122223 50.96826553 126.14544678 50.96892929 126.14389038 50.96986771 126.1253891 50.96960831 126.12360382 50.95794678 126.12140656 50.95501709 126.12338257 50.95301819 126.12469482 50.95140839 126.12574768 50.94734573 126.12850952 50.94320297 126.12728119 50.93739319 126.12361145 50.93211746 126.11302948 50.9274292 126.09842682 50.92007828 126.08724213 50.91493988 126.07303619 50.91330338 126.0615387 50.91288757 126.05358887 50.91337204 126.0448761 50.91464233 126.0306778 50.91737366 126.01282501 50.92559052 126.01356506 50.92775345 126.01615906 50.93208694 126.02135468 50.93081284 126.02971649 50.92565536 126.0354538 50.92313766 126.03825378 50.92521667 126.03946686 50.92728424 126.0406723 50.93482971 126.04046631 50.94166183 126.03810883 50.94568634 126.04560089 50.94914246 126.05202484 50.95256805 126.05157471 50.95941162 126.0503006 50.9619751 126.05421448 50.95911407 126.06407166 50.95949173 126.0669632 50.95986938 126.06985474 50.96079254 126.07091522 50.96197128 126.07378387 50.96657181 126.07619476 50.96672821 126.0745163 50.96718216 126.06965637 50.96733475 126.06312561 50.97328186 126.06296539 50.97466278 126.06105042 50.97620392 126.05889893 50.97563171 126.04876709 50.97806168 126.04145813 50.9809494 126.04037476 50.98329926 126.03949738 50.9884758 126.04147339 50.98950195 126.04186249 50.99836349 126.03726959 51.00282669 126.02771759 51.00533295 126.02692413 51.00854492 126.02792358 51.01338959 126.03141785 51.01610184 126.02880096 51.02079773 126.03156281 51.02140045 126.03192139 51.02312469 126.04239655 51.02641296 126.03842163 51.02650833 126.03830719 51.03010178 126.03276825 51.0349617 126.0377121 51.03113937 126.04486847 51.0284729 126.04986572 51.03128433 126.0555954 51.03695679 126.05281067 51.03833008 126.05213928 51.04117584 126.04153442 51.04175949 126.03244781 51.04172134 126.02916718 51.04167175 126.02519226 51.04389572 126.01968384 51.04613876 126.02201843 51.04898834 126.02498627 51.05376434 126.02304077 51.05222321 126.00856018 51.05679321 126.0044632 51.06391525 126.01113892 51.06535721 126.00455475 51.06472778 126.00376129 51.0617485 126 51.07627106 125.98672485 51.08142853 125.97301483 51.08511353 125.97464752 51.08472443 125.98296356 51.08680344 125.98679352 51.08995819 125.98358154 51.09184647 125.97545624 51.09569931 125.973526 51.10979843 125.98777008 51.11581421 125.99384308 51.12041473 125.99200439 51.11642838 125.98077393 51.12343979 125.97563934 51.12371826 125.96970367 51.10895157 125.9469986 51.10687256 125.94380188 51.10811615 125.93320465 51.11288071 125.92779541 51.11592865 125.92696381 51.12005234 125.91909027 51.12304688 125.91944122 51.12399292 125.93149567 51.12687302 125.93422699 51.12848282 125.93202972 51.139534 125.90465546 51.13484573 125.89215851 51.13511658 125.88621521 51.13973618 125.87678528 51.14009857 125.87604523 51.13984299 125.86525726 51.14316177 125.85847473 51.14839935 125.85909271 51.1529274 125.87516022 51.15999222 125.86881256 51.16757965 125.86730957 51.17341995 125.85484314 51.18464661 125.8561554 51.20015335 125.8460083 51.20912933 125.84705353 51.21651459 125.83355713 51.22052765 125.82803345 51.22411728 125.81528473 51.22247314 125.78517151 51.22388077 125.76933289 51.2255249 125.75080872 51.22953415 125.7452774 51.24406815 125.75653076 51.25844955 125.75458527 51.2642746 125.74208069 51.27442932 125.73365784 51.27939606 125.72344208 51.28538132 125.72412872 51.29863739 125.71365356 51.30295944 125.70095825 51.31038666 125.70300293 51.33047867 125.69090271 51.33454132 125.68416595 51.33488464 125.68043518 51.33597183 125.66873169 51.34622192 125.65789032 51.34878159 125.65097809 51.3569603 125.65310669 51.3590889 125.6389389 51.37233353 125.6284256 51.38204193 125.61270905 51.38704681 125.61151123 51.38888168 125.61107635 51.39070892 125.61181641 51.39700699 125.61438751 51.39728165 125.61236572 51.39923096 125.59781647 51.41701126 125.58659363 51.42192459 125.57776642 51.43087387 125.56169128 51.43910217 125.56260681 51.44398117 125.57157135 51.45022964 125.56625366 51.45133591 125.55796051 51.45992661 125.55049896 51.46128845 125.53620911 51.48515701 125.52321625 51.49158478 125.5128479 51.49664688 125.50467682 51.51098633 125.48152161 51.51797485 125.47626495 51.53258896 125.45489502 51.54430008 125.4377594 51.55322266 125.42469788 51.55554581 125.42249298 51.56575012 125.41279602 51.57954407 125.38657379 51.58615112 125.37400818 51.59233856 125.37206268 51.59757614 125.37041473 51.60856247 125.36265564 51.61027145 125.3614502 51.61604309 125.35317993 51.62217712 125.34353638 51.61994553 125.33113861 51.61970139 125.33011627 51.6163826 125.31748962 51.61348343 125.31406403 51.6115799 125.31181335 51.60829163 125.30813599 51.61278152 125.29942322 51.63233566 125.28128052 51.63581848 125.2746582 51.6350975 125.26425934 51.63000107 125.26003265 51.62871933 125.25215912 51.6360054 125.23300171 51.6371994 125.2298584 51.63894272 125.22083282 51.63664246 125.21543121 51.62950134 125.21060944 51.62907791 125.2101059 51.62643814 125.20697021 51.63657379 125.1717453 51.63764954 125.1680069 51.63730621 125.15950012 51.63521576 125.15448761 51.63389969 125.14646149 51.63282013 125.13986969 51.63241196 125.12730408 51.6372261 125.12154388 51.64611435 125.12284088 51.65122223 125.12117004 51.65721893 125.12032318 51.65872955 125.11434174 51.65912247 125.11277771 51.65959167 125.10103607 51.65655899 125.09076691 51.64537811 125.08370972 51.63869095 125.07896423 51.63430023 125.07408905 51.63167572 125.07086945 51.62865448 125.06613922 51.62277603 125.0640564 51.61386108 125.06349945 51.60992432 125.05867767 51.60387421 125.05510712 51.59869385 125.05272675 51.59505844 125.05198669 51.57658768 125.06111908 51.56917953 125.06293488 51.56382751 125.06495667 51.56013489 125.06567383 51.55168533 125.06480408 51.53707886 125.05152893 51.53335953 125.04710388 51.52792358 125.03956604 51.52719498 125.03249359 51.52692795 125.02990723 51.52540588 125.01615143 51.52738571 125.00106812 51.52769089 124.99874878 51.52355576 124.99317932 51.52145767 124.9881897 51.51473618 124.98420715 51.50981522 124.98088837 51.50959778 124.98074341 51.50680161 124.97605133 51.50614929 124.96964264 51.50597 124.96788788 51.50311279 124.94702911 51.50080872 124.93540955 51.49910736 124.92606354 51.49633408 124.92063904 51.49072647 124.91751099 51.48337173 124.9178772 51.48034668 124.91316986 51.4784584 124.90857697 51.47289276 124.91022491 51.47034454 124.91693878 51.46819687 124.92576599 51.46816635 124.92589569 51.46783447 124.92612457 51.4625206 124.92974091 51.45624161 124.93204498 51.44682693 124.93482208 51.44603729 124.93505859 51.44087219 124.9323349 51.43622971 124.92784119 51.43576431 124.92681122 51.43242645 124.91938782 51.43136978 124.91121674 51.42896271 124.9021759 51.42349243 124.895401 51.4164505 124.88773346 51.41140747 124.88173676 51.40612411 124.87608337 51.40018845 124.87549591 51.39483261 124.87753296 51.3870163 124.87779999 51.38656998 124.87781525 51.38610077 124.87696838 51.38185501 124.86928558 51.3789978 124.85987091 51.37818909 124.85720825 51.37857437 124.84698486 51.37985229 124.84172058 51.38074875 124.83804321 51.38352966 124.82512665 51.38742447 124.80682373 51.38769913 124.80357361 51.38831329 124.80194855 51.38784409 124.80185699 51.38825226 124.79701233 51.38916016 124.78501129 51.38981247 124.78104401 51.39064407 124.77600098 51.38854218 124.76480865 51.38343811 124.75405884 51.37872696 124.75141144 51.37371445 124.75055695 51.36507797 124.74863434 51.36257935 124.74781799 51.35873413 124.74655914 51.3554039 124.74367523 51.35071945 124.73406982 51.34473801 124.72216034 51.34182358 124.71419525 51.33924484 124.70955658 51.33768082 124.70314026 51.33705139 124.70056152 51.33161926 124.6861496 51.33226395 124.66864777 51.33401871 124.65820313 51.33438873 124.647995 51.33335876 124.63838196 51.32852173 124.63280487 51.32537079 124.62483215 51.32724762 124.61732483 51.33467102 124.60850525 51.33944702 124.60309601 51.34399796 124.59766388 51.34804916 124.59327698 51.35533905 124.58809662 51.36227417 124.57995605 51.36889648 124.56774902 51.37078476 124.55987549 51.3739357 124.54844666 51.37194443 124.53361511 51.37291336 124.51905823 51.37762833 124.50887299 51.37839127 124.50015259 51.37979889 124.49259186 51.37877274 124.48261261 51.36436844 124.4750824 51.36063766 124.4703598 51.35946655 124.46387482 51.35929108 124.46291351 51.3590889 124.44898987 51.35633087 124.43592834 51.35197449 124.42932129 51.34415436 124.42350006 51.33600235 124.420578 51.33010483 124.41896057 51.32408905 124.42061615 51.3063736 124.42269897 51.3022728 124.42196655 51.29950714 124.42245483 51.29280853 124.41506195 51.29265976 124.41490173 51.28971863 124.41390991 51.28095627 124.40882874 51.27780914 124.40700531 51.27030563 124.39867401 51.26983261 124.39241791 51.27410126 124.38146973 51.27765656 124.35767365 51.27022552 124.34021759 51.27499008 124.33478546 51.27985382 124.33338165 51.28414917 124.33258057 51.28654099 124.33213806 51.29181671 124.3318634 51.29057312 124.32810211 51.28995895 124.32520294 51.28938675 124.3225174 51.28757477 124.31505585 51.28793716 124.30412292 51.29032516 124.30200195 51.29431534 124.29846191 51.29589081 124.29238129 51.30002975 124.28316498 51.30331802 124.27584076 51.30668259 124.2640686 51.3107872 124.26478577 51.31754303 124.26134491 51.32339859 124.25745392 51.32703018 124.25154877 51.33491135 124.24177551 51.34303665 124.23169708 51.34580231 124.22425079 51.34638214 124.2226181 51.34776688 124.21871185 51.34832382 124.2171402 51.3483696 124.21578979 51.34854889 124.21021271 51.34716797 124.20350647 51.34243393 124.1939621 51.33694077 124.17960358 51.3387146 124.16731262 51.34146118 124.16022491 51.3441658 124.15460205 51.34147263 124.14559937 51.33802032 124.1317749 51.34180832 124.12831116 51.34462738 124.12574005 51.34571838 124.12034607 51.34415436 124.11342621 51.34310913 124.10878754 51.34246826 124.0999527 51.34113312 124.09143066 51.33958435 124.08252716 51.33288193 124.07722473 51.32447052 124.07508087 51.31908798 124.06403351 51.3191452 124.05490112 51.31951904 124.03555298 51.32150269 124.01596832 51.32133865 123.99707031 51.32125092 123.98706818 51.3199234 123.97818756 51.31649017 123.96292877 51.3146553 123.94815826 51.31168747 123.93257904 51.30643463 123.92449188 51.30298996 123.92176056 51.29927444 123.91881561 51.30457687 123.91009521 51.31143951 123.89527893 51.31798935 123.88298798 51.32297516 123.87715912 51.33005142 123.87039948 51.33431625 123.86560822 51.34205246 123.85982513 51.34274673 123.85930634 51.35495758 123.84927368 51.3592453 123.84375 51.36613846 123.83512878 51.36730194 123.82679749 51.36727524 123.81984711 51.36339951 123.81150055 51.36107635 123.80474091 51.35974121 123.79549408 51.35975266 123.78986359 51.35976028 123.78707886 51.36007309 123.78627014 51.36347198 123.77748108 51.36620712 123.77000427 51.3670845 123.76662445 51.36956024 123.75708008 51.37265778 123.74953461 51.37349701 123.74749756 51.37965012 123.7406311 51.38448334 123.73184204 51.39038086 123.72569275 51.39052963 123.72550201 51.39560699 123.71912384 51.39767838 123.71086121 51.39673996 123.70346832 51.39359283 123.70140076 51.39213562 123.70023346 51.3895607 123.69817352 51.3842392 123.69192505 51.38023758 123.68760681 51.37736893 123.68373871 51.37250519 123.67752838 51.36679459 123.67710876 51.35670853 123.67746735 51.35017014 123.67369843 51.34738159 123.66691589 51.34588623 123.66007233 51.34535217 123.65762329 51.34135818 123.65294647 51.33587265 123.65254974 51.32686615 123.65451813 51.32458115 123.65502167 51.31772614 123.65452576 51.31805801 123.64248657 51.31849289 123.63520813 51.31561661 123.62368774 51.31189728 123.60877991 51.31171799 123.59854126 51.31060791 123.58895874 51.30804062 123.5821991 51.3054924 123.57507324 51.3006897 123.57473755 51.29920578 123.57485199 51.29334641 123.57530975 51.29159546 123.57226563 51.28894424 123.56038666 51.28736115 123.55114746 51.28713989 123.54527283 51.2869606 123.54052734 51.28658295 123.53759003 51.28601456 123.53315735 51.28585434 123.52974701 51.28543472 123.52069855 51.28577805 123.5079422 51.28909683 123.49502563 51.29019165 123.47975922 51.2880249 123.46646118 51.28511047 123.45530701 51.27881622 123.45085907 51.27270126 123.44824982 51.27068329 123.44332123 51.27054596 123.44299316 51.26922226 123.43231964 51.27032852 123.42508698 51.27243042 123.41464233 51.27699661 123.40655518 51.27600861 123.39916229 51.27487946 123.39071655 51.27349091 123.38787842 51.2687912 123.37825775 51.26531982 123.37072754 51.26555634 123.36161804 51.26853561 123.35232544 51.27077103 123.34553528 51.27088547 123.33203125 51.268013 123.3187027 51.26488495 123.31066895 51.2634964 123.30709839 51.25801849 123.29724884 51.25429535 123.29044342 51.25106812 123.2853775 51.24944687 123.28282928 51.250103 123.27484894 51.25091171 123.27196503 51.25361633 123.26229858 51.25709534 123.25120544 51.25798416 123.24832916 51.26008224 123.24154663 51.26398468 123.23194122 51.26715088 123.22411346 51.27150726 123.22200012 51.27248001 123.2215271 51.27768326 123.2240448 51.27985764 123.21943665 51.28114319 123.21367645 51.28162766 123.20311737 51.28029251 123.19208527 51.28284836 123.18092346 51.28562164 123.17050934 51.28624725 123.16897583 51.28999329 123.15982056 51.29083252 123.15912628 51.29666138 123.15433502 51.29925156 123.14615631 51.2977562 123.13181305 51.29723358 123.12797546 51.29619598 123.12039948 51.29944992 123.11438751 51.30002213 123.11332703 51.30592728 123.10565186 51.30869675 123.09486389 51.30963898 123.08396149 51.31406021 123.07107544 51.31930542 123.06188965 51.32022476 123.05171204 51.31822968 123.0388031 51.31509018 123.02583313 51.31254578 123.01691437 51.30841446 123.00717163 51.31021881 122.99814606 51.31145096 122.99420166 51.31851196 122.98583984 51.32096481 122.98282623 51.32675171 122.97572327 51.33358383 122.96698761 51.34031677 122.9626236 51.34451294 122.95921326 51.35353088 122.95534515 51.36021805 122.95317078 51.36510468 122.95345306 51.36616135 122.9535141 51.37297058 122.95610046 51.38047791 122.95836639 51.38550186 122.95902252 51.39290619 122.95542145 51.39743805 122.94726563 51.40378571 122.9395752 51.40607071 122.92945862 51.40798569 122.92102051 51.40885544 122.91717529 51.40924072 122.90987396 51.41050339 122.90445709 51.41526413 122.89593506 51.41875076 122.89356995 51.42612076 122.89142609 51.43067169 122.89277649 51.43795776 122.89465332 51.44208145 122.89387512 51.44393539 122.89352417 51.4475441 122.88530731 51.44814682 122.88214111 51.45037842 122.87044525 51.45372009 122.86403656 51.46290588 122.86271667 51.46731949 122.85966492 51.47043228 122.85324097 51.47515869 122.84875488 51.47627258 122.84770203 51.47875595 122.8493042 51.48246002 122.85830688 51.48471069 122.85990143 51.49074554 122.86683655 51.49523544 122.87112427 51.49839783 122.8731308 51.50197601 122.8769989 51.50515366 122.87657166 51.50771713 122.8762207 51.51173782 122.87021637 51.51302719 122.86727905 51.51582336 122.86090088 51.5233345 122.85214996 51.52787781 122.85386658 51.53168106 122.85811615 51.5322876 122.86182404 51.53614426 122.87272644 51.53639221 122.87342834 51.5410881 122.87846375 51.54776764 122.87664032 51.55472565 122.87225342 51.55987549 122.86703491 51.56376648 122.86004639 51.56820679 122.8520813 51.57373428 122.83953094 51.57776642 122.8327713 51.58364868 122.82501221 51.58864212 122.82712555 51.59399796 122.83367157 51.60044479 122.84284973 51.60283279 122.84602356 51.60534668 122.84937286 51.61069489 122.84525299 51.61907959 122.83837128 51.62260056 122.83415222 51.62334061 122.83242798 51.62861633 122.82013702 51.63172531 122.81369019 51.6386528 122.8107605 51.64618301 122.81191254 51.65379333 122.809021 51.66209412 122.80256653 51.66263962 122.80213928 51.67008972 122.79592896 51.67329025 122.79286194 51.67919159 122.78721619 51.68478775 122.78237152 51.6908493 122.77680206 51.69667053 122.77196503 51.70248032 122.76786041 51.71144104 122.76613617 51.7190094 122.76543427 51.72546768 122.76284027 51.73180389 122.75881195 51.73242188 122.75842285 51.73802567 122.75283051 51.73905945 122.75041962 51.74235153 122.74273682 51.74599457 122.7436676 51.75095749 122.74725342 51.75544357 122.7515564 51.75746918 122.75350189 51.76532364 122.76130676 51.77122116 122.76383209 51.77806473 122.76494598 51.78014374 122.76340485 51.78317642 122.7611618 51.78918076 122.75852966 51.79423141 122.75769806 51.80187607 122.75331116 51.80680084 122.74729919 51.81257248 122.74465942 51.81744385 122.74159241 51.82304764 122.73599243 51.83221436 122.72528076 51.83837891 122.724617 51.84194183 122.72647095 51.84472275 122.7279129 51.85319519 122.72762299 51.85943222 122.72463226 51.86773682 122.72137451 51.87671661 122.71852875 51.88193893 122.7113266 51.88521194 122.70567322 51.88697815 122.70246124 51.88877106 122.69920349 51.89356232 122.70029449 51.89719772 122.7011261 51.90602112 122.70639801 51.91224289 122.71560669 51.91601944 122.72135925 51.92169189 122.72388458 51.92557907 122.72409058 51.93178177 122.72294617 51.94072342 122.71842194 51.94171906 122.7179184 51.94192886 122.71794128 51.94765472 122.71860504 51.95448685 122.72045135 51.96156311 122.72119904 51.96659088 122.72146606 51.97074509 122.719841 51.9773941 122.71907806 51.97880936 122.70544434 51.9787941 122.70536804 51.97529602 122.68598938 51.97318649 122.67699432 51.97880936 122.67024231 51.98372269 122.66457367 51.98647308 122.66434479 51.9906044 122.66381836 51.99547577 122.66036987 52 122.65620422 52.00377274 122.65630341 52.01563644 122.65661621 52.02223969 122.65458679 52.03017807 122.64881897 52.03607941 122.64532471 52.05776596 122.64362335 52.06200409 122.63424683 52.06246185 122.62804413 52.06280136 122.62347412 52.06570816 122.61746979 52.06813431 122.61857605 52.08637619 122.62689972 52.08723831 122.62723541 52.09348679 122.62966919 52.09685898 122.63158417 52.10222244 122.63462067 52.10818863 122.63705444 52.11804581 122.63014984 52.12132645 122.62786102 52.12860107 122.62276459 52.13523483 122.62368774 52.13673782 122.63589478 52.13674927 122.63633728 52.13710785 122.64924622 52.13875961 122.67823792 52.13907242 122.68371582 52.14299011 122.68732452 52.14496231 122.70100403 52.14771652 122.71562958 52.14858246 122.72021484 52.15211868 122.730896 52.15670776 122.7326355 52.15761948 122.73297882 52.16085434 122.73590088 52.1652298 122.73984528 52.16667557 122.74314117 52.1699028 122.75049591 52.17710495 122.76294708 52.19541931 122.7665863 52.19720078 122.76646423 52.20409775 122.76599884 52.20934296 122.76550293 52.21777725 122.76306152 52.22686005 122.75725555 52.23122025 122.75901031 52.23847961 122.77996826 52.2385025 122.78003693 52.24378586 122.78288269 52.24982834 122.78064728 52.25130081 122.78009796 52.25352859 122.77445984 52.25554657 122.77031708 52.26094437 122.76125336 52.26546097 122.75592804 52.26495361 122.75073242 52.25885773 122.73487854 52.25737 122.7230072 52.25611496 122.71187592 52.25489044 122.70371246 52.2602272 122.68906403 52.26914215 122.6895752 52.27535629 122.67190552 52.27552032 122.64434814 52.27249527 122.63884735 52.27082825 122.63293457 52.26926422 122.6151123 52.26820374 122.60136414 52.26529312 122.58618164 52.2652092 122.57911682 52.28137589 122.55369568 52.28374863 122.54133606 52.28527069 122.53459167 52.28672791 122.52262115 52.28715134 122.50026703 52.29067993 122.48973083 52.2947998 122.47097778 52.29953003 122.46560669 52.30251312 122.46662903 52.31331253 122.47151184 52.317173 122.4695282 52.32353973 122.46708679 52.32860947 122.47028351 52.33526993 122.47342682 52.34011841 122.477005 52.34648895 122.47494507 52.35300827 122.46615601 52.36201859 122.45542908 52.3697319 122.45070648 52.37929535 122.44815826 52.38611221 122.44495392 52.39244843 122.43989563 52.39212418 122.43243408 52.37988663 122.42201233 52.3726387 122.40918732 52.37618637 122.40048218 52.38412857 122.39611816 52.39113617 122.39028168 52.39320755 122.37341309 52.39657974 122.3691864 52.40702057 122.36398315 52.41222 122.35969543 52.40995026 122.34333801 52.41145706 122.33618927 52.41644669 122.33339691 52.42739105 122.33152008 52.43345642 122.32383728 52.43984222 122.32286835 52.44417191 122.32196808 52.45807266 122.31886292 52.46755219 122.30992889 52.47386169 122.30334473 52.47622681 122.29241943 52.47534561 122.27823639 52.47029877 122.26008606 52.46966171 122.24739075 52.46944046 122.23168945 52.47046661 122.22341919 52.46785355 122.20069885 52.47492218 122.18397522 52.48261261 122.17807007 52.48640442 122.17193604 52.49411011 122.16751862 52.51208496 122.16195679 52.51341248 122.15891266 52.51352692 122.15142059 52.51127243 122.13802338 52.50729752 122.13219452 52.5009346 122.13468933 52.49339676 122.13498688 52.48500061 122.12371826 52.47452927 122.12637329 52.47050476 122.11717987 52.46580505 122.10876465 52.45683289 122.10501099 52.45104218 122.1000061 52.44258118 122.08464813 52.43874359 122.07321167 52.43172836 122.0776062 52.42565536 122.08383942 52.41933823 122.07437897 52.41397476 122.05292511 52.41160583 122.03322601 52.40206146 122.03661346 52.39343643 122.04032898 52.37610245 122.02835846 52.37000275 122.0185318 52.36644745 122.01047516 52.36427689 122.00347137 52.34928894 121.98134613 52.34550095 121.97330475 52.34246826 121.96970367 52.33601379 121.96625519 52.32611847 121.96220398 52.32320023 121.95152283 52.3195076 121.94944763 52.31607056 121.94884491 52.31079102 121.94758606 52.30413437 121.9460144 52.29719162 121.94072723 52.28450394 121.92004395 52.28109741 121.90790558 52.28031158 121.90198517 52.2794838 121.89382172 52.28013611 121.87852478 52.28320694 121.8578949 52.28259277 121.84898376 52.28141785 121.83413696 52.28245544 121.82813263 52.28511047 121.82316589 52.2949791 121.79998016 52.29912949 121.78935242 52.3014946 121.78104401 52.30470657 121.76895905 52.30686569 121.76215363 52.3105011 121.74855804 52.31122208 121.73809052 52.31462097 121.71183014 52.31681442 121.70687103 52.32000351 121.7063446 52.32825851 121.70780182 52.34175491 121.70825958 52.35145569 121.7014389 52.35480499 121.69717407 52.35857773 121.69139099 52.36670685 121.68613434 52.37652969 121.67369843 52.38296509 121.6636734 52.38913727 121.65141296 52.39790726 121.65582275 52.41854858 121.67160034 52.420578 121.6700058 52.4260788 121.65888977 52.43202209 121.64700317 52.43743896 121.64336395 52.44127655 121.64092255 52.4431839 121.63298035 52.44163513 121.61212158 52.44039917 121.59573364 52.44198227 121.58330536 52.44508362 121.57828522 52.45200729 121.57006836 52.45908356 121.55810547 52.46002579 121.54795837 52.45695877 121.53203583 52.45304108 121.51914978 52.45540237 121.51154327 52.47140503 121.50057983 52.47831345 121.49197388 52.48141861 121.47608948 52.4817276 121.46896362 52.48815155 121.45887756 52.49555206 121.4303894 52.49942017 121.41856384 52.50108719 121.41098022 52.50522614 121.40139008 52.5227356 121.39702606 52.5251236 121.39089966 52.52794266 121.38399506 52.52833176 121.37010956 52.5273056 121.35443115 52.53381348 121.34880829 52.54822922 121.32848358 52.55691528 121.31785583 52.56469727 121.31815338 52.56943893 121.31562805 52.58124161 121.28079224 52.5825882 121.26946259 52.58137512 121.25602722 52.57913208 121.24790955 52.57759476 121.2405014 52.57542419 121.22562408 52.57429886 121.21631622 52.57751846 121.20711517 52.58719254 121.19039154 52.59436798 121.18431854 52.6023407 121.19284058 52.61600876 121.22053528 52.62124252 121.22960663 52.62863159 121.23254395 52.63394165 121.24498749 52.63703537 121.26058197 52.64124298 121.27497864 52.64737701 121.28326416 52.65605927 121.2831192 52.66143036 121.28806305 52.67110062 121.3119278 52.67564392 121.32106018 52.67958069 121.33361816 52.67853546 121.33818817 52.68067169 121.36288452 52.68286133 121.36914825 52.68738174 121.37716675 52.69363022 121.3809433 52.70005417 121.39261627 52.71429062 121.41702271 52.72293091 121.42556763 52.72872925 121.44067383 52.74807739 121.45842743 52.75805283 121.46540833 52.7651329 121.46501923 52.76938248 121.47156525 52.77290726 121.47627258 52.77653885 121.49716949 52.77851868 121.50460052 52.78294754 121.50888062 52.79135895 121.51785278 52.79555893 121.52214813 52.8102417 121.54737854 52.81600189 121.56102753 52.81802368 121.57110596 52.82241821 121.57350922 52.83471298 121.59437561 52.84121704 121.5996933 52.8468132 121.60506439 52.85200119 121.61347198 52.86354828 121.60758972 52.86753082 121.60058594 52.87271118 121.5969162 52.87802505 121.59966278 52.88241577 121.60207367 52.88605118 121.60075378 52.88991165 121.59941864 52.89271545 121.60266876 52.89448166 121.62298584 52.89869308 121.62805939 52.90638733 121.63597107 52.90821838 121.64797974 52.91521835 121.65555573 52.9217453 121.66203308 52.93283844 121.66864777 52.93903732 121.66985321 52.94658661 121.67022705 52.94961166 121.6730957 52.95449448 121.67739105 52.96125412 121.68424225 52.96795654 121.68806458 52.97607422 121.69447327 52.98235321 121.7002182 52.98830795 121.70067596 52.99271393 121.70424652 52.9964447 121.70822144 52.99886322 121.71529388 53.00113297 121.72692871 53.00292587 121.73744965 53.00701523 121.74861145 53.01152802 121.75786591 53.01898575 121.77871704 53.02705383 121.78249359 53.03258896 121.78526306 53.04154205 121.78749084 53.04892731 121.79130554 53.05334854 121.79564667 53.05900955 121.80561829 53.06410599 121.80916595 53.07141876 121.79629517 53.07641602 121.7816391 53.08210754 121.78022766 53.09283447 121.76642609 53.10255051 121.772789 53.10823441 121.77098846 53.11434555 121.76765442 53.12070465 121.76544952 53.14125443 121.75115204 53.14728546 121.74325562 53.14403152 121.72782898 53.14403915 121.71566772 53.1573143 121.69181824 53.15982437 121.67914581 53.16305161 121.66833496 53.16819382 121.66236877 53.1804657 121.64614105 53.18638992 121.64508057 53.19430923 121.65303802 53.19711685 121.66849518 53.20461655 121.66621399 53.21922302 121.66470337 53.22732925 121.67038727 53.23693466 121.6706543 53.24071884 121.66513062 53.24679565 121.65986633 53.2592392 121.62874603 53.25549698 121.61254883 53.26008606 121.60125732 53.26659775 121.59519958 53.2808609 121.57614136 53.28640747 121.56745911 53.29027939 121.55504608 53.29430008 121.55025482 53.30279922 121.54064178 53.30764771 121.53160095 53.31093216 121.51272583 53.31388855 121.50035095 53.32069397 121.49768829 53.33117294 121.48937988 53.33171082 121.4916153 53.33651733 121.51165771 53.34218597 121.5328598 53.34404373 121.54516602 53.34518814 121.55725861 53.34834671 121.5776062 53.35329056 121.59860992 53.35608673 121.60636902 53.36282349 121.62303925 53.36841583 121.63904572 53.37254333 121.65176392 53.37667084 121.66448212 53.3829155 121.67571259 53.38708496 121.68605804 53.38842392 121.69149017 53.38851166 121.69239044 53.38658905 121.70263672 53.38446808 121.71477509 53.38409042 121.71692657 53.38557434 121.72969818 53.38652039 121.73781586 53.38963318 121.74781036 53.39178085 121.75470734 53.39884949 121.77041626 53.40736008 121.79219818 53.41492081 121.81532288 53.41559219 121.83596039 53.41947556 121.84533691 53.42313385 121.85909271 53.42275238 121.8663559 53.42190552 121.88240051 53.42162704 121.90441895 53.42597961 121.9211731 53.4287796 121.95095062 53.42958069 121.96868896 53.42782211 121.9803009 53.42742157 121.98294067 53.42414093 122.00457764 53.41909027 122.03315735 53.42060089 122.04703522 53.42110443 122.05168152 53.42201233 122.06004333 53.42113876 122.07605743 53.42776871 122.09909821 53.43735123 122.10041809 53.45944214 122.1251297 53.46541595 122.13204193 53.46744919 122.13835144 53.46937943 122.14663696 53.46962357 122.15667725 53.46918106 122.16464996 53.46903992 122.16723633 53.46683884 122.17822266 53.46457291 122.19052124 53.46229935 122.20281982 53.46123886 122.21465302 53.46129608 122.2154007 53.46216202 122.22677612 53.46385956 122.23902893 53.46863556 122.25311279 53.47373962 122.2612381 53.48388672 122.27883148 53.4958992 122.30539703 53.49818039 122.31442261 53.49834061 122.31556702 53.49842072 122.31632233 53.49848938 122.31707001 53.49853897 122.31781769 53.49858093 122.318573 53.49860001 122.31933594 53.49861145 122.32009125 53.49860001 122.32084656 53.49858093 122.32160187 53.49853897 122.32235718 53.49848175 122.32311249 53.49840927 122.32386017 53.49832916 122.32460785 53.49822998 122.32534027 53.49811172 122.32608032 53.49798203 122.32681274 53.49784851 122.32752228 53.4977951 122.32774353 53.49768066 122.32823181 53.497509 122.32892609 53.49732208 122.32962036 53.49195862 122.34010315 53.4871788 122.34732819 53.48414993 122.35186005 53.47637939 122.36160278 53.45452881 122.38260651 53.4446106 122.40040588 53.44166183 122.41371155 53.44141006 122.43136597 53.44181061 122.44115448 53.44184875 122.44212341 53.44481659 122.45142365 53.44935226 122.46391296 53.4500885 122.46620941 53.45233154 122.47322083 53.45617294 122.48267365 53.45588684 122.48757172 53.45558167 122.49285889 53.45473862 122.5074234 53.453022 122.52184296 53.45308304 122.5224762 53.45627975 122.55619049 53.45755768 122.56991577 53.46058655 122.60249329 53.46113586 122.61339569 53.46260834 122.64251709 53.45979309 122.66596985 53.45914459 122.6713562 53.45809937 122.68884277 53.46032333 122.71142578 53.46192932 122.72770691 53.46170425 122.7387085 53.46147919 122.74970245 53.45867538 122.79628754 53.45854568 122.79699707 53.45605469 122.81054688 53.45290375 122.83354187 53.45600891 122.85466766 53.45933533 122.87052917 53.46144867 122.8806076 53.46646118 122.89911652 53.47536087 122.92568207 53.48159409 122.9385376 53.48203659 122.94114685 53.48545074 122.96128845 53.48958969 122.97968292 53.49332047 122.98817444 53.49477768 122.99149323 53.50064468 123.00060272 53.50743103 123.02068329 53.5112114 123.03752899 53.51126099 123.04968262 53.50770187 123.06793976 53.50759506 123.06851959 53.50483322 123.08338165 53.50284958 123.09406281 53.50025177 123.10977936 53.5002861 123.12193298 53.50144577 123.12778473 53.50333023 123.13730621 53.50814056 123.1503067 53.5166893 123.16532135 53.51755142 123.1668396 53.52817154 123.17684174 53.54323196 123.19304657 53.55138016 123.2039566 53.55459213 123.21669769 53.55770874 123.2307663 53.56003952 123.24471283 53.56085968 123.25701904 53.55974197 123.27437592 53.55833435 123.27954102 53.55764008 123.28209686 53.55183029 123.29724884 53.54699707 123.30988312 53.54261017 123.32798004 53.54111862 123.33851624 53.53660965 123.35941315 53.53268051 123.37932587 53.53144073 123.39827728 53.53128433 123.42499542 53.53126907 123.42772675 53.53031158 123.44230652 53.52548981 123.44876862 53.51633453 123.45445251 53.50650024 123.45704651 53.49811172 123.46433258 53.49570084 123.47419739 53.49661255 123.48318481 53.49676514 123.48471069 53.50331879 123.49182892 53.50881958 123.48842621 53.51644135 123.47953033 53.52202988 123.47467804 53.52820206 123.47434998 53.53601074 123.47580719 53.54536057 123.4805069 53.55096054 123.48892975 53.552742 123.49917603 53.554142 123.50723267 53.55404282 123.50871277 53.55316925 123.52179718 53.55210495 123.52354431 53.54430008 123.53636932 53.53707123 123.53942871 53.5309906 123.53829193 53.51460266 123.52046967 53.50881958 123.51496124 53.50101089 123.5134964 53.4958992 123.52433777 53.4944458 123.53291321 53.49594498 123.53606415 53.49983978 123.54424286 53.50437164 123.55539703 53.50918961 123.56220245 53.51671219 123.56804657 53.52442169 123.57097626 53.53348923 123.56678772 53.54043198 123.56809235 53.54233551 123.56957245 53.54544067 123.57199097 53.54756165 123.57977295 53.54716873 123.58558655 53.54636765 123.5881424 53.53710938 123.61763 53.53033829 123.63993835 53.52618027 123.64948273 53.51787949 123.65526581 53.5078392 123.66072845 53.49587631 123.66876221 53.48926163 123.67782593 53.49303055 123.69338989 53.49368286 123.69687653 53.49539185 123.70598602 53.49736023 123.71852112 53.49729919 123.72525787 53.49666977 123.73458862 53.49638367 123.73612976 53.49473953 123.74501801 53.49082565 123.76113892 53.48797226 123.77340698 53.4860611 123.78383636 53.48590851 123.79190826 53.48611832 123.79374695 53.4874115 123.80502319 53.48835754 123.81465149 53.48854065 123.8295517 53.48871994 123.84442139 53.48677826 123.85168457 53.48546219 123.85661316 53.4797287 123.86966705 53.47026062 123.89008331 53.46088028 123.9091568 53.45399094 123.9213028 53.44911194 123.92775726 53.44721985 123.93750763 53.44068146 123.95038605 53.43400192 123.96526337 53.42809296 123.97486877 53.4214325 123.9836731 53.41110229 124 53.4100914 124.00113678 53.40883636 124.00254059 53.39640045 124.01850891 53.39157486 124.03140259 53.39157486 124.03172302 53.39172363 124.06253052 53.38573837 124.07234192 53.3780632 124.08190918 53.36703873 124.09564972 53.36292648 124.09648895 53.3555603 124.09799194 53.3499794 124.10416412 53.34791946 124.10644531 53.34746933 124.10694122 53.34368134 124.11501312 53.34395218 124.11872864 53.34498978 124.13301086 53.34697342 124.14213562 53.34828186 124.14816284 53.35659027 124.162323 53.36458588 124.19235992 53.36795044 124.20871735 53.36809921 124.2208786 53.36550903 124.24575043 53.34767532 124.27121735 53.34381866 124.27750397 53.32810211 124.30310822 53.32522964 124.30797577 53.31835938 124.31962585 53.30099869 124.33158875 53.29381943 124.33300781 53.28723526 124.34023285 53.28705978 124.34042358 53.2816391 124.34571838 53.27301788 124.35519409 53.27156067 124.35679626 53.26771927 124.36100006 53.26529694 124.36116791 53.26153946 124.36141968 53.25342941 124.36720276 53.24618149 124.37548828 53.24123001 124.39711761 53.23981094 124.40660095 53.23441315 124.41726685 53.23251724 124.42101288 53.22950363 124.42311859 53.21815872 124.43105316 53.21672058 124.43206024 53.20864868 124.45197296 53.20743942 124.4572525 53.20050049 124.48757172 53.19688034 124.51541901 53.19488907 124.53032684 53.19607162 124.55459595 53.20063019 124.5916214 53.19974136 124.62853241 53.19947052 124.63965607 53.20096207 124.6481781 53.19919205 124.66304016 53.19225311 124.69127655 53.18904877 124.70430756 53.1815033 124.71526337 53.17921829 124.71598816 53.1758728 124.71705627 53.15644836 124.715271 53.15433121 124.71795654 53.15097046 124.72098541 53.14955902 124.72225952 53.14122009 124.74213409 53.13861847 124.74833679 53.13441467 124.77507782 53.13550949 124.80581665 53.13809204 124.81266785 53.13269043 124.83304596 53.12458801 124.84287262 53.12417221 124.84337616 53.10868073 124.8543396 53.10462189 124.85720825 53.098629 124.86400604 53.09429169 124.87509155 53.0951004 124.88754272 53.09767914 124.89546967 53.10647202 124.89998627 53.116436 124.90126038 53.13264084 124.89605713 53.13740921 124.89290619 53.14850998 124.88556671 53.15481949 124.88368225 53.16117096 124.88941193 53.16376114 124.89391327 53.1737709 124.91734314 53.179245 124.94020081 53.18193054 124.95141602 53.18925095 124.97189331 53.19285202 124.98197174 53.19417953 125 53.19617081 125.02688599 53.19567108 125.04830933 53.19543076 125.05873871 53.19496155 125.09513092 53.19739914 125.12298584 53.195858 125.14312744 53.19499969 125.15437317 53.19158936 125.18820953 53.18939209 125.20082092 53.18619156 125.21041107 53.18335724 125.21891022 53.1832428 125.21925354 53.17911911 125.23162842 53.158535 125.27539063 53.14844894 125.29682922 53.14422989 125.31009674 53.14267349 125.31498718 53.1385231 125.3259964 53.13660431 125.34731293 53.13001633 125.36522675 53.12852478 125.36927795 53.12382507 125.38646698 53.12279129 125.394104 53.12049103 125.41105652 53.11325073 125.42758179 53.10512924 125.44603729 53.10109329 125.46273041 53.10079956 125.46325684 53.09590149 125.47203827 53.09030914 125.48206329 53.07427216 125.49223328 53.07328033 125.49286652 53.05847931 125.49494171 53.0496788 125.5013504 53.04771805 125.50556946 53.04642105 125.50836182 53.04938889 125.52348328 53.05499268 125.53663635 53.06348038 125.54820251 53.07085037 125.56004333 53.07337952 125.56408691 53.07620239 125.57006836 53.08073044 125.57965851 53.07954025 125.58370209 53.07460022 125.60045624 53.06935883 125.61274719 53.06105042 125.61981201 53.05806732 125.62612152 53.05656052 125.62930298 53.05337143 125.62980652 53.04725647 125.63493347 53.04154968 125.6397171 53.02671814 125.65113831 53.02090454 125.65561676 53.00746536 125.66919708 53.00041962 125.68210602 52.99713898 125.69291687 52.99431229 125.71229553 52.99401855 125.71431732 52.99288177 125.71729279 52.98809433 125.72985077 52.98784256 125.7305069 52.98450851 125.73636627 52.97937012 125.7387085 52.97262192 125.73712921 52.96917725 125.73484802 52.9582901 125.72763824 52.94122314 125.72618103 52.93411636 125.72238159 52.92868042 125.70388794 52.9270401 125.68744659 52.92121887 125.67433929 52.92004395 125.67173767 52.91595078 125.66265869 52.90872955 125.65699005 52.8925705 125.65162659 52.8839798 125.65377045 52.87100983 125.65585327 52.8601265 125.66835785 52.85681915 125.67215729 52.86124039 125.68888855 52.86379623 125.6944046 52.87514877 125.71888733 52.87590027 125.72106171<span class="hljs-tag">&lt;/<span class="hljs-name">gml:posList</span>&gt;</span><br>                                <span class="hljs-tag">&lt;/<span class="hljs-name">gml:LinearRing</span>&gt;</span><br>                            <span class="hljs-tag">&lt;/<span class="hljs-name">gml:exterior</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">gml:Polygon</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">gml:surfaceMember</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">gml:MultiSurface</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">cesium:the_geom</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:GID_0</span>&gt;</span>CHN<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:GID_0</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:NAME_0</span>&gt;</span>China<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:NAME_0</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:GID_1</span>&gt;</span>CHN.11_1<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:GID_1</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:NAME_1</span>&gt;</span>Heilongjiang<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:NAME_1</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:NL_NAME_1</span>&gt;</span>黑龙江省|黑龍江省<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:NL_NAME_1</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:GID_2</span>&gt;</span>CHN.11.2_1<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:GID_2</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:NAME_2</span>&gt;</span>Daxing&#x27;anling<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:NAME_2</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:VARNAME_2</span>&gt;</span>Dàxīng&#x27;ānlǐng<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:VARNAME_2</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:NL_NAME_2</span>&gt;</span>大兴安岭地区<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:NL_NAME_2</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:TYPE_2</span>&gt;</span>Dìqu<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:TYPE_2</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:ENGTYPE_2</span>&gt;</span>Prefecture<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:ENGTYPE_2</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:CC_2</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:HASC_2</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">cesium:0</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">wfs:Insert</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">wfs:Transaction</span>&gt;</span><br></code></pre></td></tr></table></figure><p>多次插入同一个元素的话，会生成多个<code>id</code>不同的要素。因此我们不需要自己设置<code>id</code>.</p><p>用下面官网的来举例</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">wfs:Transaction</span></span><br><span class="hljs-tag">   <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;2.0.02.0.2&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">service</span>=<span class="hljs-string">&quot;WFS&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.someserver.example.com/myns&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">xmlns:gml</span>=<span class="hljs-string">&quot;http://www.opengis.net/gml/3.2&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">xmlns:wfs</span>=<span class="hljs-string">&quot;http://www.opengis.net/wfs/2.0&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.someserver.example.com/myns ./SampleSchema.xsd</span></span><br><span class="hljs-tag"><span class="hljs-string">                       http://www.opengis.net/wfs/2.0</span></span><br><span class="hljs-tag"><span class="hljs-string">                       http://schemas.opengis.net/wfs/2.0.02.0/wfs.xsd</span></span><br><span class="hljs-tag"><span class="hljs-string">                       http://www.opengis.net/gml/3.2</span></span><br><span class="hljs-tag"><span class="hljs-string">                       http://schemas.opengis.net/gml/3.2.1/gml.xsd&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">wfs:Insert</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">InWaterA_1M</span> <span class="hljs-attr">gml:id</span>=<span class="hljs-string">&quot;F1&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">wkbGeom</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">gml:Polygon</span> <span class="hljs-attr">srsName</span>=<span class="hljs-string">&quot;urn:ogc:def:crs:EPSG::4326http://www.opengis.net/def/crs/epsg/0/4326&quot;</span> <span class="hljs-attr">gml:id</span>=<span class="hljs-string">&quot;P1&quot;</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">gml:exterior</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">gml:LinearRing</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">gml:posList</span>&gt;</span>-30.93597221374512 117.6290588378906 -30.94830513000489 117.6447219848633 -30.95219421386719 117.6465530395508 -30.95219421386719 117.6431121826172 -30.94802856445312 117.6386108398438 -30.94799995422363 117.6314163208008 -30.946138381958 117.62850189209 -30.94430541992188 117.6295852661133 -30.93280601501464 117.6240539550781 -30.92869377136231 117.624641418457 -30.92386054992676 117.6201400756836 -30.92111206054688 117.6206970214844 -30.92458343505859 117.6275863647461 -30.93597221374512 117.6290588378906<span class="hljs-tag">&lt;/<span class="hljs-name">gml:posList</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">gml:LinearRing</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">gml:exterior</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">gml:Polygon</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">wkbGeom</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>28022<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">fCode</span>&gt;</span>BH000<span class="hljs-tag">&lt;/<span class="hljs-name">fCode</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">hyc</span>&gt;</span>6<span class="hljs-tag">&lt;/<span class="hljs-name">hyc</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">tileId</span>&gt;</span>177<span class="hljs-tag">&lt;/<span class="hljs-name">tileId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">facId</span>&gt;</span>132<span class="hljs-tag">&lt;/<span class="hljs-name">facId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">InWaterA_1M</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">InWaterA_1M</span> <span class="hljs-attr">gml:id</span>=<span class="hljs-string">&quot;F2&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">wkbGeom</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">gml:Polygon</span> <span class="hljs-attr">srsName</span>=<span class="hljs-string">&quot;urn:ogc:def:crs:EPSG::4326http://www.opengis.net/def/crs/epsg/0/4326&quot;</span> <span class="hljs-attr">gml:id</span>=<span class="hljs-string">&quot;P2&quot;</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">gml:exterior</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">gml:LinearRing</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">gml:posList</span>&gt;</span>-30.92013931274414 117.6552810668945 -30.92383384704589 117.661361694336 -30.93005561828613 117.6666412353516 -30.93280601501464 117.6663589477539 -30.93186187744141 117.6594467163086 -30.93780517578125 117.6541137695312 -30.94397163391114 117.6519470214844 -30.94255638122559 117.6455535888672 -30.93402862548828 117.6336364746094 -30.92874908447266 117.6355285644531 -30.92138862609864 117.6326370239258 -30.92236137390137 117.6395568847656 -30.91708374023438 117.6433029174805 -30.91711044311523 117.6454467773437 -30.92061042785645 117.6484985351563 -30.92061042785645 117.6504135131836 -30.91638946533203 117.6504440307617 -30.92013931274414 117.6552810668945 <span class="hljs-tag">&lt;/<span class="hljs-name">gml:posList</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">gml:LinearRing</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">gml:exterior</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">gml:Polygon</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">wkbGeom</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>28021<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">fCode</span>&gt;</span>BH000<span class="hljs-tag">&lt;/<span class="hljs-name">fCode</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">hyc</span>&gt;</span>6<span class="hljs-tag">&lt;/<span class="hljs-name">hyc</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">tileId</span>&gt;</span>177<span class="hljs-tag">&lt;/<span class="hljs-name">tileId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">facId</span>&gt;</span>131<span class="hljs-tag">&lt;/<span class="hljs-name">facId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">InWaterA_1M</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">wfs:Insert</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">wfs:Transaction</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">wfs:Transaction</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;2.0.2&quot;</span> <span class="hljs-attr">service</span>=<span class="hljs-string">&quot;WFS&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xmlns:cesium</span>=<span class="hljs-string">&quot;http://geoserver.org/cesium&quot;</span> <span class="hljs-attr">xmlns:wfs</span>=<span class="hljs-string">&quot;http://www.opengis.net/wfs/2.0&quot;</span> <span class="hljs-attr">xmlns:gml</span>=<span class="hljs-string">&quot;http://www.opengis.net/gml/3.2&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="hljs-attr">numberMatched</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">numberReturned</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">timeStamp</span>=<span class="hljs-string">&quot;2020-10-21T05:46:20.854Z&quot;</span> <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.opengis.net/wfs/2.0 http://localhost:8080/geoserver/schemas/wfs/2.0/wfs.xsd http://geoserver.org/cesium http://localhost:8080/geoserver/cesium/wfs?service=WFS<span class="hljs-symbol">&amp;amp;</span>version=2.0.0<span class="hljs-symbol">&amp;amp;</span>request=DescribeFeatureType<span class="hljs-symbol">&amp;amp;</span>typeName=cesium%3A0 http://www.opengis.net/gml/3.2 http://localhost:8080/geoserver/schemas/gml/3.2.1/gml.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">wfs:Insert</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">cesium:0</span> <span class="hljs-attr">gml:id</span>=<span class="hljs-string">&quot;0.102&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:the_geom</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">gml:MultiSurface</span> <span class="hljs-attr">srsName</span>=<span class="hljs-string">&quot;urn:ogc:def:crs:EPSG::4326&quot;</span> <span class="hljs-attr">srsDimension</span>=<span class="hljs-string">&quot;2&quot;</span> <span class="hljs-attr">gml:id</span>=<span class="hljs-string">&quot;0.102.the_geom&quot;</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">gml:surfaceMember</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">gml:Polygon</span> <span class="hljs-attr">gml:id</span>=<span class="hljs-string">&quot;0.102.the_geom.1&quot;</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">gml:exterior</span>&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">gml:LinearRing</span>&gt;</span><br>                                    <span class="hljs-tag">&lt;<span class="hljs-name">gml:posList</span>&gt;</span><br>                                  50.75596883266384 103.3116295189964 51.75596883266384 103.3116295189964<br>                                  <span class="hljs-tag">&lt;/<span class="hljs-name">gml:posList</span>&gt;</span><br>                                <span class="hljs-tag">&lt;/<span class="hljs-name">gml:LinearRing</span>&gt;</span><br>                            <span class="hljs-tag">&lt;/<span class="hljs-name">gml:exterior</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">gml:Polygon</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">gml:surfaceMember</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">gml:MultiSurface</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">cesium:the_geom</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:GID_0</span>&gt;</span>CHN<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:GID_0</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:NAME_0</span>&gt;</span>中国<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:NAME_0</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:GID_1</span>&gt;</span>CHN.11_1<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:GID_1</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:NAME_1</span>&gt;</span>Heilongjiang<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:NAME_1</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:NL_NAME_1</span>&gt;</span>测试数据1<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:NL_NAME_1</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:GID_2</span>&gt;</span>CHN.11.2_1<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:GID_2</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:NAME_2</span>&gt;</span>Daxing&#x27;anling<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:NAME_2</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:VARNAME_2</span>&gt;</span>Dàxīng&#x27;ānlǐng<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:VARNAME_2</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:NL_NAME_2</span>&gt;</span>测试数据<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:NL_NAME_2</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:TYPE_2</span>&gt;</span>Dìqu<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:TYPE_2</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:ENGTYPE_2</span>&gt;</span>Prefecture<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:ENGTYPE_2</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:CC_2</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:HASC_2</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">cesium:0</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">wfs:Insert</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">wfs:Transaction</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="测试点数据"><a href="#测试点数据" class="headerlink" title="测试点数据"></a>测试点数据</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">wfs:FeatureCollection</span> <span class="hljs-attr">xmlns:xs</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span> <span class="hljs-attr">xmlns:wfs</span>=<span class="hljs-string">&quot;http://www.opengis.net/wfs/2.0&quot;</span> <span class="hljs-attr">xmlns:gml</span>=<span class="hljs-string">&quot;http://www.opengis.net/gml/3.2&quot;</span> <span class="hljs-attr">xmlns:topp</span>=<span class="hljs-string">&quot;http://www.openplans.org/topp&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="hljs-attr">numberMatched</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">numberReturned</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">timeStamp</span>=<span class="hljs-string">&quot;2020-10-21T13:05:14.443Z&quot;</span> <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.opengis.net/wfs/2.0 http://localhost:8080/geoserver/schemas/wfs/2.0/wfs.xsd http://www.openplans.org/topp http://localhost:8080/geoserver/topp/wfs?service=WFS<span class="hljs-symbol">&amp;amp;</span>version=2.0.0<span class="hljs-symbol">&amp;amp;</span>request=DescribeFeatureType<span class="hljs-symbol">&amp;amp;</span>typeName=topp%3Atasmania_cities http://www.opengis.net/gml/3.2 http://localhost:8080/geoserver/schemas/gml/3.2.1/gml.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">wfs:member</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">topp:tasmania_cities</span> <span class="hljs-attr">gml:id</span>=<span class="hljs-string">&quot;tasmania_cities.1&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">topp:the_geom</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">gml:MultiPoint</span> <span class="hljs-attr">srsName</span>=<span class="hljs-string">&quot;urn:ogc:def:crs:EPSG::4326&quot;</span> <span class="hljs-attr">srsDimension</span>=<span class="hljs-string">&quot;2&quot;</span> <span class="hljs-attr">gml:id</span>=<span class="hljs-string">&quot;tasmania_cities.1.the_geom&quot;</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">gml:pointMember</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">gml:Point</span> <span class="hljs-attr">gml:id</span>=<span class="hljs-string">&quot;tasmania_cities.1.the_geom.1&quot;</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">gml:pos</span>&gt;</span>-42.85100182 147.29100045<span class="hljs-tag">&lt;/<span class="hljs-name">gml:pos</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">gml:Point</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">gml:pointMember</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">gml:MultiPoint</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">topp:the_geom</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">topp:CITY_NAME</span>&gt;</span>Hobart<span class="hljs-tag">&lt;/<span class="hljs-name">topp:CITY_NAME</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">topp:ADMIN_NAME</span>&gt;</span>Tasmania<span class="hljs-tag">&lt;/<span class="hljs-name">topp:ADMIN_NAME</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">topp:CNTRY_NAME</span>&gt;</span>Australia<span class="hljs-tag">&lt;/<span class="hljs-name">topp:CNTRY_NAME</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">topp:STATUS</span>&gt;</span>Provincial capital<span class="hljs-tag">&lt;/<span class="hljs-name">topp:STATUS</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">topp:POP_CLASS</span>&gt;</span>100,000 to 250,000<span class="hljs-tag">&lt;/<span class="hljs-name">topp:POP_CLASS</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">topp:tasmania_cities</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">wfs:member</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">wfs:FeatureCollection</span>&gt;</span><br></code></pre></td></tr></table></figure><p>自己的数据</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">wfs:Transaction</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;2.0.2&quot;</span> <span class="hljs-attr">service</span>=<span class="hljs-string">&quot;WFS&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://localhost:8080/geoserver/topp&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xmlns:xs</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span> <span class="hljs-attr">xmlns:wfs</span>=<span class="hljs-string">&quot;http://www.opengis.net/wfs/2.0&quot;</span> <span class="hljs-attr">xmlns:gml</span>=<span class="hljs-string">&quot;http://www.opengis.net/gml/3.2&quot;</span> <span class="hljs-attr">xmlns:topp</span>=<span class="hljs-string">&quot;http://localhost:8080/geoserver/topp&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">numberMatched</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">numberReturned</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">timeStamp</span>=<span class="hljs-string">&quot;2020-10-21T13:05:14.443Z&quot;</span> <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.opengis.net/wfs/2.0 http://localhost:8080/geoserver/schemas/wfs/2.0/wfs.xsd http://www.openplans.org/topp http://localhost:8080/geoserver/topp/wfs?service=WFS<span class="hljs-symbol">&amp;amp;</span>version=2.0.0<span class="hljs-symbol">&amp;amp;</span>request=DescribeFeatureType<span class="hljs-symbol">&amp;amp;</span>typeName=topp%3Atasmania_cities http://www.opengis.net/gml/3.2 http://localhost:8080/geoserver/schemas/gml/3.2.1/gml.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">wfs:Insert</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">topp:tasmania_cities</span> <span class="hljs-attr">gml:id</span>=<span class="hljs-string">&quot;tasmania_cities.1&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">topp:the_geom</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">gml:MultiPoint</span> <span class="hljs-attr">srsName</span>=<span class="hljs-string">&quot;urn:ogc:def:crs:EPSG::4326&quot;</span> <span class="hljs-attr">srsDimension</span>=<span class="hljs-string">&quot;2&quot;</span> <span class="hljs-attr">gml:id</span>=<span class="hljs-string">&quot;tasmania_cities.1.the_geom&quot;</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">gml:pointMember</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">gml:Point</span> <span class="hljs-attr">gml:id</span>=<span class="hljs-string">&quot;tasmania_cities.1.the_geom.1&quot;</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">gml:pos</span>&gt;</span>-42.85100182 147.29100045<span class="hljs-tag">&lt;/<span class="hljs-name">gml:pos</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">gml:Point</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">gml:pointMember</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">gml:MultiPoint</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">topp:the_geom</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">topp:CITY_NAME</span>&gt;</span>Hobart<span class="hljs-tag">&lt;/<span class="hljs-name">topp:CITY_NAME</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">topp:ADMIN_NAME</span>&gt;</span>Tasmania<span class="hljs-tag">&lt;/<span class="hljs-name">topp:ADMIN_NAME</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">topp:CNTRY_NAME</span>&gt;</span>Australia<span class="hljs-tag">&lt;/<span class="hljs-name">topp:CNTRY_NAME</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">topp:STATUS</span>&gt;</span>Provincial capital<span class="hljs-tag">&lt;/<span class="hljs-name">topp:STATUS</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">topp:POP_CLASS</span>&gt;</span>100,000 to 250,000<span class="hljs-tag">&lt;/<span class="hljs-name">topp:POP_CLASS</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">topp:tasmania_cities</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">wfs:Insert</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">wfs:Transaction</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="插入结构分析"><a href="#插入结构分析" class="headerlink" title="插入结构分析"></a>插入结构分析</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">wfs:Transaction</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;2.0.2&quot;</span> <span class="hljs-attr">service</span>=<span class="hljs-string">&quot;WFS&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:cesium</span>=<span class="hljs-string">&quot;http://geoserver.org/cesium&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://localhost:8080/geoserver/cesium&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:gml</span>=<span class="hljs-string">&quot;http://www.opengis.net/gml/3.2&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:wfs</span>=<span class="hljs-string">&quot;http://www.opengis.net/wfs/2.0&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>  <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;</span></span><br><span class="hljs-tag"><span class="hljs-string">    http://www.opengis.net/wfs/2.0</span></span><br><span class="hljs-tag"><span class="hljs-string">    http://localhost:8080/geoserver/schemas/wfs/2.0/wfs.xsd</span></span><br><span class="hljs-tag"><span class="hljs-string">    http://geoserver.org/cesium http://localhost:8080/geoserver/cesium/wfs?service=WFS<span class="hljs-symbol">&amp;amp;</span>version=2.0.0<span class="hljs-symbol">&amp;amp;</span>request=DescribeFeatureType<span class="hljs-symbol">&amp;amp;</span>typeName=cesium%3A0</span></span><br><span class="hljs-tag"><span class="hljs-string">    http://www.opengis.net/gml/3.2 http://localhost:8080/geoserver/schemas/gml/3.2.1/gml.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">wfs:Insert</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">cesium:0</span> <span class="hljs-attr">gml:id</span>=<span class="hljs-string">&quot;0.133&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:the_geom</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">gml:MultiPoint</span> <span class="hljs-attr">srsName</span>=<span class="hljs-string">&quot;urn:ogc:def:crs:EPSG::4326&quot;</span> <span class="hljs-attr">srsDimension</span>=<span class="hljs-string">&quot;2&quot;</span> <span class="hljs-attr">gml:id</span>=<span class="hljs-string">&quot;tasmania_cities.1.the_geom&quot;</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">gml:pointMember</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">gml:Point</span> <span class="hljs-attr">gml:id</span>=<span class="hljs-string">&quot;tasmania_cities.1.the_geom.1&quot;</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">gml:pos</span>&gt;</span>-42.85100182 147.29100045<span class="hljs-tag">&lt;/<span class="hljs-name">gml:pos</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">gml:Point</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">gml:pointMember</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">gml:MultiPoint</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">cesium:the_geom</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:GID_0</span>&gt;</span>CHN<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:GID_0</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:NAME_0</span>&gt;</span>China<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:NAME_0</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:GID_1</span>&gt;</span>CHN.13_1<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:GID_1</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:NAME_1</span>&gt;</span>Hubei<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:NAME_1</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:NL_NAME_1</span>&gt;</span>湖北<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:NL_NAME_1</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:GID_2</span>&gt;</span>CHN.13.2_1<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:GID_2</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:NAME_2</span>&gt;</span>Ezhou by emhui111<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:NAME_2</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:VARNAME_2</span>&gt;</span>Èzhōu<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:VARNAME_2</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:NL_NAME_2</span>&gt;</span>鄂州市<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:NL_NAME_2</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:TYPE_2</span>&gt;</span>Dìjíshì<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:TYPE_2</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:ENGTYPE_2</span>&gt;</span>Prefecture City<span class="hljs-tag">&lt;/<span class="hljs-name">cesium:ENGTYPE_2</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:CC_2</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cesium:HASC_2</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">cesium:0</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">wfs:Insert</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">wfs:Transaction</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">wfs:FeatureCollection</span> <span class="hljs-attr">xmlns:xs</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span> <span class="hljs-attr">xmlns:cesium</span>=<span class="hljs-string">&quot;http://geoserver.org/cesium&quot;</span> <span class="hljs-attr">xmlns:wfs</span>=<span class="hljs-string">&quot;http://www.opengis.net/wfs/2.0&quot;</span> <span class="hljs-attr">xmlns:gml</span>=<span class="hljs-string">&quot;http://www.opengis.net/gml/3.2&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="hljs-attr">numberMatched</span>=<span class="hljs-string">&quot;356&quot;</span> <span class="hljs-attr">numberReturned</span>=<span class="hljs-string">&quot;356&quot;</span> <span class="hljs-attr">timeStamp</span>=<span class="hljs-string">&quot;2020-10-26T01:26:59.770Z&quot;</span> <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.opengis.net/wfs/2.0 http://localhost:8080/geoserver/schemas/wfs/2.0/wfs.xsd http://geoserver.org/cesium http://localhost:8080/geoserver/cesium/wfs?service=WFS<span class="hljs-symbol">&amp;amp;</span>version=2.0.0<span class="hljs-symbol">&amp;amp;</span>request=DescribeFeatureType<span class="hljs-symbol">&amp;amp;</span>typeName=cesium%3A0 http://www.opengis.net/gml/3.2 http://localhost:8080/geoserver/schemas/gml/3.2.1/gml.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">wfs:member</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>GeoServer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>geoserver</tag>
      
      <tag>gis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1103 Integer Factorization</title>
    <link href="/2021/01/13/1103-Integer-Factorization/"/>
    <url>/2021/01/13/1103-Integer-Factorization/</url>
    
    <content type="html"><![CDATA[<h1 id="1103-Integer-Factorization"><a href="#1103-Integer-Factorization" class="headerlink" title="1103 Integer Factorization"></a>1103 Integer Factorization</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/YD0TiN.png" alt="YD0TiN"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>拿题目中的数据来举例 $N = 169, K = 5, P = 2$</p><ol><li>先计算出第一个位置$n_0$的范围。$max(n_0) = \sqrt[2]{169} = 13$，因此$n_0$的范围在$13 \sim 1$（从最大值开始往后遍历）。</li><li>当$n_0 = 13$时，$N = 169 - 13^2 = 0$，因为$K = 5 &gt; 1$所以$n_0=13$不满足，当$n_0=12$时，$N = 169 - 12^2 = 25$, 此时计算$n_1$的范围,$max(n_1) = \sqrt[2]{25} = 5$,$n_1$范围$5 \sim 1$.令$n_1 = 5$</li><li>当$n_1 = 5$时，$N = 25 - 5^2 = 0$，此时$K = 5 &gt; 2$，不满足，所以令$n_1 = 4$，继续求$n_2$.</li><li>重复上面步骤，当$N == 0$ 且$n_i (i == K)$时候即找到了所有的$n_i$。</li></ol><p>通过上面总结出下面的公示。</p><p>$$<br>N_i = N_{i - 1} - n_{i}^p \qquad (0 &lt;= i &lt;= K; 1 &lt;= n_{i} &lt;= \sqrt[p]{N_{i - 1}})<br>$$</p><p>设置以下变量来存储数据</p><ul><li><code>vector&lt;int&gt; graphic;</code>: 存储$n_i$结果</li><li><code>vector&lt;int&gt; ans;</code> : 存储$Sum(n_i)$的最大值对应的$n_i$</li><li><code>vector&lt;int&gt; fact</code>: 存储$n_i^P$的所有结果，防止重复计算出现超时。</li><li><code>int maxSum;</code> : 存储$Sum(n_i)$的最大值</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans, graphic,face;<br><span class="hljs-keyword">int</span> maxSum = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">int</span> n, k, p;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> idx, <span class="hljs-keyword">int</span> tempN, <span class="hljs-keyword">int</span> sum)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (idx == k &amp;&amp; tempN == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 找到了结果</span><br>        <span class="hljs-keyword">if</span> (maxSum &lt; sum) &#123;<br>            maxSum = sum;<br>            ans = graphic;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tempN &lt; <span class="hljs-number">0</span> || idx &gt; k) &#123;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-keyword">int</span> data = (<span class="hljs-keyword">int</span>)<span class="hljs-built_in">pow</span>(tempN, <span class="hljs-number">1.0</span> / p); <span class="hljs-comment">// 求出最大值,再依次计算是否满足</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = data; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">if</span> (i &lt;= graphic[idx - <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 防止当前的值大于前面的值，出现超时计算</span><br>            <span class="hljs-keyword">int</span> tempNN = tempN;<br>            tempNN -= face[i];<br>            graphic.push_back(i);<br>            sum += i;<br>            dfs(idx + <span class="hljs-number">1</span>, tempNN, sum);<br>            graphic.pop_back();<br>            sum -= i;<br>         &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;k, &amp;p);<br>    <span class="hljs-keyword">int</span> data = (<span class="hljs-keyword">int</span>)<span class="hljs-built_in">pow</span>(n, <span class="hljs-number">1.0</span> / p);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= data; i++) &#123;<br>        face.push_back(<span class="hljs-built_in">pow</span>(i, p));<br>    &#125;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = data; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">int</span> tempN = n;<br>        tempN -= face[i];<br>        graphic.push_back(i);<br>        sum += i;<br>        dfs(<span class="hljs-number">1</span>, tempN, sum);<br>        graphic.pop_back();<br>        sum -= i;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (maxSum != <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d = &quot;</span>, n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i &lt; k - <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d^%d + &quot;</span>, ans[i], p);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d^%d\n&quot;</span>, ans[i], p);<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Impossible\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><p>下面面是做的三个优化，其中第一个优化解决了几个用例超时的问题。2，3优化是尝试，但是有一个用例<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="">[1]</span></a></sup>一直无法通过😭。</p><ol><li>保持$n_i &gt;= n_j （i &lt; j）$，防止超时</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = data; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br><span class="hljs-keyword">if</span> (i &lt;= graphic[idx - <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 防止当前的值大于前面的值，出现超时计算</span><br><span class="hljs-keyword">int</span> tempNN = tempN;<br>tempNN -= face[i];<br>graphic.push_back(i);<br>sum += i;<br>dfs(idx + <span class="hljs-number">1</span>, tempNN, sum);<br>graphic.pop_back();<br>sum -= i;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>在每次计算$n_i$的同时，也计算$Sum(n_i)$的值。当得到结果后可以直接比较是否是最佳结果。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = data; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br><span class="hljs-keyword">int</span> tempN = n;<br>tempN -= face[i];<br>graphic.push_back(i);<br>sum += i;<br>dfs(<span class="hljs-number">1</span>, tempN, sum);<br>graphic.pop_back();<br>sum -= i;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>设置<code>fact</code>变量存储$n_i^P$的结果，计算$N_j = N_{j-1} - n_i^P$直接读取$n_i^P$结果。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= data; i++) &#123;<br>face.push_back(<span class="hljs-built_in">pow</span>(i, p));<br>&#125;<br></code></pre></td></tr></table></figure><section class="footnotes"><h2>参考</h2><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/Y1wPoW.png" alt="一直超时"><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
      <tag>dfs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1097 Deduplication on a Linked List</title>
    <link href="/2021/01/13/1097-Deduplication-on-a-Linked-List/"/>
    <url>/2021/01/13/1097-Deduplication-on-a-Linked-List/</url>
    
    <content type="html"><![CDATA[<h1 id="1097-Deduplication-on-a-Linked-List"><a href="#1097-Deduplication-on-a-Linked-List" class="headerlink" title="1097 Deduplication on a Linked List"></a>1097 Deduplication on a Linked List</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/hpuYZC.png" alt="hpuYZC"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本题目的是<strong>给定一个链表，按顺序删除结点中绝对值重复的链表，并且将删除后的结点按顺序输出，然后再按序输出被删除的结点</strong></p><p>具体步骤</p><ol><li>创建一个静态链表，存储结点信息。其中使用<code>order</code>表示结点在链表中的顺序。先将所有的结点<code>order=2*maxn</code>。然后非重复的结点<code>order</code>从<code>0</code>开始，重复的结点<code>order</code>从<code>maxn + i</code>开始。</li><li>使用一个<code>isExist</code>判断结点值是否重复。</li><li>设置两个变量<code>vaildCount,removeCount</code>分别表示非重复结点和被删除结点数量。在使用<code>begin</code>遍历结点顺序的时候，分别设置结点的<code>order</code>。下面是关键代码</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">while</span> (begin != <span class="hljs-number">-1</span>) &#123;<br><span class="hljs-keyword">if</span> (!isExist[<span class="hljs-built_in">abs</span>(node[begin].data)]) &#123;<br>isExist[<span class="hljs-built_in">abs</span>(node[begin].data)] = <span class="hljs-literal">true</span>;<br>node[begin].order = vaildCount++;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>node[begin].order = maxn + removeCount++;<br>&#125;<br>begin = node[begin].next;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>对结点按照<code>order</code>排序，无效结点<code>order=2*maxn</code>都会被排到后面。而<code>0 ~ vaildCount - 1</code>为非重复结点。<code>vaildCount ~ vaildCOunt + removeCount - 1</code>为被删除结点。</li></ol><p>⚠️会有不出现在给定链表上的结点，为无效结点。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">100010</span>;<br><span class="hljs-keyword">bool</span> isExist[<span class="hljs-number">2</span> * maxn + <span class="hljs-number">1</span>];<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>    <span class="hljs-keyword">int</span> address, data, next;<br>    <span class="hljs-keyword">int</span> order; <span class="hljs-comment">// 标记结点在原来数组的位置。删除的结点设置为maxn+remveCount</span><br>&#125;node[maxn];<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Node a, Node b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a.order &lt; b.order;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(isExist, <span class="hljs-literal">false</span>,  <span class="hljs-keyword">sizeof</span>(isExist));<br>    <span class="hljs-keyword">int</span> begin, n, address, vaildCount = <span class="hljs-number">0</span>, removeCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;begin, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;address);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;node[address].data, &amp;node[address].next);<br>        node[address].address = address;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; maxn; i++) &#123;node[i].order = <span class="hljs-number">2</span> * maxn;&#125;<br><br>    <span class="hljs-keyword">while</span> (begin != <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (!isExist[<span class="hljs-built_in">abs</span>(node[begin].data)]) &#123;<br>            isExist[<span class="hljs-built_in">abs</span>(node[begin].data)] = <span class="hljs-literal">true</span>;<br>            node[begin].order = vaildCount++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            node[begin].order = maxn + removeCount++;<br>        &#125;<br>        begin = node[begin].next;<br>    &#125;<br>    sort(node, node+maxn,cmp);<br>    <span class="hljs-keyword">int</span> allCount = vaildCount + removeCount;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; allCount; i++) &#123;<br>        <span class="hljs-keyword">if</span> (i != vaildCount<span class="hljs-number">-1</span> &amp;&amp; i != allCount - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d %d %05d\n&quot;</span>, node[i].address, node[i].data, node[i + <span class="hljs-number">1</span>].address);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d %d -1\n&quot;</span>, node[i].address, node[i].data);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
      <tag>链表</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>684. 冗余连接</title>
    <link href="/2021/01/13/684-%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5/"/>
    <url>/2021/01/13/684-%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="684-冗余连接"><a href="#684-冗余连接" class="headerlink" title="684. 冗余连接"></a><a href="https://leetcode-cn.com/problems/redundant-connection/">684. 冗余连接</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/NfR2TK.png" alt="NfR2TK"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本题考察的是<strong>并查集</strong>,假设它是一个无环图，那么边和顶点的数量是$e + 1 = v$。但是因为存在一条冗余边，因此边和顶点关系为$e=v$。</p><p>同时，在通过并查集连接两个顶点的时候，若该两个顶点已经出现在一个连通分量中，则证明该此图已经连通过，出现了环，若是没有，则连通该两点。</p><div class="note note-warning">            <p>并查集知识点参考</p><ul><li>并查集详解<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="并查集详解 ——图文解说,简单易懂">[1]</span></a></sup></li><li>《算法4》<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="算法4">[2]</span></a></sup></li></ul>          </div><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>C++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; parent, <span class="hljs-keyword">int</span> q)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (parent[q] != q) &#123;q = parent[q]; &#125; <span class="hljs-comment">// 找到根结点</span><br>        <span class="hljs-keyword">return</span> q;<br>    &#125;<br><br>    <span class="hljs-comment">// 加权quick-union方法，参考《算法4》</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quick_union</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; parent, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; weight, <span class="hljs-keyword">int</span> q, <span class="hljs-keyword">int</span> p)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> qRoot = find(parent, q), pRoot = find(parent, p);<br>        <span class="hljs-keyword">if</span> (qRoot == pRoot) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (weight[qRoot] &lt; weight[pRoot]) &#123;<br>            parent[qRoot] = pRoot;<br>            weight[pRoot] += weight[qRoot];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            parent[pRoot] = qRoot;<br>            weight[qRoot] += weight[pRoot];<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">findRedundantConnection</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> size = edges.size() + <span class="hljs-number">1</span>;<br>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">parent</span><span class="hljs-params">(size)</span></span>;<br>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">weight</span><span class="hljs-params">(size, <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123; <span class="hljs-comment">// 初始化</span><br>            parent[i] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; edge: edges) &#123;<br>            <span class="hljs-keyword">int</span> p = edge[<span class="hljs-number">0</span>], q = edge[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (find(parent, q) != find(parent, p)) &#123;<br>                quick_union(parent, weight, q, p);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> edge;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这里参考《算法4》<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="算法4">[2]</span></a></sup>,使用的是加权quick-union方法。经过测试时间上是有提升，但是有时候也不稳定。时间是非加权结果一样。如图测试结果</p><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/rHY9BU.png" alt="rHY9BU"></p><p>Python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findRedundantConnection</span>(<span class="hljs-params">self, edges: List[List[<span class="hljs-built_in">int</span>]]</span>) -&gt; List[int]:</span><br>        nodesCount = <span class="hljs-built_in">len</span>(edges)<br>        parent = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(nodesCount + <span class="hljs-number">1</span>)) <span class="hljs-comment"># 初始化值，即 parent[i] = i</span><br><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find</span>(<span class="hljs-params">index: <span class="hljs-built_in">int</span></span>) -&gt; int:</span><br>            <span class="hljs-keyword">while</span> index != parent[index]: index = parent[index]<br>            <span class="hljs-keyword">return</span> index<br><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">union</span>(<span class="hljs-params">index1: <span class="hljs-built_in">int</span>, index2: <span class="hljs-built_in">int</span></span>):</span><br>            parent[find(index1)] = find(index2)<br><br>        <span class="hljs-keyword">for</span> node1, node2 <span class="hljs-keyword">in</span> edges:<br>            <span class="hljs-keyword">if</span> find(node1) != find(node2): <span class="hljs-comment"># 如果不再一个集合里面，则没有找到重复</span><br>                union(node1, node2)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> [node1, node2]<br><br>        <span class="hljs-keyword">return</span> []<br></code></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>以下是根据《算法4》<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="算法4">[2]</span></a></sup>写出的Python版本的Unin-find模板。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UF</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, N</span>):</span><br>        self.count = N<br>        self.<span class="hljs-built_in">id</span> = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(N))<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">count</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.count<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">connected</span>(<span class="hljs-params">self, p, q</span>):</span><br>        <span class="hljs-keyword">return</span> self.find(p) == self.find(q)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find</span>(<span class="hljs-params">self, p</span>):</span><br>        <span class="hljs-keyword">while</span> (p != self.<span class="hljs-built_in">id</span>[p]): p = self.<span class="hljs-built_in">id</span>[p]<br>        <span class="hljs-keyword">return</span> p<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">union</span>(<span class="hljs-params">self, p, q</span>):</span><br>        p_root, q_root = self.find(p), self.find(q)<br>        <span class="hljs-keyword">if</span> p_root == q_root: <span class="hljs-keyword">return</span><br>        self.<span class="hljs-built_in">id</span>[p] = q_root<br>        self.count -= <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><section class="footnotes"><h2>参考</h2><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://blog.csdn.net/liujian20150808/article/details/50848646">并查集详解 ——图文解说,简单易懂</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://m.douban.com/book/subject/19952400/">算法4</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图</tag>
      
      <tag>union-find</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1052 Linked List Sorting</title>
    <link href="/2021/01/12/1052-Linked-List-Sorting/"/>
    <url>/2021/01/12/1052-Linked-List-Sorting/</url>
    
    <content type="html"><![CDATA[<h1 id="1052-Linked-List-Sorting"><a href="#1052-Linked-List-Sorting" class="headerlink" title="1052 Linked List Sorting"></a>1052 Linked List Sorting</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><div class="note note-warning">            <p>仔细看题，考虑周全</p>          </div><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/7Q2QCm.png" alt="题目"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题和之前的题目一样，使用静态数组，然后进行排序。但是排序需要注意。因为存在无效数据，所以对于无效的结点，需要将结点放到最后面，然后再根据<code>key</code>值进行排序。</p><p><code>cmp</code>函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Node a, Node b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (a.flag == <span class="hljs-literal">false</span> || b.flag == <span class="hljs-literal">false</span>) &#123; <span class="hljs-comment">// 若是无效数据，就放到后面去，若数据有效，则根据key值放到前面</span><br>        <span class="hljs-keyword">return</span> a.flag &gt; b.flag;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> a.key &lt; b.key;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>⚠️</p><ul><li>记住有无效数据，即结点不在给定的头结点链表中，这些数据需要排除。通过设置<code>flag</code>来判断它是否存在。</li><li>需要考虑有效结点数量为0，设置<code>count</code>统计有效结点数量。</li></ul><p>下面代码是实现有效结点的统计和标记</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> p = head, count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (p != <span class="hljs-number">-1</span>) &#123;<br>node[p].flag = <span class="hljs-literal">true</span>;<br>count++;<br>p = node[p].next;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">100010</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>    <span class="hljs-keyword">int</span> address, key, next, order;<br>    <span class="hljs-keyword">bool</span> flag;<br>&#125;node[maxn];<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Node a, Node b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (a.flag == <span class="hljs-literal">false</span> || b.flag == <span class="hljs-literal">false</span>) &#123; <span class="hljs-comment">// 若是无效数据，就放到后面去，若数据有效，则根据key值放到前面</span><br>        <span class="hljs-keyword">return</span> a.flag &gt; b.flag;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> a.key &lt; b.key;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> head, n;<br>    <span class="hljs-keyword">int</span> address;<br>    <span class="hljs-keyword">int</span> order = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; maxn; i++) &#123;<br>        node[i].key = maxn;<br>        node[i].flag = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 过滤无效结点</span><br>    &#125;<br><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;head);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;address);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;node[address].key, &amp;node[address].next);<br>        node[address].address = address;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> p = head, count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (p != <span class="hljs-number">-1</span>) &#123;<br>        node[p].flag = <span class="hljs-literal">true</span>;<br>        count++;<br>        p = node[p].next;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0 -1\n&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        n = count;<br>        sort(node, node + maxn, cmp); <span class="hljs-comment">// 按照order进行排序</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %05d\n&quot;</span>, n, node[<span class="hljs-number">0</span>].address);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d %d %05d\n&quot;</span>, node[i].address, node[i].key, node[i + <span class="hljs-number">1</span>].address);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d %d -1\n&quot;</span>, node[n - <span class="hljs-number">1</span>].address, node[n - <span class="hljs-number">1</span>].key);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
      <tag>链表</tag>
      
      <tag>C++</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1032 Sharing</title>
    <link href="/2021/01/12/1032-Sharing/"/>
    <url>/2021/01/12/1032-Sharing/</url>
    
    <content type="html"><![CDATA[<h1 id="1032-Sharing"><a href="#1032-Sharing" class="headerlink" title="1032 Sharing"></a>1032 Sharing</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/XC2jKw.png" alt="题目"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本题是求链表的公共结点的首个结点地址。</p><p>⚠️这里是求<strong>公共结点的首个结点位置，而不是公共尾结点的首个结点位置。</strong></p><p>因此可以使用静态链表，在结构体中定义一个<code>flag</code>变量，表示该结点在第一个链表中出现过。</p><p>按照输入的第一个链表首地址，将第一链表的所有结点<code>flag</code>标志为<code>true</code>。</p><p>然后按照输入的第二个链表的首地址，找到第一个结点<code>flag=true</code>即为两个结点的首个公共结点。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>C++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">100010</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>    <span class="hljs-keyword">int</span> address, next;<br>    <span class="hljs-keyword">char</span> data;<br>    <span class="hljs-keyword">bool</span> flag;<br>&#125;node[maxn];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> begin_a, begin_b, n;<br>    <span class="hljs-keyword">int</span> address;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;begin_a, &amp;begin_b, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d &quot;</span>, &amp;address);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c%d&quot;</span>, &amp;node[address].data, &amp;node[address].next);<br>    &#125;<br>    <span class="hljs-comment">// init(node_a);</span><br>    <span class="hljs-comment">// init(node_b);</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; maxn; i++) &#123;node[i].flag = <span class="hljs-literal">false</span>;&#125;<br><br>    <span class="hljs-keyword">while</span>(begin_a != <span class="hljs-number">-1</span>) &#123;<br>        node[begin_a].flag = <span class="hljs-literal">true</span>;<br>        begin_a = node[begin_a].next;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (begin_b != <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (node[begin_b].flag) &#123;<span class="hljs-keyword">break</span>;&#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            begin_b = node[begin_b].next;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (begin_b != <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d\n&quot;</span>, begin_b);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-1\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>一开始看错了题目意思，认为是要寻找<strong>公共结尾的首地址</strong>。下面代码是找<strong>公共结尾的首地址</strong>。具体思路如下</p><ol><li>创建两个静态链表<code>node_a, node_b</code>。</li><li>分别对两个链表设置位置<code>order</code>，同时计算出它们的长度<code>len1, len2</code>。</li><li>最后对两个链表，从后往前进行对比，若找到第一个不同的结点。将他们输出进行对比，若该结点后的一样的，那就输出，若不一样，则输出-1.</li></ol><p>C++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 思路：组成两个链表，记录他们的长度，然后从后往前进行比较</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">100010</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>    <span class="hljs-keyword">int</span> address, next, order;<br>    <span class="hljs-keyword">char</span> data;<br>&#125;node_a[maxn], node_b[maxn], node[maxn];<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Node a, Node b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a.order &lt; b.order;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> begin_a, begin_b, n;<br>    <span class="hljs-keyword">int</span> address;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;begin_a, &amp;begin_b, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d &quot;</span>, &amp;address);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c%d&quot;</span>, &amp;node[address].data, &amp;node[address].next);<br>        node[address].address = address;<br>    &#125;<br>    <span class="hljs-comment">// init(node_a);</span><br>    <span class="hljs-comment">// init(node_b);</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; maxn; i++) &#123;node_a[i].order = maxn; node_b[i].order = maxn;&#125;<br>    <span class="hljs-keyword">int</span> len1 = <span class="hljs-number">0</span>, len2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// arrange_order(begin_a, node, node_a, len1);</span><br>    <span class="hljs-comment">// arrange_order(begin_b, node, node_b, len2);</span><br>    <span class="hljs-keyword">while</span>(begin_a != <span class="hljs-number">-1</span>) &#123;<br>        node_a[begin_a].address = node[begin_a].address;<br>        node_a[begin_a].data = node[begin_a].data;<br>        node_a[begin_a].next = node[begin_a].next;<br>        node_a[begin_a].order = len1++;<br>        begin_a = node[begin_a].next;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(begin_b != <span class="hljs-number">-1</span>) &#123;<br>        node_b[begin_b].address = node[begin_b].address;<br>        node_b[begin_b].data = node[begin_b].data;<br>        node_b[begin_b].next = node[begin_b].next;<br>        node_b[begin_b].order = len2++;<br>        begin_b = node[begin_b].next;<br>    &#125;<br>    sort(node_a, node_a + maxn, cmp);<br>    sort(node_b, node_b + maxn, cmp);<br>    <span class="hljs-keyword">while</span> (len1 &gt; <span class="hljs-number">0</span> &amp;&amp; len2 &gt; <span class="hljs-number">0</span> &amp;&amp; node_a[len1 - <span class="hljs-number">1</span>].address == node_b[len2 - <span class="hljs-number">1</span>].address) &#123;<br>        len1--;<br>        len2--;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (node_a[len1].address == node_b[len2].address) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d\n&quot;</span>, node_a[len1].address);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-1\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
      <tag>链表</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1025 反转链表</title>
    <link href="/2021/01/11/1025-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <url>/2021/01/11/1025-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="1025-反转链表"><a href="#1025-反转链表" class="headerlink" title="1025 反转链表"></a>1025 反转链表</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><div class="note note-warning">            <p>难度：中等</p>          </div><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/CSJuhH.png" alt="反转链表"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>本题看起来不难，但是和<strong>leetcode</strong>不一样，他的数据是自己输入，因此还需要构造一个数据结构来存储每个输入数据</p></blockquote><ol><li>创建一个结构体如下，存储链表。其中使用一个<code>order</code>来表示链表的顺序。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">100010</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>&#123;</span><br>    <span class="hljs-keyword">int</span> address, next, order, data;<br>&#125;node[maxn];<br></code></pre></td></tr></table></figure><ul><li>address:该结点地址</li><li>next:下一个结点地址</li><li>order:结点在链表中的顺序。初始值为<code>maxn</code></li><li>data:结点数据</li></ul><ol start="2"><li>设置一个变量<code>count</code>,根据输入的首地址<code>begin</code>，给每个结点的<code>order</code>编号。最后让<code>n=count</code>.这一步很重要，因为可能给出的数据有两个链表。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (begin_address != <span class="hljs-number">-1</span>) &#123; <span class="hljs-comment">// 计算链表的顺序</span><br>node[begin_address].order = count++;<br>begin_address = node[begin_address].next;<br>&#125;<br>n = count; <span class="hljs-comment">// 这里需要处理一下，有时候会出现两个结点。部分用例无法通过</span><br>sort(node, node + maxn, cmp); <span class="hljs-comment">// 按照链表顺序进行排序，即有效数组都在前面。</span><br></code></pre></td></tr></table></figure><ol start="3"><li>对结点进行排序，然后分成<code>group = n / k</code>,每k个一组倒叙输出。每组的最后一个结点的<code>next</code>指向的是当前组的下一组的最后一个结点<code>address</code>。</li><li>⚠️对最后一组需要单独判断。若当前是最后一组，判断是否还存在多余的小于k的结点，若存在，对最后剩余结点正序输出。若不存在，输出<code>-1</code>。</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>C++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">100010</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>&#123;</span><br>    <span class="hljs-keyword">int</span> address, next, order, data;<br>&#125;node[maxn];<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Node a, Node b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a.order &lt; b.order;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> begin_address, n, k;<br>    <span class="hljs-keyword">int</span> address;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;begin_address, &amp;n, &amp;k);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;address);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;node[address].data, &amp;node[address].next);<br>        node[address].address = address;<br>    &#125;<br>    <span class="hljs-comment">// 初始化数组的order，方便排序</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; maxn; i++) &#123;node[i].order = maxn;&#125;<br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (begin_address != <span class="hljs-number">-1</span>) &#123; <span class="hljs-comment">// 计算链表的顺序</span><br>        node[begin_address].order = count++;<br>        <span class="hljs-comment">// count++;</span><br>        begin_address = node[begin_address].next;<br>    &#125;<br>    <span class="hljs-comment">// node[begin_address].order = count; // 最后一个等于-1也要标注order</span><br>    sort(node, node + maxn, cmp); <span class="hljs-comment">// 按照链表顺序进行排序，即有效数组都在前面。</span><br>    n = count; <span class="hljs-comment">// 这里需要处理一下，有时候会出现两个节点。部分用例无法通过</span><br>    <span class="hljs-comment">// 开始按照k个一组进行倒叙输出。</span><br>    <span class="hljs-comment">// 注意每组最后一个节点的next都是下一组的最后一个节点。</span><br>    <span class="hljs-comment">// 但是若是该组的下一组节点数量小于k，即下一个节点就是最后一组的第一个节点</span><br>    <span class="hljs-comment">// 若该组本身就是最后一个节点，那么下一个节点就是-1</span><br>    <span class="hljs-keyword">int</span> group = n / k; <span class="hljs-comment">// 满足每组k个数的组的数量</span><br>    <span class="hljs-comment">// 先处理前面group组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; group; i++) &#123;<br>        <span class="hljs-comment">// 倒叙输出第i组,注意每组最后一个node不要输出</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = (i + <span class="hljs-number">1</span>) * k - <span class="hljs-number">1</span>; j &gt; i * k; j--) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d %d %05d\n&quot;</span>, node[j].address, node[j].data, node[j - <span class="hljs-number">1</span>].address);<br>        &#125;<br>        <span class="hljs-comment">// 处理最后一个node的下一个节点</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d %d &quot;</span>, node[i * k].address, node[i * k].data);<br>        <span class="hljs-comment">// 如果当前i是最后一组</span><br>        <span class="hljs-keyword">if</span> (i == group - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// 判断是否还存在小于k的最后一组组</span><br>            <span class="hljs-keyword">if</span> (n % k == <span class="hljs-number">0</span>) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-number">-1</span>);&#125;<br>            <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 存在第group+1组</span><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d\n&quot;</span>, node[group * k].address); <span class="hljs-comment">// 指向group+1组的第一个节点。</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> r = group * k; r &lt; n - <span class="hljs-number">1</span>; r++) &#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d %d %05d\n&quot;</span>, node[r].address, node[r].data, node[r + <span class="hljs-number">1</span>].address);<br>                &#125;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d %d %d\n&quot;</span>, node[n - <span class="hljs-number">1</span>].address, node[n - <span class="hljs-number">1</span>].data, <span class="hljs-number">-1</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果不是最后一组，那么当前组的最后一个node的next指向下一个组的最后一个节点。</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d\n&quot;</span>, node[(i + <span class="hljs-number">2</span>)*k - <span class="hljs-number">1</span>].address);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>难点</p><ul><li>构造一个恰当的结构体</li><li>测试用例中存在多个<code>next = -1</code>,即多条链表,所以需要使用<code>count</code>记录有效结点，然后使用<code>n = count</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1202. Smallest String With Swaps</title>
    <link href="/2021/01/11/1202-Smallest-String-With-Swaps/"/>
    <url>/2021/01/11/1202-Smallest-String-With-Swaps/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/smallest-string-with-swaps/">1202. Smallest String With Swaps</a></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/SlDQXJ.png" alt="SlDQXJ"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本题主要考察连通图、将属于同一连通分量中的字符进行排序，再依次放到原来同一连通分量的位置中。</p><p>方法</p><ul><li><input checked="" disabled="" type="checkbox"> DFS</li><li><input checked="" disabled="" type="checkbox"> BFS</li><li><input disabled="" type="checkbox"> Union-find</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>Python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">self, connect_graphic, graphic, visited, idx</span>):</span><br>        visited[idx] = <span class="hljs-literal">True</span><br>        connect_graphic.append(idx) <span class="hljs-comment"># 添加当前属于同一个连通图的对象</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> graphic[idx]:<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> visited[i]:<br>                self.dfs(connect_graphic, graphic, visited, i)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">smallestStringWithSwaps</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, pairs: List[List[<span class="hljs-built_in">int</span>]]</span>) -&gt; str:</span><br>        <span class="hljs-comment"># 思路：同一个连通图內的字符按照顺序排序，再放回原来的位置</span><br>        size = <span class="hljs-built_in">len</span>(s)<br>        graphic = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(size)]<br>        <span class="hljs-keyword">for</span> i,j <span class="hljs-keyword">in</span> pairs: <span class="hljs-comment"># 建图</span><br>            graphic[i].append(j)<br>            graphic[j].append(i)<br>        print(graphic)<br>        visited = [<span class="hljs-literal">False</span>] * size<br>        res = <span class="hljs-built_in">list</span>(s)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(size):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> visited[i]:<br>                connect_graphic = []<br>                self.dfs(connect_graphic, graphic, visited, i)<br>                indicates = <span class="hljs-built_in">sorted</span>(connect_graphic) <span class="hljs-comment"># 索引排序</span><br>                string = <span class="hljs-built_in">sorted</span>([res[j] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> indicates]) <span class="hljs-comment"># 索引对应的字符排序</span><br>                <span class="hljs-keyword">for</span> key, val <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(indicates, string): <span class="hljs-comment"># 将对应的字符和对应的索引重现排大小</span><br>                    res[key] = val<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>.join(res)<br></code></pre></td></tr></table></figure><p>复杂度分析</p><ul><li>时间复杂度: $O(n)$,$n$为顶点的数量</li><li>空间复杂度: $O(m+n)$, $m,n$分别是图的顶点和边的数量</li></ul><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p>python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bfs</span>(<span class="hljs-params">self, connect_graphic, graphic, visited, idx</span>):</span><br>        q = collections.deque([idx])<br>        visited[idx] = <span class="hljs-literal">True</span><br>        connect_graphic.append(idx)<br>        <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(q) &gt; <span class="hljs-number">0</span>:<br>            node = q.popleft()<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> graphic[node]:<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> visited[i]:<br>                    visited[i] = <span class="hljs-literal">True</span><br>                    connect_graphic.append(i)<br>                    q.append(i)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">smallestStringWithSwaps</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, pairs: List[List[<span class="hljs-built_in">int</span>]]</span>) -&gt; str:</span><br>        <span class="hljs-comment"># 思路：同一个连通图內的字符按照顺序排序，再放回原来的位置</span><br>        size = <span class="hljs-built_in">len</span>(s)<br>        graphic = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(size)]<br>        <span class="hljs-keyword">for</span> i,j <span class="hljs-keyword">in</span> pairs: <span class="hljs-comment"># 建图</span><br>            graphic[i].append(j)<br>            graphic[j].append(i)<br>        print(graphic)<br>        visited = [<span class="hljs-literal">False</span>] * size<br>        res = <span class="hljs-built_in">list</span>(s)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(size):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> visited[i]:<br>                connect_graphic = []<br>                <span class="hljs-comment"># self.dfs(connect_graphic, graphic, visited, i)</span><br>                self.bfs(connect_graphic, graphic, visited, i)<br>                indicates = <span class="hljs-built_in">sorted</span>(connect_graphic) <span class="hljs-comment"># 索引排序</span><br>                string = <span class="hljs-built_in">sorted</span>([res[j] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> indicates]) <span class="hljs-comment"># 索引对应的字符排序</span><br>                <span class="hljs-keyword">for</span> key, val <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(indicates, string): <span class="hljs-comment"># 将对应的字符和对应的索引重现排大小</span><br>                    res[key] = val<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>.join(res)<br></code></pre></td></tr></table></figure><p>复杂度分析</p><ul><li>时间复杂度: $O(n)$,$n$为顶点的数量</li><li>空间复杂度: $O(m+n)$, $m,n$分别是图的顶点和边的数量</li></ul>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>图</tag>
      
      <tag>union-find</tag>
      
      <tag>dfs</tag>
      
      <tag>bfs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1051 Pop Sequence</title>
    <link href="/2021/01/07/1051-Pop-Sequence/"/>
    <url>/2021/01/07/1051-Pop-Sequence/</url>
    
    <content type="html"><![CDATA[<h1 id="1051-Pop-Sequence-25分"><a href="#1051-Pop-Sequence-25分" class="headerlink" title="1051 Pop Sequence (25分)"></a>1051 Pop Sequence (25分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/18Xskb.png" alt="18Xskb"></p><p>本题给定一个大小为$M$的栈，然后有一堆有序序列$1,2,3,4,5…N$依次入栈出栈。给定$K$个出栈序列，判断这几个出栈序列是否合法。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>建立一个栈，模拟$1 ~ N$进栈的过程，在这个过程中，将进栈的元素（<strong>栈顶元素</strong>）与当前<strong>出栈序列</strong>中的元素进行对比。若相等，则弹出栈顶，同时<strong>出栈序列</strong>往后移一位，继续此操作，直到有不相等的元素时，再让下一个元素进栈。</p><ol><li>建立一个初始的栈，该栈在每次输入前需要清空。</li><li>设置一个变量<code>flag</code>，若当前入栈后，栈的大小超过了<code>M</code>，则直接<code>flag = false;</code>然后跳出♻️。</li><li>接下然反复判断栈顶元素和当前第<code>idx</code>个<strong>出栈序列</strong>是否一样，若一样，执行弹出操作和<code>idx++</code></li><li>最后当栈为空且<code>flag=true</code>的时候输出<code>YES</code>,否则输出<code>No</code></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1001</span>;<br><span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; st;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> arr[maxn], m, n, k;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;m, &amp;n, &amp;k);<br>    <span class="hljs-keyword">while</span> (k--) &#123;<br>        <span class="hljs-keyword">while</span> (!st.empty()) &#123;st.pop();&#125; <span class="hljs-comment">// 每次都要清空栈</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;arr[i]);<br>        &#125;<br>        <span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>; <span class="hljs-comment">// 输出数组的下标</span><br>        <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            st.push(i + <span class="hljs-number">1</span>); <span class="hljs-comment">// 把数字i+1压入栈</span><br>            <span class="hljs-keyword">if</span> (st.size() &gt; m) &#123;<br>                flag = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (!st.empty() &amp;&amp; st.top() == arr[idx]) &#123;<br>                st.pop();<br>                idx++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (st.empty() &amp;&amp; flag) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;YES\n&quot;</span>);&#125;<br>        <span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NO\n&quot;</span>);&#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度分析</p><ul><li>时间复杂度：$O(n+m)$</li><li>空间复杂度: $O(max(m,n))$</li></ul>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>547. Number of Provinces</title>
    <link href="/2021/01/07/547-Number-of-Provinces/"/>
    <url>/2021/01/07/547-Number-of-Provinces/</url>
    
    <content type="html"><![CDATA[<h1 id="547-Number-of-Provinces"><a href="#547-Number-of-Provinces" class="headerlink" title="547. Number of Provinces"></a><a href="https://leetcode-cn.com/problems/number-of-provinces/">547. Number of Provinces</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><div class="note note-warning">            <p>难度：中等</p>          </div><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/xmxR4o.png" alt="xmxR4o"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本题转化为图，其大概意思就是是<strong>给出一个用邻接矩阵表示的无向图，找出连通分量的数量</strong>。</p><p>解决问题的方法主要有三种方法</p><ol><li><ul><li><input checked="" disabled="" type="checkbox"> DFS</li></ul></li><li><ul><li><input checked="" disabled="" type="checkbox"> BFS</li></ul></li><li><ul><li><input checked="" disabled="" type="checkbox"> union-ﬁnd</li></ul></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p><strong>Python</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findCircleNum</span>(<span class="hljs-params">self, isConnected: List[List[<span class="hljs-built_in">int</span>]]</span>) -&gt; int:</span><br>        <span class="hljs-comment"># 求连通图的数量</span><br>        size = <span class="hljs-built_in">len</span>(isConnected)<br>        visited = [<span class="hljs-literal">False</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(size)]<br>        count = <span class="hljs-number">0</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">isConnected, idx</span>):</span><br>            visited[idx] = <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(size):<br>                <span class="hljs-keyword">if</span> isConnected[idx][i] == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> visited[i]:<br>                    dfs(isConnected, i)<br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(size):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> visited[i]:<br>                dfs(isConnected, i)<br>                count += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> count<br></code></pre></td></tr></table></figure><p><strong>C++</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findCircleNum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; isConnected)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> size = isConnected.size();<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(size, <span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (!visited[i]) &#123;<br>                dfs(isConnected, i, visited, size);<br>                count++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; isConnected, <span class="hljs-keyword">int</span> idx, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&amp; visited, <span class="hljs-keyword">int</span> size)</span> </span>&#123;<br>        visited[idx] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            <span class="hljs-keyword">if</span> (isConnected[idx][i] == <span class="hljs-number">1</span> &amp;&amp; !visited[i]) &#123;<br>                dfs(isConnected, i, visited, size);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度: $O(n^2)$,这里需要对矩阵进行遍历。</li><li>空间复杂度: $O(n)$, 使用<code>visited</code>存储<code>n</code>个城市是否被访问。</li></ul><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p><strong>C++</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python">class Solution &#123;<br>public:<br>    <span class="hljs-built_in">int</span> findCircleNum(vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt;&amp; isConnected) &#123;<br>        <span class="hljs-built_in">int</span> size = isConnected.size();<br>        <span class="hljs-built_in">int</span> count = <span class="hljs-number">0</span>;<br>        vector&lt;<span class="hljs-built_in">bool</span>&gt; visited(size, false);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (!visited[i]) &#123;<br>                bfs(isConnected, i, visited, size);<br>                count++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>    <br><br>    void bfs(vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt;&amp; isConnected, <span class="hljs-built_in">int</span> idx, vector&lt;<span class="hljs-built_in">bool</span>&gt;&amp; visited, <span class="hljs-built_in">int</span> size) &#123;<br>        visited[idx] = true;<br>        queue&lt;<span class="hljs-built_in">int</span>&gt; q;<br>        q.push(idx);<br>        <span class="hljs-keyword">while</span> (!q.empty()) &#123;<br>            <span class="hljs-built_in">int</span> node = q.front();<br>            q.pop();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                <span class="hljs-keyword">if</span> (isConnected[node][i] == <span class="hljs-number">1</span> &amp;&amp; !visited[i]) &#123;<br>                    visited[i] = true;<br>                    q.push(i);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>从上面可以看到，<code>BFS</code>和<code>DFS</code>的写法，只有计算连通分量的时候不一样，其他都是一样的。</p><p>复杂度分析</p><ul><li>时间复杂度：$O(n^2)$，遍历整个矩阵</li><li>空间复杂度: $O(n)$.visited大小的空间</li></ul><h3 id="union-find"><a href="#union-find" class="headerlink" title="union-find"></a>union-find</h3><p>Python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findCircleNum</span>(<span class="hljs-params">self, isConnected: List[List[<span class="hljs-built_in">int</span>]]</span>) -&gt; int:</span><br>        size = <span class="hljs-built_in">len</span>(isConnected)<br>        parent = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(size)) <span class="hljs-comment"># 初始化</span><br>        count = size <span class="hljs-comment"># 连通分量数量</span><br><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find</span>(<span class="hljs-params">p</span>):</span> <span class="hljs-comment"># 找到结点p</span><br>            <span class="hljs-keyword">while</span> p != parent[p]: p = parent[p]<br>            <span class="hljs-keyword">return</span> p<br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">union</span>(<span class="hljs-params">p, q</span>):</span><br>            <span class="hljs-keyword">nonlocal</span> count<br>            parent[find(p)] = find(q)<br>            count -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(size):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(size):<br>                <span class="hljs-keyword">if</span> isConnected[i][j] == <span class="hljs-number">1</span>:<br>                    <span class="hljs-keyword">if</span> find(i) != find(j):<br>                        union(i,j)<br>        <span class="hljs-keyword">return</span> count<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>图</tag>
      
      <tag>union-find</tag>
      
      <tag>dfs</tag>
      
      <tag>bfs</tag>
      
      <tag>leetcode</tag>
      
      <tag>无向图</tag>
      
      <tag>邻接矩阵</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1071 Speech Patterns</title>
    <link href="/2021/01/05/1071-Speech-Patterns/"/>
    <url>/2021/01/05/1071-Speech-Patterns/</url>
    
    <content type="html"><![CDATA[<h1 id="1071-Speech-Patterns-25分"><a href="#1071-Speech-Patterns-25分" class="headerlink" title="1071 Speech Patterns (25分)"></a>1071 Speech Patterns (25分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/dMgnxy.png" alt="dMgnxy"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本题目的是<strong>在一句话中，找到出现次数最多的有效单词</strong>。有效单词的定义是：包含<code>[0-9 a-z A-Z]</code>。因此本题分两步。</p><ul><li>分割出有效单词。大写字符要转成小写字母，无效字符使用<code>while</code>过滤。</li><li>使用<code>map</code>统计有效单词出现次数。</li><li>⚠️题目要求如果两个单词的数量一样，则输出字典上小的那个单词。而<code>C++</code>中<strong>map会以键从小到大的顺序自动排序</strong><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="算法笔记上机训练实战指南">[1]</span></a></sup>。所以下面这个关键代码对比的时候，使用<code>it-&gt;second &gt; macCount</code>就可以求出字典上小的那个单词。如果要求出字典顺序最大的那个单词，只需要<code>it-&gt;second &gt;= maxCount</code>就可以。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (<span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt;::iterator it = mp.begin(); it != mp.end(); ++it) &#123;<br><span class="hljs-keyword">if</span> (it-&gt;second &gt; maxCount) &#123;<br>maxCount = it-&gt;second;<br>ans = it-&gt;first;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 1. 分割字符串</span><br><span class="hljs-comment">// 2. 找出最大的值</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isVaildChar</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (c &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (c &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;z&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (c &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt; mp; <span class="hljs-comment">// 统计字符的数量</span><br>    <span class="hljs-built_in">string</span> str, ans;<br>    getline(<span class="hljs-built_in">cin</span>, str);<br>    <span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>, size = str.length(), maxCount = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (idx &lt; size) &#123; <span class="hljs-comment">// 开始分割字符串</span><br>        <span class="hljs-built_in">string</span> word;<br>        <span class="hljs-comment">// 1. 判断当前字符是否有效</span><br>        <span class="hljs-keyword">while</span> (idx &lt; size &amp;&amp; isVaildChar(str[idx])) &#123; <span class="hljs-comment">// 如果该字符有效</span><br>            <span class="hljs-keyword">if</span> (str[idx] &gt;=<span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; str[idx] &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>) &#123;str[idx] += <span class="hljs-number">32</span>;&#125;<br>            word += str[idx];<br>            idx++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (word != <span class="hljs-string">&quot;&quot;</span>) &#123; <span class="hljs-comment">// 如果该字符不是空的，就加入到map中</span><br>            <span class="hljs-keyword">if</span> (mp.find(word) != mp.end()) &#123;mp[word]++;&#125;<br>            <span class="hljs-keyword">else</span> &#123;mp[word] = <span class="hljs-number">1</span>;&#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (idx &lt; size &amp;&amp; !isVaildChar(str[idx])) &#123;idx++;&#125; <span class="hljs-comment">// 排除无效字符</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt;::iterator it = mp.begin(); it != mp.end(); ++it) &#123;<br>        <span class="hljs-keyword">if</span> (it-&gt;second &gt; maxCount) &#123;<br>            maxCount = it-&gt;second;<br>            ans = it-&gt;first;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; maxCount &lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><section class="footnotes"><h2>参考</h2><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://book.douban.com/subject/30162908/">算法笔记上机训练实战指南</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1054 The Dominant Color</title>
    <link href="/2021/01/05/1054-The-Dominant-Color/"/>
    <url>/2021/01/05/1054-The-Dominant-Color/</url>
    
    <content type="html"><![CDATA[<h1 id="1054-The-Dominant-Color-20分"><a href="#1054-The-Dominant-Color-20分" class="headerlink" title="1054 The Dominant Color (20分)"></a><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805422639136768">1054 The Dominant Color (20分)</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/To7ZZS.png" alt="content"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本题目目的是要找到<strong>出现次数大于总数一半的那个数字</strong>。</p><ul><li>最简单的方法就是使用<code>map</code>，以每个值作为<code>key</code>，出现次数作为<code>value</code>。再找出<code>value</code>最大的<code>key</code>。见方法一。</li><li>因为题目要求过半数的值，因此可以采用<strong>两两不相同相互抵消的方法</strong>，最后剩下的那个数一定是超过半数的数字。设置一个<code>ans</code>来存储当前数字，<code>count</code>来计算当前数字的数量。如果遇到相同的数字，<code>count++</code>,否则<code>count--</code>。若<code>count==0</code>，则令<code>ans</code>等于新的值。见方法二。</li><li>❌也可以使用一个很大的数组来存储，但是使用数组会超时</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 找出最主要的颜色，即数量超过一半的</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; colors;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, m, num;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;m, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;num);<br>            <span class="hljs-keyword">if</span> (colors.find(num) != colors.end()) &#123;<br>                colors[num]++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                colors[num] = <span class="hljs-number">1</span>;<br>            &#125;<br><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>, max = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;::iterator it = colors.begin(); it != colors.end(); it++) &#123;<br>        <span class="hljs-keyword">if</span> (it-&gt;second &gt; max) &#123;<br>            k = it-&gt;first;<br>            max = it-&gt;second;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, k);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度</p><blockquote><p><code>map</code>的<code>find</code>时间复杂度是$O(logN)$,而遍历一遍<code>map</code>的时间复杂度是$O(N)$。因此总的时间复杂度是 $O(N*logN)$</p></blockquote><p>空间复杂度</p><blockquote><p>$O (N)$</p></blockquote><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 找出最主要的颜色，即数量超过一半的</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, m, ans = <span class="hljs-number">0</span>, count = <span class="hljs-number">1</span>, num;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;m, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;num);<br>            <span class="hljs-keyword">if</span> (ans == num) count++; <span class="hljs-comment">// 遇到相同的数字，则count++</span><br>            <span class="hljs-keyword">else</span> count--;<br>            <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 令ans等于新的值</span><br>                ans = num;<br>                count = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度</p><blockquote><p>$O(N)$</p></blockquote><p>空间复杂度</p><blockquote><p>$O(1)$</p></blockquote><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><blockquote><p>C++知识学习</p></blockquote><ul><li><code>map</code>遍历以及对key,value的访问</li></ul><p><code>map</code>使用迭代器进行遍历元素<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="算法笔记上机训练实战指南">[1]</span></a></sup></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;::iterator it;<br>it-&gt;first; <span class="hljs-comment">// 访问key</span><br>it-&gt;second; <span class="hljs-comment">// 访问value</span><br><span class="hljs-comment">// 遍历每个元素</span><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;::iterator it = mp.begin(); it != mp.end(); it++) &#123;<br><span class="hljs-keyword">int</span> key = it-&gt;first;<br><span class="hljs-keyword">int</span> value = it-&gt;second;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>map</code>判断<code>key</code>是否存在<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="C++(14):判断map中key值是否存在">[2]</span></a></sup></li></ul><p><strong>find函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">iterator <span class="hljs-title">find</span> <span class="hljs-params">( <span class="hljs-keyword">const</span> key_type&amp; key )</span></span>;<br></code></pre></td></tr></table></figure><p>如果key存在，则find返回key对应的迭代器，如果key不存在，则find返回尾后迭代器 .end()。可以参考下面的示例来判断key值是否存在</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span> (mp.find(key) == mp.end()) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;mp not has the key&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;mp has the key&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><section class="footnotes"><h2>参考</h2><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://book.douban.com/subject/30162908/">算法笔记上机训练实战指南</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://blog.csdn.net/Leo_csdn_/article/details/85066264">C++(14):判断map中key值是否存在</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1044 火星数字</title>
    <link href="/2021/01/04/1044-%E7%81%AB%E6%98%9F%E6%95%B0%E5%AD%97/"/>
    <url>/2021/01/04/1044-%E7%81%AB%E6%98%9F%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h1 id="1044-火星数字-20分"><a href="#1044-火星数字-20分" class="headerlink" title="1044 火星数字 (20分)"></a><a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805279328157696">1044 火星数字 (20分)</a></h1><blockquote><p>本文内容参考自《算法笔记-上机训练实战指南》<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="算法笔记上机训练实战指南">[1]</span></a></sup>，并添加上自己总结，容易出错部分。</p></blockquote><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>火星人是以 13 进制计数的：</p><ul><li>地球人的 0 被火星人称为 tret。</li><li>地球人数字 1 到 12 的火星文分别为：jan, feb, mar, apr, may, jun, jly, aug, sep, oct, nov, dec。</li><li>火星人将进位以后的 12 个高位数字分别称为：tam, hel, maa, huh, tou, kes, hei, elo, syy, lok, mer, jou。</li></ul><p>例如地球人的数字 <code>29</code> 翻译成火星文就是 <code>hel mar</code>；而火星文 <code>elo nov</code> 对应地球数字 <code>115</code>。为了方便交流，请你编写程序实现地球和火星数字之间的互译。</p><p>输入格式：<br>输入第一行给出一个正整数 $N（&lt;100）$，随后 $N$ 行，每行给出一个 $[0, 169)$ 区间内的数字 —— 或者是地球文，或者是火星文。</p><h2 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h2><p>对应输入的每一行，在一行中输出翻译后的另一种语言的数字。</p><blockquote><p>4</p><p>29</p><p>5</p><p>elo nov</p><p>tam</p></blockquote><h2 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h2><blockquote><p>hel mar</p><p>may</p><p>115</p><p>13</p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ul><li>因为输入的测试数据范围是$13*13=169$，所以可以考虑将所有数据都计算出来。</li><li>设置两个数组，一个是<code>n2s</code>，用来存储数字转化为字符串。</li><li>另一个数组 <code>s2n</code>，用来存储字符串转化为数字。</li></ul><p>预处理代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">string</span> unit[<span class="hljs-number">13</span>] = &#123;<br>    <span class="hljs-string">&quot;tret&quot;</span>, <span class="hljs-string">&quot;jan&quot;</span>, <span class="hljs-string">&quot;feb&quot;</span>, <span class="hljs-string">&quot;mar&quot;</span>, <span class="hljs-string">&quot;apr&quot;</span>, <span class="hljs-string">&quot;may&quot;</span>, <span class="hljs-string">&quot;jun&quot;</span>, <span class="hljs-string">&quot;jly&quot;</span>, <span class="hljs-string">&quot;aug&quot;</span>, <span class="hljs-string">&quot;sep&quot;</span>, <span class="hljs-string">&quot;oct&quot;</span>, <span class="hljs-string">&quot;nov&quot;</span>, <span class="hljs-string">&quot;dec&quot;</span><br>&#125;;<br><br><span class="hljs-built_in">string</span> ten[<span class="hljs-number">13</span>] = &#123;<br>    <span class="hljs-string">&quot;tret&quot;</span>, <span class="hljs-string">&quot;tam&quot;</span>, <span class="hljs-string">&quot;hel&quot;</span>, <span class="hljs-string">&quot;maa&quot;</span>, <span class="hljs-string">&quot;huh&quot;</span>, <span class="hljs-string">&quot;tou&quot;</span>, <span class="hljs-string">&quot;kes&quot;</span>, <span class="hljs-string">&quot;hei&quot;</span>, <span class="hljs-string">&quot;elo&quot;</span>, <span class="hljs-string">&quot;syy&quot;</span>, <span class="hljs-string">&quot;lok&quot;</span>, <span class="hljs-string">&quot;mer&quot;</span>, <span class="hljs-string">&quot;jou&quot;</span><br>&#125;;<br><br><span class="hljs-built_in">string</span> n2s[<span class="hljs-number">170</span>]; <span class="hljs-comment">// num-&gt;string</span><br><span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt; s2n; <span class="hljs-comment">// string -&gt; num</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">13</span>; i++) &#123;<br>        n2s[i] = unit[i]; <span class="hljs-comment">// 填充 0- 12</span><br>        n2s[i * <span class="hljs-number">13</span>] = ten[i]; <span class="hljs-comment">// 填充13的倍数</span><br>        s2n[unit[i]] = i; <span class="hljs-comment">// 填充 0-12</span><br>        s2n[ten[i]] = i * <span class="hljs-number">13</span>; <span class="hljs-comment">// 填充 13的倍数</span><br><br>    &#125;<br>    <span class="hljs-comment">// 接下来填充其他部分数据</span><br><span class="hljs-comment">// ⚠️需要从1开始，因为13倍数部分已经在上面被填充了</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">13</span>; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">13</span>; ++j) &#123;<br>            <span class="hljs-built_in">string</span> res = ten[i] + <span class="hljs-string">&quot; &quot;</span> + unit[j]; <span class="hljs-comment">// 组成新的字符串</span><br>            n2s[i * <span class="hljs-number">13</span> + j] = res;<br>            s2n[res] = i * <span class="hljs-number">13</span> + j;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-built_in">string</span> unit[<span class="hljs-number">13</span>] = &#123;<br>    <span class="hljs-string">&quot;tret&quot;</span>, <span class="hljs-string">&quot;jan&quot;</span>, <span class="hljs-string">&quot;feb&quot;</span>, <span class="hljs-string">&quot;mar&quot;</span>, <span class="hljs-string">&quot;apr&quot;</span>, <span class="hljs-string">&quot;may&quot;</span>, <span class="hljs-string">&quot;jun&quot;</span>, <span class="hljs-string">&quot;jly&quot;</span>, <span class="hljs-string">&quot;aug&quot;</span>, <span class="hljs-string">&quot;sep&quot;</span>, <span class="hljs-string">&quot;oct&quot;</span>, <span class="hljs-string">&quot;nov&quot;</span>, <span class="hljs-string">&quot;dec&quot;</span><br>&#125;;<br><br><span class="hljs-built_in">string</span> ten[<span class="hljs-number">13</span>] = &#123;<br>    <span class="hljs-string">&quot;tret&quot;</span>, <span class="hljs-string">&quot;tam&quot;</span>, <span class="hljs-string">&quot;hel&quot;</span>, <span class="hljs-string">&quot;maa&quot;</span>, <span class="hljs-string">&quot;huh&quot;</span>, <span class="hljs-string">&quot;tou&quot;</span>, <span class="hljs-string">&quot;kes&quot;</span>, <span class="hljs-string">&quot;hei&quot;</span>, <span class="hljs-string">&quot;elo&quot;</span>, <span class="hljs-string">&quot;syy&quot;</span>, <span class="hljs-string">&quot;lok&quot;</span>, <span class="hljs-string">&quot;mer&quot;</span>, <span class="hljs-string">&quot;jou&quot;</span><br>&#125;;<br><br><span class="hljs-built_in">string</span> n2s[<span class="hljs-number">170</span>]; <span class="hljs-comment">// num-&gt;string</span><br><span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt; s2n; <span class="hljs-comment">// string -&gt; num</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">13</span>; i++) &#123;<br>        n2s[i] = unit[i]; <span class="hljs-comment">// 填充 0- 12</span><br>        n2s[i * <span class="hljs-number">13</span>] = ten[i]; <span class="hljs-comment">// 填充13的倍数</span><br>        s2n[unit[i]] = i; <span class="hljs-comment">// 填充 0-12</span><br>        s2n[ten[i]] = i * <span class="hljs-number">13</span>; <span class="hljs-comment">// 填充 13的倍数</span><br><br>    &#125;<br>    <span class="hljs-comment">// 接下来填充其他部分数据</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">13</span>; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">13</span>; ++j) &#123;<br>            <span class="hljs-built_in">string</span> res = ten[i] + <span class="hljs-string">&quot; &quot;</span> + unit[j]; <span class="hljs-comment">// 组成新的字符串</span><br>            n2s[i * <span class="hljs-number">13</span> + j] = res;<br>            s2n[res] = i * <span class="hljs-number">13</span> + j;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    init();<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-built_in">cin</span>.get(); <span class="hljs-comment">// 需要吸收回车符号，不然使用getline的第一个字符是回车</span><br>    <span class="hljs-keyword">while</span> (n--) &#123;<br>        <span class="hljs-built_in">string</span> str;<br>        getline(<span class="hljs-built_in">cin</span>, str);<br>        <span class="hljs-comment">// fgets(str, 100, stdin);</span><br>        <span class="hljs-comment">// cin &gt;&gt; str;</span><br>        <span class="hljs-comment">// cout &lt;&lt; str &lt;&lt;endl;</span><br>        <span class="hljs-keyword">if</span> (str[<span class="hljs-number">0</span>] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; str[<span class="hljs-number">0</span>] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>            <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; str.length(); ++i)<br>            &#123;<br>                num = num * <span class="hljs-number">10</span> + (str[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>            &#125;<br>            <span class="hljs-comment">// printf(&quot;%d\n&quot;, num);</span><br>            <span class="hljs-comment">//printf(&quot;%s\n&quot;, n2s[num]);</span><br>            <span class="hljs-built_in">cout</span> &lt;&lt; n2s[num] &lt;&lt;<span class="hljs-built_in">endl</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//printf(&quot;%d\n&quot;, s2n[str]);</span><br>            <span class="hljs-built_in">cout</span> &lt;&lt; s2n[str] &lt;&lt;<span class="hljs-built_in">endl</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><blockquote><p>由于本人初次学习C++，在写代码的时候遇到几个语法问题</p></blockquote><ul><li>在输出<code>string</code>类型的变量时候，使用<code>printf(&quot;%s&quot;, str);</code>出现乱码，而需要使用<code>cout &lt;&lt; str &lt;&lt; endl;</code>。因为<code>printf</code>里面要求的是<code>*char</code>类型，而<code>string</code>与<code>*char</code>类型不一样。<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="c++ string问题 cout输出正常，printf输出乱码">[2]</span></a></sup></li><li>C++中，处理字符<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="C++ 输入函数getline(cin,str) 与cin.getline(str,int)区别">[3]</span></a></sup><ul><li>处理<code>string</code>使用<code>getline(cin,str)</code>.</li><li>处理<code>char[]</code>类型使用<code>cin.getline(char * , in)</code></li><li>⚠️ 在输入的时候，需要注意吸收字符<code>cin.get();//接受最后一个结束符</code></li></ul></li></ul><section class="footnotes"><h2>参考</h2><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://book.douban.com/subject/30162908/">算法笔记上机训练实战指南</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://blog.csdn.net/qinweixin/article/details/51743962">c++ string问题 cout输出正常，printf输出乱码</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://blog.csdn.net/xumengxing/article/details/6664436">C++ 输入函数getline(cin,str) 与cin.getline(str,int)区别</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
      <tag>C++</tag>
      
      <tag>map</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ArcGIS For JS 实现鹰眼图</title>
    <link href="/2021/01/04/ArcGIS-For-JS-%E5%AE%9E%E7%8E%B0%E9%B9%B0%E7%9C%BC%E5%9B%BE/"/>
    <url>/2021/01/04/ArcGIS-For-JS-%E5%AE%9E%E7%8E%B0%E9%B9%B0%E7%9C%BC%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="鹰眼图-概述图实现"><a href="#鹰眼图-概述图实现" class="headerlink" title="鹰眼图/概述图实现"></a>鹰眼图/概述图实现</h1><p><img src="https://cdn.jsdelivr.net/gh/emhui/oss@master/uPic/bPrbRu.png" alt="bPrbRu"></p><p>本例展示在3D场景中添加一个2D的鹰眼图/概述图。概述图展示当前所在的3D场景。使用<a href="https://developers.arcgis.com/javascript/latest/api-reference/esri-core-Accessor.html#watch">watch()</a>来实现2D概览图和3D场景图的同步。<a href="https://developers.arcgis.com/javascript/latest/sample-code/sandbox/index.html?sample=overview-map">具体案例</a>。</p><blockquote><p>有关watching属性的更多信息，可以查看<a href="https://developers.arcgis.com/javascript/latest/guide/programming-patterns/#properties">Working with properties</a></p></blockquote><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><ol><li>创建一个DIV，用来展示鹰眼图。</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;overviewDiv&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;extentDiv&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>为鹰眼图创建一个Map。</li><li>为鹰眼图创建一个MapView</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> overviewMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(&#123;<br>    basemap: <span class="hljs-string">&quot;topo&quot;</span><br>&#125;)<br><br><span class="hljs-keyword">var</span> mapView = <span class="hljs-keyword">new</span> MapView(&#123;<br>    contrain: <span class="hljs-string">&quot;overviewDIV&quot;</span>,<br>    map: overviewMap,<br>    constraints: &#123;<br>        rotationEnabled: <span class="hljs-literal">false</span><br>    &#125;<br>&#125;)<br><br><span class="hljs-comment">// 移除默认的MapVIew自带的控件,具体效果可看文末下面</span><br>mapView.ui.components = [];<br></code></pre></td></tr></table></figure><ol start="4"><li>创建一个灰色的矩形用来标示当前的位置，并添加到mapview中。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> extent3Dgraphic = <span class="hljs-keyword">new</span> Graphic(&#123;<br>    geometry: <span class="hljs-literal">null</span>,<br>    symbol: &#123;<br>      type: <span class="hljs-string">&quot;simple-fill&quot;</span>,<br>      color: [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.5</span>],<br>      outline: <span class="hljs-literal">null</span><br>    &#125;<br>  &#125;);<br>  mapView.graphics.add(extent3Dgraphic);<br></code></pre></td></tr></table></figure><ol start="5"><li><strong>重点：使用WatchUtils监听MainView的extent属性变化</strong></li></ol><p><strong>WatchUtils的用法</strong></p><p><code>watchUtils.init(obj, propertyName, callback)</code></p><p>具体代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript">watchUtils.init(mainView, <span class="hljs-string">&quot;extent&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">extent</span>) </span>&#123;<br><span class="hljs-comment">// 当3D场景静止的时候，mapView移动到视图的位置</span><br><span class="hljs-keyword">if</span> (mainView.stationary) &#123;<br>  mapView.goTo(&#123;<br>    center: mainView.center,<br>    scale:<br>      mainView.scale *<br>      <span class="hljs-number">2</span> *<br>      <span class="hljs-built_in">Math</span>.max(<br>        mainView.width / mapView.width,<br>        mainView.height / mapView.height<br>      )<br>  &#125;);<br>&#125;<br><br>extent3Dgraphic.geometry = extent;<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><strong>mapView.ui.components = []的作用</strong></p><p>如图，该语句作用是清空默认的组件</p><p><img src="https://cdn.jsdelivr.net/gh/emhui/oss@master/uPic/LmJOlG.png" alt="LmJOlG"></p><p><strong>Scale缩放算式</strong></p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs maxima">mainView.<span class="hljs-built_in">scale</span> * <span class="hljs-number">2</span> *<br>Math.<span class="hljs-built_in">max</span>(<br>mainView.<span class="hljs-built_in">width</span> / mapView.<span class="hljs-built_in">width</span>,<br>mainView.<span class="hljs-built_in">height</span> / mapView.<span class="hljs-built_in">height</span><br></code></pre></td></tr></table></figure><p><code>mapView.width/height</code> 是指当前显示区域的宽度和高度.</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">var</span> size = mainView.<span class="hljs-built_in">scale</span> *<br>Math.<span class="hljs-built_in">max</span>(<br>mainView.<span class="hljs-built_in">width</span> / mapView.<span class="hljs-built_in">width</span>,<br>mainView.<span class="hljs-built_in">height</span> / mapView.<span class="hljs-built_in">height</span>)<br></code></pre></td></tr></table></figure><p>令上面的算式=size，下面两张图是size*1、2的效果。 可见其实size *1的效果已经不错了，但是 *2 效果可以更好。</p><p>*<em>size * 1*</em></p><p><img src="https://cdn.jsdelivr.net/gh/emhui/oss@master/uPic/wgFEZq.png" alt="wgFEZq"></p><p>*<em>size * 2*</em></p><p><img src="https://cdn.jsdelivr.net/gh/emhui/oss@master/uPic/sfffrS.png" alt="sfffrS"></p><p><a href="https://developers.arcgis.com/javascript/latest/sample-code/sandbox/index.html?sample=overview-map">Overview Sample</a></p><h3 id="2D和3D同步切换"><a href="#2D和3D同步切换" class="headerlink" title="2D和3D同步切换"></a>2D和3D同步切换</h3><p><img src="https://cdn.jsdelivr.net/gh/emhui/oss@master/uPic/Y3EIi3.png" alt="Y3EIi3"></p><p><a href="https://developers.arcgis.com/javascript/latest/sample-code/sandbox/index.html?sample=views-synchronize">views-synchronize</a></p><h4 id="代码讲解"><a href="#代码讲解" class="headerlink" title="代码讲解"></a>代码讲解</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>  &lt;head&gt;<br>    &lt;meta charset=<span class="hljs-string">&quot;utf-8&quot;</span> /&gt;<br>    &lt;meta<br>      name=<span class="hljs-string">&quot;viewport&quot;</span><br>      content=<span class="hljs-string">&quot;initial-scale=1,maximum-scale=1,user-scalable=no&quot;</span><br>    /&gt;<br>    &lt;title&gt;Synchronize MapView and SceneView - <span class="hljs-number">4.14</span>&lt;/title&gt;<br><br>    &lt;style&gt;<br>      html,<br>      body &#123;<br>        padding: <span class="hljs-number">0</span>;<br>        margin: <span class="hljs-number">0</span>;<br>        height: <span class="hljs-number">100</span>%;<br>      &#125;<br>    &lt;/style&gt;<br><br>    &lt;link<br>      rel=<span class="hljs-string">&quot;stylesheet&quot;</span><br>      href=<span class="hljs-string">&quot;https://js.arcgis.com/4.14/esri/themes/light/main.css&quot;</span><br>    /&gt;<br>    &lt;script src=<span class="hljs-string">&quot;https://js.arcgis.com/4.14/&quot;</span>&gt;&lt;/script&gt;<br><br>    &lt;script&gt;<br>      <span class="hljs-built_in">require</span>([<br>        <span class="hljs-string">&quot;esri/Map&quot;</span>,<br>        <span class="hljs-string">&quot;esri/views/MapView&quot;</span>,<br>        <span class="hljs-string">&quot;esri/views/SceneView&quot;</span>,<br>        <span class="hljs-string">&quot;esri/core/watchUtils&quot;</span><br>      ], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">Map</span>, MapView, SceneView, watchUtils</span>) </span>&#123;<br>        <span class="hljs-keyword">var</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(&#123;<br>          basemap: <span class="hljs-string">&quot;satellite&quot;</span><br>        &#125;);<br><br>        <span class="hljs-keyword">var</span> view1 = <span class="hljs-keyword">new</span> SceneView(&#123;<br>          id: <span class="hljs-string">&quot;view1&quot;</span>,<br>          container: <span class="hljs-string">&quot;view1Div&quot;</span>,<br>          map: map<br>        &#125;);<br><br>        <span class="hljs-keyword">var</span> view2 = <span class="hljs-keyword">new</span> MapView(&#123;<br>          id: <span class="hljs-string">&quot;view2&quot;</span>,<br>          container: <span class="hljs-string">&quot;view2Div&quot;</span>,<br>          map: map,<br>          constraints: &#123;<br>            <span class="hljs-comment">// Disable zoom snapping to get the best synchronization</span><br>            snapToZoom: <span class="hljs-literal">false</span><br>          &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * utility method that synchronizes the viewpoint of a view to other views</span><br><span class="hljs-comment">         * 同步视图</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">var</span> synchronizeView = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">view, others</span>) </span>&#123;<br>          others = <span class="hljs-built_in">Array</span>.isArray(others) ? others : [others];<br><br>          <span class="hljs-keyword">var</span> viewpointWatchHandle;<br>          <span class="hljs-keyword">var</span> viewStationaryHandle;<br>          <span class="hljs-keyword">var</span> otherInteractHandlers;<br>          <span class="hljs-keyword">var</span> scheduleId;<br><br>          <span class="hljs-keyword">var</span> clear = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-keyword">if</span> (otherInteractHandlers) &#123;<br>              otherInteractHandlers.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">handle</span>) </span>&#123;<br>                handle.remove();<br>              &#125;);<br>            &#125;<br>            <span class="hljs-comment">// 这是什么意思?</span><br>            <span class="hljs-comment">// viewpointWatchHandle 和 viewStatioaryHandle 对象是WatchHandle对象，其中有一个remove对象方法。用来清空监听属性</span><br>            viewpointWatchHandle &amp;&amp; viewpointWatchHandle.remove();<br>            viewStationaryHandle &amp;&amp; viewStationaryHandle.remove();<br>            scheduleId &amp;&amp; <span class="hljs-built_in">clearTimeout</span>(scheduleId);<br>            otherInteractHandlers = viewpointWatchHandle = viewStationaryHandle = scheduleId = <span class="hljs-literal">null</span>;<br>          &#125;;<br><br>            <span class="hljs-comment">// 监听当前控制视图的 交互和动画属性</span><br>          <span class="hljs-keyword">var</span> interactWatcher = view.watch(<span class="hljs-string">&quot;interacting,animation&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">            newValue</span></span><br><span class="hljs-function"><span class="hljs-params">          </span>) </span>&#123;<br>            <span class="hljs-keyword">if</span> (!newValue) &#123;<br>              <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (viewpointWatchHandle || scheduleId) &#123;<br>              <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 开始更新其他视图</span><br>            scheduleId = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>              scheduleId = <span class="hljs-literal">null</span>;<br>              <span class="hljs-comment">// 监听当前view的视点属性</span><br>              viewpointWatchHandle = view.watch(<span class="hljs-string">&quot;viewpoint&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">                newValue</span></span><br><span class="hljs-function"><span class="hljs-params">              </span>) </span>&#123;<br>                <span class="hljs-comment">// 根据新获取的视点，其他视图也同时更新它的视点</span><br>                others.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">otherView</span>) </span>&#123;<br>                  otherView.viewpoint = newValue;<br>                &#125;);<br>              &#125;);<br>            &#125;, <span class="hljs-number">0</span>);<br><br>            <span class="hljs-comment">// stop as soon as another view starts interacting, like if the user starts panning</span><br>            <span class="hljs-comment">// 如果移动其他视图，则销毁当前视图的所有变量</span><br>            otherInteractHandlers = others.map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">otherView</span>) </span>&#123;<br>              <span class="hljs-keyword">return</span> watchUtils.watch(<br>                otherView,<br>                <span class="hljs-string">&quot;interacting,animation&quot;</span>,<br>                <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>&#123;<br>                  <span class="hljs-keyword">if</span> (value) &#123;<br>                    clear();<br>                  &#125;<br>                &#125;<br>              );<br>            &#125;);<br><br>            <span class="hljs-comment">// or stop when the view is stationary again</span><br>            <span class="hljs-comment">// 当不再和视图进行交互时候，即 stationary 状态，则也注销所有变量</span><br>            <span class="hljs-comment">// 当监听的属性为True的时候执行</span><br>            viewStationaryHandle = watchUtils.whenTrue(<br>              view,<br>              <span class="hljs-string">&quot;stationary&quot;</span>,<br>              clear<br>            );<br>          &#125;);<br><br>          <span class="hljs-keyword">return</span> &#123;<br>            remove: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>              <span class="hljs-built_in">this</span>.remove = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;<br>              clear();<br>              interactWatcher.remove();<br>            &#125;<br>          &#125;;<br>        &#125;;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 同步多个View的视点</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">var</span> synchronizeViews = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">views</span>) </span>&#123;<br>        <span class="hljs-comment">/* array.map(function(currentValue,index,arr), thisValue)</span><br><span class="hljs-comment">        * 遍历所有的view</span><br><span class="hljs-comment">        * views.concat() 对当前对views进行复制一份</span><br><span class="hljs-comment">        * handles 存储一系列的同步事件</span><br><span class="hljs-comment">        */</span><br>          <span class="hljs-keyword">var</span> handles = views.map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">view, idx, views</span>) </span>&#123;<br>            <span class="hljs-keyword">var</span> others = views.concat(); <span class="hljs-comment">// 复制一份views</span><br>            others.splice(idx, <span class="hljs-number">1</span>); <span class="hljs-comment">// 删除当前视图，其他视图则是others</span><br>            <span class="hljs-keyword">return</span> synchronizeView(view, others); <span class="hljs-comment">//</span><br>          &#125;);<br><br>          <span class="hljs-keyword">return</span> &#123;<br>            remove: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>              <span class="hljs-built_in">this</span>.remove = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;<br>              handles.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">h</span>) </span>&#123;<br>                h.remove();<br>              &#125;);<br>              handles = <span class="hljs-literal">null</span>;<br>            &#125;<br>          &#125;;<br>        &#125;;<br><br>        <span class="hljs-comment">// 绑定两个视图</span><br>        synchronizeViews([view1, view2]);<br>      &#125;);<br>    &lt;/script&gt;<br>  &lt;/head&gt;<br>  &lt;body&gt;<br>    &lt;div id=<span class="hljs-string">&quot;view1Div&quot;</span> style=<span class="hljs-string">&quot;float: left; width: 50%; height: 100%;&quot;</span>&gt;&lt;/div&gt;<br>    &lt;div id=<span class="hljs-string">&quot;view2Div&quot;</span> style=<span class="hljs-string">&quot;float: left; width: 50%; height: 100%;&quot;</span>&gt;&lt;/div&gt;<br>  &lt;/body&gt;<br>&lt;/html&gt;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ArcGIS For JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ArcGIS For JS</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ceisum实现铁路仿真</title>
    <link href="/2021/01/03/Ceisum%E5%AE%9E%E7%8E%B0%E9%93%81%E8%B7%AF%E4%BB%BF%E7%9C%9F/"/>
    <url>/2021/01/03/Ceisum%E5%AE%9E%E7%8E%B0%E9%93%81%E8%B7%AF%E4%BB%BF%E7%9C%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="铁路模拟仿真实现"><a href="#铁路模拟仿真实现" class="headerlink" title="铁路模拟仿真实现"></a>铁路模拟仿真实现</h1><p>实现效果</p><p><img src="https://cdn.jsdelivr.net/gh/emhui/oss@master/uPic/lxieypx;.gif" alt="train"></p><p>内容比较多，只讲部分内容，可能有点乱。可以参考一下代码，有不懂的欢迎提问</p><h1 id="初始化变量"><a href="#初始化变量" class="headerlink" title="初始化变量"></a>初始化变量</h1><p>这些变量下面都会用到</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 运动车厢的速度</span><br><span class="hljs-keyword">let</span> velocity = <span class="hljs-number">30</span> <span class="hljs-comment">// 速度,根据他来计算到达各个点的时间</span><br><span class="hljs-comment">// 当前目标点的位置</span><br><span class="hljs-comment">// var currentIndex = 1</span><br><br><span class="hljs-comment">// 每节车厢相对上一节车厢延时一定时间到达同一个位置</span><br><span class="hljs-keyword">var</span> delayTime = <span class="hljs-number">13</span><br><br><span class="hljs-comment">// 存储所有运动中的实体对象</span><br><span class="hljs-keyword">var</span> dynamicEntities = []<br><br><span class="hljs-comment">// 运动模型数量</span><br><span class="hljs-keyword">var</span> dynamicNum = <span class="hljs-number">5</span><br><br><span class="hljs-comment">// 每节铁轨的长度，用于计算两个点之前铺设多少节铁轨</span><br><span class="hljs-keyword">var</span> modelLength = <span class="hljs-number">170</span><br><br><span class="hljs-comment">// 初始化dynamicEntitye</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; dynamicNum ; ++i) &#123;<br>    <span class="hljs-keyword">let</span> obj = &#123;<br>        entity: <span class="hljs-literal">null</span>, <span class="hljs-comment">// 实体对象</span><br>        property: <span class="hljs-keyword">new</span> Cesium.SampledPositionProperty(), <span class="hljs-comment">// 动态位置属性</span><br>        timeAndOrientationList: [],<br>        startTime: <span class="hljs-number">0</span>,<br>        endTime: <span class="hljs-number">0</span><br>    &#125;<br>    dynamicEntities.push(obj)<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="加载线路并获取位置"><a href="#加载线路并获取位置" class="headerlink" title="加载线路并获取位置"></a>加载线路并获取位置</h1><p>我们需要有一系列点路径坐标（火车运行的路径）。这里我从Google Eearth中绘制了一条线，然后导出为KML数据加载进来。</p><p><img src="https://cdn.jsdelivr.net/gh/emhui/oss@master/uPic/7MbzTG.png" alt="Google earth"></p><p>通过加载的这条路径，我们需要获取路径中每个转折点的坐标信息。通过这些转折点，我们可以完成<strong>设置铁轨位置</strong>和<strong>计算出模型实体每个时间点对应点位置</strong></p><p><strong>加载KML</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-comment">// 初始化路径 设置带时间的路径</span><br>viewer.dataSources.add(Cesium.KmlDataSource.load(routerUrl,<br>    &#123;<br>        camera: viewer.scene.camera,<br>        canvas: viewer.scene.canvas,<br>        clampToGround: <span class="hljs-literal">true</span><br>    &#125;)<br>).then(<span class="hljs-function"><span class="hljs-params">dataSource</span> =&gt;</span> &#123;<br><span class="hljs-comment">// ... 加载好后获取改路径点坐标数组</span><br>    <span class="hljs-keyword">var</span> router = dataSource.entities.getById(<span class="hljs-string">&#x27;0129AA13ED12D2857AD0&#x27;</span>);<br>    <span class="hljs-keyword">var</span> positions = router.polyline.positions._value<br>    viewer.flyTo(router)<br>    <span class="hljs-comment">// createDynamicPositions(positions) // 计算带时间的路径</span><br>    <span class="hljs-comment">// createDynamicEntity() // 根据动态路径创建模型实体</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>首先我们加载好路线后，就要获取改路线的坐标数组（每个转折点或顶点的位置）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 获取路径对象</span><br><span class="hljs-keyword">var</span> router = dataSource.entities.getById(<span class="hljs-string">&#x27;0129AA13ED12D2857AD0&#x27;</span>);<br><span class="hljs-comment">// 获取对象中的坐标数组</span><br><span class="hljs-keyword">var</span> positions = router.polyline.positions._value<br></code></pre></td></tr></table></figure><p>我们可以看一下这些数组的内容</p><p><img src="https://cdn.jsdelivr.net/gh/emhui/oss@master/uPic/IoR5O3.png" alt="IoR5O3"></p><p>在这里可以看出来，这些坐标全是笛卡尔类型。同时可以知道我们总共有13个转折点</p><p>接下来两章是重点</p><h1 id="加载铁轨"><a href="#加载铁轨" class="headerlink" title="加载铁轨"></a>加载铁轨</h1><p>效果展示</p><p><img src="https://cdn.jsdelivr.net/gh/emhui/oss@master/uPic/Kkx93r.png" alt="Kkx93r"></p><p>实现上面效果，这里我们需要做下面几步。</p><ul><li>计算每段路（两个点）之间的距离S</li><li>设置每个铁轨的固定长度L</li><li>计算每段路可以铺设多少个模型 num = S / L</li><li>通过每段路两端的点的坐标，计算出这段中每个铁轨模型的位置</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-comment">// 这个是每个模型的长度，在一开始的时候就定义了</span><br><span class="hljs-comment">// var modelLength = 170</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">repeateModel</span>(<span class="hljs-params">posCart1, posCart2</span>) </span>&#123;<br>    <span class="hljs-comment">// 需要摆放模型的数量</span><br>    <span class="hljs-comment">// 模型的数量 = 两个点之间的长度 / 每个模型的长度</span><br>    <span class="hljs-keyword">let</span> modelNum = <span class="hljs-built_in">parseInt</span>(computeDistance(posCart1, posCart2) / modelLength)<br>    <span class="hljs-comment">// 根据两个点的经纬度调整每个模型的方向</span><br>    <span class="hljs-keyword">let</span> heading = computeOrientation(posCart1, posCart2)<br>    <span class="hljs-comment">// 开始计算每个模型的位置</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; modelNum; ++i) &#123;<br>    <span class="hljs-comment">// 求第i个点的位置。下面有介绍为什么这样写</span><br>        <span class="hljs-keyword">var</span> mid = <span class="hljs-keyword">new</span> Cesium.Cartesian3()<br>        Cesium.Cartesian3.add(<br>            Cesium.Cartesian3.multiplyByScalar(posCart1, i / modelNum, <span class="hljs-keyword">new</span> Cesium.Cartesian3()),<br>            Cesium.Cartesian3.multiplyByScalar(posCart2, (modelNum - i) / modelNum, <span class="hljs-keyword">new</span> Cesium.Cartesian3()),<br>            mid<br>        )<br><span class="hljs-comment">// 计算出位置后，添加铁轨模型到Viewer中。同时调整模型的方向</span><br>        viewer.entities.add(&#123;<br>            position: mid,<br>            model: &#123;<br>                uri: modelRailwayUrl,<br>                scale: <span class="hljs-number">0.025</span><br>            &#125;,<br>            orientation: changeOrientation(mid, heading)<br>        &#125;)<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>两个坐标之前第i的位置如何求</strong></p><p>先看一下下面的一道数学题</p><p><img src="https://cdn.jsdelivr.net/gh/emhui/oss@master/uPic/bJgWdB.png" alt="bJgWdB"></p><p>通过这道题，我们就可以写出下面代码，求出第i个点的位置了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">Cesium.Cartesian3.add(<br>    Cesium.Cartesian3.multiplyByScalar(posCart1, i / modelNum, <span class="hljs-keyword">new</span> Cesium.Cartesian3()),<br>    Cesium.Cartesian3.multiplyByScalar(posCart2, (modelNum - i) / modelNum, <span class="hljs-keyword">new</span> Cesium.Cartesian3()),<br>    mid<br>)<br></code></pre></td></tr></table></figure><p><strong>模型方向问题</strong></p><p>在上面代码中。我们经常要用到一个计算模型方向和改变模型方向的函数，那么为什么要计算模型的方向呢？</p><p>我们打开铁轨模型和系统自带的一些模型。看看他们的方向</p><p>使用下面命令调出查看方向的小工具</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">viewer.extend(Cesium.viewerCesiumInspectorMixin);<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/emhui/oss@master/uPic/EUBOGy.png" alt="EUBOGy"></p><p>可以看到，我们的模型的方向默认位置是朝向南方（红色是东方，绿色是北方）。而官网的模型方向默认是东方。根据官方对模型的描述</p><blockquote><p>By default, the model is oriented upright and facing east. Control the orientation of the model by specifying a Quaternion for the Entity.orientation property. This controls the heading, pitch, and roll of the model.</p></blockquote><p>可以看到，我们的模型方向是有问题。因此需要手动纠正。查阅很多方法，无法从模型本身入手。所以只能通过代码的方式来纠正方向。大概的思路是先计算出两个点的方向，然后在向东方偏移90度左右即可。</p><p><strong>计算方向函数</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">computeOrientation</span>(<span class="hljs-params">posCart1, posCart2</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> heading = bearing(<br>        Cesium.Cartographic.fromCartesian(posCart1).latitude,<br>        Cesium.Cartographic.fromCartesian(posCart1).longitude,<br>        Cesium.Cartographic.fromCartesian(posCart2).latitude,<br>        Cesium.Cartographic.fromCartesian(posCart2).longitude<br>    )<br>    <span class="hljs-keyword">return</span> heading<br>&#125;<br>        <span class="hljs-comment">// 计算两点之间的方向</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bearing</span>(<span class="hljs-params">startLat, startLng, destLat, destLng</span>) </span>&#123;<br>    startLat = Cesium.Math.toRadians(startLat);<br>    startLng = Cesium.Math.toRadians(startLng);<br>    destLat = Cesium.Math.toRadians(destLat);<br>    destLng = Cesium.Math.toRadians(destLng);<br><br>    <span class="hljs-keyword">let</span> y = <span class="hljs-built_in">Math</span>.sin(destLng - startLng) * <span class="hljs-built_in">Math</span>.cos(destLat);<br>    <span class="hljs-keyword">let</span> x = <span class="hljs-built_in">Math</span>.cos(startLat) * <span class="hljs-built_in">Math</span>.sin(destLat) - <span class="hljs-built_in">Math</span>.sin(startLat) * <span class="hljs-built_in">Math</span>.cos(destLat) * <span class="hljs-built_in">Math</span>.cos(destLng - startLng);<br>    <span class="hljs-keyword">let</span> brng = <span class="hljs-built_in">Math</span>.atan2(y, x);<br>    <span class="hljs-keyword">let</span> brngDgr = Cesium.Math.toDegrees(brng);<br>    <span class="hljs-keyword">return</span> (brngDgr + <span class="hljs-number">360</span>) % <span class="hljs-number">360</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>改变模型的位置</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">changeOrientation</span>(<span class="hljs-params">position, degree</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> heading = Cesium.Math.toRadians(degree);<br>    <span class="hljs-keyword">var</span> pitch = Cesium.Math.toRadians(<span class="hljs-number">0.0</span>);<br>    <span class="hljs-keyword">var</span> roll = Cesium.Math.toRadians(<span class="hljs-number">0.0</span>);<br>    <span class="hljs-keyword">var</span> orientation = Cesium.Transforms.headingPitchRollQuaternion(position, <span class="hljs-keyword">new</span> Cesium.HeadingPitchRoll(heading, pitch, roll));<br>    <span class="hljs-keyword">return</span> orientation<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="加载运动的车头和车厢"><a href="#加载运动的车头和车厢" class="headerlink" title="加载运动的车头和车厢"></a>加载运动的车头和车厢</h1><p>这里我们需要了解一个知识。<a href="https://www.jianshu.com/p/f0b47997224c">Cesium的Property机制总结</a>.<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="Cesium的Property机制总结">[1]</span></a></sup>这篇文章中，我们可以看到一个属性<code>SampledPositionProperty</code>,它可以使用物体的运动。</p><p><img src="https://upload-images.jianshu.io/upload_images/80648-366b91d38f419afa.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/296/format/webp" alt="move"></p><p>它的实现代码如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> property = <span class="hljs-keyword">new</span> Cesium.SampledPositionProperty();<br><br>property.addSample(Cesium.JulianDate.fromIso8601(<span class="hljs-string">&#x27;2019-01-01T00:00:00.00Z&#x27;</span>),<br>    Cesium.Cartesian3.fromDegrees(-<span class="hljs-number">114.0</span>, <span class="hljs-number">40.0</span>, <span class="hljs-number">300000.0</span>));<br><br>property.addSample(Cesium.JulianDate.fromIso8601(<span class="hljs-string">&#x27;2019-01-03T00:00:00.00Z&#x27;</span>),<br>    Cesium.Cartesian3.fromDegrees(-<span class="hljs-number">114.0</span>, <span class="hljs-number">45.0</span>, <span class="hljs-number">300000.0</span>));<br><br>blueBox.position = property;<br></code></pre></td></tr></table></figure><p>它的原理是，Entity在不同的时间运动到不同的位置。因此我们的火车运动也是一样，在不同的时候运动到不同的位置即可。那么如何实现呢？</p><p>还是通过之前获取的铁轨路径数组，再计算到达每个转折点的时间。构成一个如下图所示的数据结构。</p><p><img src="https://cdn.jsdelivr.net/gh/emhui/oss@master/uPic/XzFZ1f.png" alt="XzFZ1f"></p><p>如何让模型运动起来也可以总结为下面这张图</p><p><img src="https://cdn.jsdelivr.net/gh/emhui/oss@master/uPic/Eg6FPk.png" alt="Eg6FPk"></p><p>比如4点的时候在position1位置，4.30的时候在position2位置。4.50的时候在position3位置。</p><p>那么现在时间点应该如何计算</p><p>我们设置一个速度变量V，然后计算两点的距离S。那么到达下一个的时间就是</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">time</span> = S / V<br></code></pre></td></tr></table></figure><p>因此实现代码如下（伪代码）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 计算到下一个坐标所花费的时间</span><br><span class="hljs-keyword">let</span> time2Next = computeTime(datas[index], datas[index + <span class="hljs-number">1</span>])<br><span class="hljs-comment">// 计算到达改点的时刻</span><br><span class="hljs-keyword">let</span> time = totalTime + time2Next<br><span class="hljs-comment">// 将时刻+位置信息写入到模型的位置变量中</span><br>dynamicEntity.property.addSample(<br>    Cesium.JulianDate.addSeconds(start, time, <span class="hljs-keyword">new</span> Cesium.JulianDate()),<br>    position<br>)<br><span class="hljs-comment">// 计算总花费时间</span><br>totalTime += time2Next<br><br></code></pre></td></tr></table></figure><p>这里又有新的问题。</p><p>我们需要好几节车厢一起运动，如何实现呢？</p><p>使用延时启动，就是每一个车厢到达一个转折点的时间都比上一节车厢晚一段时间。如下图所示，不同的车厢在不同的时间点的位置不一样。</p><p><img src="https://cdn.jsdelivr.net/gh/emhui/oss@master/uPic/Lp33qj.png" alt="Lp33qj"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> time = totalTime + delayTime * i<br></code></pre></td></tr></table></figure><p>我们看一下实现效果,车厢是一节在一节的后面出现的</p><p><img src="https://cdn.jsdelivr.net/gh/emhui/oss@master/uPic/lxiemjmjiuxm.gif" alt="train"></p><p>通过代码实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createDynamicPositions</span>(<span class="hljs-params">positions</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> length = positions.length<br>    <span class="hljs-keyword">var</span> totalTime = <span class="hljs-number">0</span><span class="hljs-comment">// 跑完全部路程的时间</span><br>    <span class="hljs-comment">// 遍历铁轨路径的每个转折点</span><br>    positions.forEach(<span class="hljs-function">(<span class="hljs-params">position, index, datas</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">// 在每个路径转角处创建一个Point对象</span><br>        CreatePoint(position, index)<br>        <span class="hljs-keyword">if</span> (index + <span class="hljs-number">1</span> &lt; length) &#123;<br>            <span class="hljs-comment">// 计算一个点到另一点需要到时间</span><br>            <span class="hljs-keyword">let</span> time2Next = computeTime(datas[index], datas[index + <span class="hljs-number">1</span>])<br>            <span class="hljs-comment">// 计算两个转角点的方向</span><br>            <span class="hljs-keyword">let</span> orientation = computeOrientation(datas[index], datas[index + <span class="hljs-number">1</span>])<br>            <span class="hljs-comment">// 为每个车厢模型设置 时间+位置</span><br>            dynamicEntities.forEach(<span class="hljs-function">(<span class="hljs-params">dynamicEntity, i</span>) =&gt;</span> &#123;<br>            <span class="hljs-comment">// 这里实现了 每个模型都相对于之前都个模型延时一定时间进行启动</span><br>                <span class="hljs-keyword">let</span> time = totalTime + delayTime * i<br>                dynamicEntity.property.addSample(<br>                    Cesium.JulianDate.addSeconds(start, time, <span class="hljs-keyword">new</span> Cesium.JulianDate()),<br>                    position<br>                )<br>                <span class="hljs-comment">// 记录每个模型分别达到一个点的时间、方向、位置</span><br>                <span class="hljs-keyword">let</span> obj = &#123;<br>                    time: totalTime, <span class="hljs-comment">// 到达下一个点需要耗费的时间,它是一个数值，不是一个时间点</span><br>                    position: position,<br>                    orientation: orientation<br>                &#125;<br><br>                <span class="hljs-comment">// 计算开始时间</span><br>                <span class="hljs-keyword">if</span> (index === <span class="hljs-number">0</span>) &#123;<br>                    dynamicEntity.startTime = Cesium.JulianDate.addSeconds(start, time, <span class="hljs-keyword">new</span> Cesium.JulianDate())<br>                &#125;<br><br>                <span class="hljs-comment">// 计算最后一个时间</span><br>                <span class="hljs-keyword">if</span> (index + <span class="hljs-number">2</span> === length) &#123;<br>                    dynamicEntity.endTime = Cesium.JulianDate.addSeconds(start, time, <span class="hljs-keyword">new</span> Cesium.JulianDate())<br>                &#125;<br>                <span class="hljs-comment">// 将计算得到的 时间+位置 属性存储到每个实体中</span><br>                dynamicEntity.timeAndOrientationList.push(obj)<br><br>            &#125;)<br><br>            totalTime += time2Next<br><br>        &#125;<br>    &#125;);<br></code></pre></td></tr></table></figure><p>这里我们发现我们也计算了每个模型的方向，为什么要计算方向呢？在上面设置铁轨的时候讲到了，因为我们的模型方向默认是有点问题的。默认朝向南方，因此需要手动调整方向，我们需要自己写一个方法，判断到了转角处进行转向。（如果是模型默认朝向东方的话，则不需要使用该方法，直接使用自带的一种方法，具体方法后面再谈）</p><p>如何实现到了转角处自动转向呢？我们在刚刚上一步的时候记录了每个模型到达某个位置的时候是在是什么时间点。因此只需要判断，当前模型运行的时间是否到了转角的时间点，到了的话就开始转向，而这个方向我们同时也在上一步的时候存储到每个实体中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;<br>    time: totalTime, <span class="hljs-comment">// 到达下一个点需要耗费的时间,它是一个数值，不是一个时间点</span><br>    position: position,<br>    orientation: orientation<br>&#125;<br></code></pre></td></tr></table></figure><p>监听当前时间点并转向的代码如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript">viewer.clock.onTick.addEventListener(<span class="hljs-function">(<span class="hljs-params">clock</span>) =&gt;</span> &#123;<br><span class="hljs-comment">// 判断每个运动的模型当前是否到了转向时间</span><br>    dynamicEntities.forEach(<span class="hljs-function"><span class="hljs-params">dynamicEntity</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 计算每个运动的模型与模型的开始时间差</span><br>        <span class="hljs-keyword">let</span> timeOffset = Cesium.JulianDate.secondsDifference(clock.currentTime, dynamicEntity.startTime);<br>        <span class="hljs-comment">// 判断是否达到转向的时间点</span><br>        dynamicEntity.timeAndOrientationList.forEach(<span class="hljs-function">(<span class="hljs-params">obj, index, array</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (timeOffset &gt;= obj.time &amp;&amp; timeOffset &lt;= array[index + <span class="hljs-number">1</span>].time) &#123;<br>                <span class="hljs-comment">// 177在第一条铁轨是一个好的角度</span><br>                dynamicEntity.entity.orientation = changeOrientation(obj.position, obj.orientation + <span class="hljs-number">180</span>)<br>            &#125;<br>        &#125;)<br>    &#125;)<br></code></pre></td></tr></table></figure><p>如果模型的方向是正确的，只需要在创建模型实体对象的时候，指定该属性即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">orientation: <span class="hljs-keyword">new</span> Cesium.VelocityOrientationProperty(dynamicEntity.property),<br></code></pre></td></tr></table></figure><p>目前还有下面问题暂时无法解决</p><ul><li>各个模型之间的衔接不好</li></ul><blockquote><p>经过测试如果模型的方向是正确的话，那么就可以解决这个问题。所以可以从模型入手，更改模型的默认方向，使它默认朝向东方，但是自己一直没有找到如何编辑GLB模型。所以暂时无解。</p></blockquote><section class="footnotes"><h2>参考</h2><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.jianshu.com/p/f0b47997224c">Cesium的Property机制总结</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Cesium</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Cesium</tag>
      
      <tag>铁路</tag>
      
      <tag>仿真</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo注意事项</title>
    <link href="/2021/01/03/hexo%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <url>/2021/01/03/hexo%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<p><code>hexo clean &amp;&amp; hexo d</code></p><p><del>如果使用这个命令，可能会清除<strong>CNAME</strong>文件</del></p><p>保持永久域名的方法</p><p>在<code>/source</code>目录下面建立一个文件<code>CNAME</code>,然后填入你的域名即可。<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="脚注">[1]</span></a></sup></p><h2 id="hexow文件管理-lt-span-class-”hint–top-hint–rounded”-aria-label-”hexo博客文章多了怎么管理"><a href="#hexow文件管理-lt-span-class-”hint–top-hint–rounded”-aria-label-”hexo博客文章多了怎么管理" class="headerlink" title="hexow文件管理&lt;span class=”hint–top hint–rounded” aria-label=”hexo博客文章多了怎么管理"></a>hexow文件管理<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote">&lt;span class=”hint–top hint–rounded” aria-label=”hexo博客文章多了怎么管理</h2><p>“&gt;[2]</span></a></sup></p><p>默认情况下使用<code>hexo new &quot;title&quot;</code>，所有文章都存放在<code>/source/_post</code>下面。随着文章的数量变多，该目录下面都文件也会越来越多，所以我们可以将文件进行归类。</p><ul><li>自己指定文章目录</li></ul><p><a href="https://hexo.io/zh-cn/docs/commands#new">官方</a>使用下面命令可以在创建文件的同时并归类。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new [layout] &lt;title&gt;<br></code></pre></td></tr></table></figure><p>比如我要创建一个文件<code>hexo new -p 其他/&quot;hexo 搭建blog&quot;.md &quot;hexo 搭建blog&quot;</code>,这样会在<code>_post</code>下面创建一个<code>其他</code>的目录，并且目录的名字是<code>heox 搭建blog.md</code>.但是这种方式非常繁琐。</p><ul><li>通过年月日管理文件</li></ul><p>因此使用第二种方式，在<code>_config.yml</code>中设置</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-symbol">new_post_name:</span> <span class="hljs-symbol">:year/</span><span class="hljs-symbol">:month/</span><span class="hljs-symbol">:title</span>.md<br></code></pre></td></tr></table></figure><p>通过这样的设置，仍使用之前创建文件的命令</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;hexo文件管理&quot;</span><br></code></pre></td></tr></table></figure><p>运行该命令则会在创建一个以当前年月为子目录的结构。如图所示</p><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/TNJnDw.png" alt="TNJnDw"></p><blockquote><p>如果之前已经建立好的文件想按照时间归类可以直接把文件拖到对应目录</p></blockquote><p>总结：可以看到第二种方法比第一种简单，且按照时间管理文件也比较方便。</p><h2 id="hexo-fluid-首页和文章等页面实现每天更换壁纸"><a href="#hexo-fluid-首页和文章等页面实现每天更换壁纸" class="headerlink" title="hexo.fluid 首页和文章等页面实现每天更换壁纸"></a>hexo.fluid 首页和文章等页面实现每天更换壁纸</h2><ol><li>首先在网上找到必应壁纸的接口<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="巨硬(必应)每日壁纸接口">[3]</span></a></sup>，网上有很多。</li><li>找到接口地址后，在<code>hexo.fluid</code>的配置中。修改这个地址</li></ol><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-attr">banner_img:</span> <span class="hljs-attr">https:</span><span class="hljs-comment">//static.zkqiang.cn/example.jpg</span><br></code></pre></td></tr></table></figure><h2 id="hexo-fluid-首页每次刷新显示不同的诗句"><a href="#hexo-fluid-首页每次刷新显示不同的诗句" class="headerlink" title="hexo.fluid 首页每次刷新显示不同的诗句"></a>hexo.fluid 首页每次刷新显示不同的诗句</h2><ol><li>参考<a href="https://www.jinrishici.com/">今日诗词</a>,通过<code>F12</code>获取其每次刷新的诗句接口。</li><li>在<code>hexo.fluid</code>的配置文件中，配置<code>slogan</code><sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="hexo.fluid配置">[4]</span></a></sup></li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">index:</span><br>  <span class="hljs-attr">slogan:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">text:</span> <span class="hljs-string">这是一条</span> <span class="hljs-string">Slogan</span><br>    <span class="hljs-attr">api:</span><br>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><br>      <span class="hljs-attr">url:</span> <span class="hljs-string">&quot;https://v1.hitokoto.cn/&quot;</span><br>      <span class="hljs-attr">method:</span> <span class="hljs-string">&quot;GET&quot;</span><br>      <span class="hljs-attr">headers:</span> &#123;&#125;<br>      <span class="hljs-attr">keys:</span> [<span class="hljs-string">&quot;hitokoto&quot;</span>]<br></code></pre></td></tr></table></figure><p>url: API 地址，必须返回的是一个 JSON 格式</p><p>method: 请求方法，可选 GET、POST、PUT</p><p>headers: 请求头，如果接口需要传一些验证的头部信息，在这里设置</p><p>keys: 从请求结果获取字符串的取值字段，程序会根据列表中的字段依次取值，最终需要获得到一个字符串</p><h2 id="使用hexo-admin管理后台-lt-span-class-”hint–top-hint–rounded”-aria-label-”hexo-admin-issue"><a href="#使用hexo-admin管理后台-lt-span-class-”hint–top-hint–rounded”-aria-label-”hexo-admin-issue" class="headerlink" title="使用hexo-admin管理后台 &lt;span class=”hint–top hint–rounded” aria-label=”hexo-admin issue"></a>使用hexo-admin管理后台 <sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote">&lt;span class=”hint–top hint–rounded” aria-label=”hexo-admin issue</h2><p>“&gt;[5]</span></a></sup></p><p>安装方法见<a href="https://github.com/jaredly/hexo-admin">hexo-admin</a>.<br>这里主要是看一下如何配置<code>hexo-admin</code>的文件</p><ul><li><code>hexo-admin</code>配置</li><li><code>hexo-admin</code>部署</li></ul><p><code>hexo-admin</code>只能在<code>_config.yml</code>中配置</p><p><code>hexo-admin</code>部署，需要配置<code>deployCommand</code>.</p><ol><li>首先在根目录创建一个文件<code>deploy.sh</code>，然后更<strong>改它的权限</strong>,这一步很重要，如果没有更改权限。<code>hexo-admin</code>无法执行该命令<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">$ touch <span class="hljs-keyword">deploy</span>.sh; chmod a+x <span class="hljs-keyword">deploy</span>.sh<br></code></pre></td></tr></table></figure></li></ol><p>接着在文件中写入下面的脚本，或者你可以自己定义脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/usr/bin/env sh</span><br>hexo deploy<br>and edit _config.yml:<br></code></pre></td></tr></table></figure><p>最后在<code>_config.yml</code>中配置<code>deployCommand</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">admin:<br>  deployCommand: &#x27;./hexo-deploy.sh&#x27;<br></code></pre></td></tr></table></figure><section class="footnotes"><h2>参考</h2><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://hexo.fluid-dev.com/docs/guide/#%E8%84%9A%E6%B3%A8">脚注</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://www.pianshen.com/article/81511649508/">hexo博客文章多了怎么管理</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://atlinker.cn/2019/07/28/bing.html">巨硬(必应)每日壁纸接口</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://hexo.fluid-dev.com/docs/guide/#slogan-%E6%89%93%E5%AD%97%E6%9C%BA">hexo.fluid配置</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><a href="https://github.com/jaredly/hexo-admin/issues/70">hexo-admin issue</a><a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>域名</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
