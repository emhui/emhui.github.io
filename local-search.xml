<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>1051 Pop Sequence</title>
    <link href="/2021/01/07/1051-Pop-Sequence/"/>
    <url>/2021/01/07/1051-Pop-Sequence/</url>
    
    <content type="html"><![CDATA[<h1 id="1051-Pop-Sequence-25分"><a href="#1051-Pop-Sequence-25分" class="headerlink" title="1051 Pop Sequence (25分)"></a>1051 Pop Sequence (25分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/18Xskb.png" alt="18Xskb"></p><p>本题给定一个大小为$M$的栈，然后有一堆有序序列$1,2,3,4,5…N$依次入栈出栈。给定$K$个出栈序列，判断这几个出栈序列是否合法。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>建立一个栈，模拟$1 ~ N$进栈的过程，在这个过程中，将进栈的元素（<strong>栈顶元素</strong>）与当前<strong>出栈序列</strong>中的元素进行对比。若相等，则弹出栈顶，同时<strong>出栈序列</strong>往后移一位，继续此操作，直到有不相等的元素时，再让下一个元素进栈。</p><ol><li>建立一个初始的栈，该栈在每次输入前需要清空。</li><li>设置一个变量<code>flag</code>，若当前入栈后，栈的大小超过了<code>M</code>，则直接<code>flag = false;</code>然后跳出♻️。</li><li>接下然反复判断栈顶元素和当前第<code>idx</code>个<strong>出栈序列</strong>是否一样，若一样，执行弹出操作和<code>idx++</code></li><li>最后当栈为空且<code>flag=true</code>的时候输出<code>YES</code>,否则输出<code>No</code></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1001</span>;<br><span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; st;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> arr[maxn], m, n, k;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;m, &amp;n, &amp;k);<br>    <span class="hljs-keyword">while</span> (k--) &#123;<br>        <span class="hljs-keyword">while</span> (!st.empty()) &#123;st.pop();&#125; <span class="hljs-comment">// 每次都要清空栈</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;arr[i]);<br>        &#125;<br>        <span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>; <span class="hljs-comment">// 输出数组的下标</span><br>        <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            st.push(i + <span class="hljs-number">1</span>); <span class="hljs-comment">// 把数字i+1压入栈</span><br>            <span class="hljs-keyword">if</span> (st.size() &gt; m) &#123;<br>                flag = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (!st.empty() &amp;&amp; st.top() == arr[idx]) &#123;<br>                st.pop();<br>                idx++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (st.empty() &amp;&amp; flag) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;YES\n&quot;</span>);&#125;<br>        <span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NO\n&quot;</span>);&#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度分析</p><ul><li>时间复杂度：$O(n+m)$</li><li>空间复杂度: $O(max(m,n))$</li></ul>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法， 栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>547. Number of Provinces</title>
    <link href="/2021/01/07/547-Number-of-Provinces/"/>
    <url>/2021/01/07/547-Number-of-Provinces/</url>
    
    <content type="html"><![CDATA[<h1 id="547-Number-of-Provinces"><a href="#547-Number-of-Provinces" class="headerlink" title="547. Number of Provinces"></a><a href="https://leetcode-cn.com/problems/number-of-provinces/">547. Number of Provinces</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><div class="note note-warning">            <p>难度：中等</p>          </div><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/xmxR4o.png" alt="xmxR4o"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本题转化为图，其大概意思就是是<strong>给出一个用邻接矩阵表示的无向图，找出连通分量的数量</strong>。</p><p>解决问题的方法主要有三种方法</p><ol><li><ul><li><input checked="" disabled="" type="checkbox"> DFS</li></ul></li><li><ul><li><input checked="" disabled="" type="checkbox"> BFS</li></ul></li><li><ul><li><input disabled="" type="checkbox"> union-ﬁnd</li></ul></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p><strong>Python</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findCircleNum</span>(<span class="hljs-params">self, isConnected: List[List[<span class="hljs-built_in">int</span>]]</span>) -&gt; int:</span><br>        <span class="hljs-comment"># 求连通图的数量</span><br>        size = <span class="hljs-built_in">len</span>(isConnected)<br>        visited = [<span class="hljs-literal">False</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(size)]<br>        count = <span class="hljs-number">0</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">isConnected, idx</span>):</span><br>            visited[idx] = <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(size):<br>                <span class="hljs-keyword">if</span> isConnected[idx][i] == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> visited[i]:<br>                    dfs(isConnected, i)<br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(size):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> visited[i]:<br>                dfs(isConnected, i)<br>                count += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> count<br></code></pre></td></tr></table></figure><p><strong>C++</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findCircleNum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; isConnected)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> size = isConnected.size();<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(size, <span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (!visited[i]) &#123;<br>                dfs(isConnected, i, visited, size);<br>                count++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; isConnected, <span class="hljs-keyword">int</span> idx, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&amp; visited, <span class="hljs-keyword">int</span> size)</span> </span>&#123;<br>        visited[idx] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            <span class="hljs-keyword">if</span> (isConnected[idx][i] == <span class="hljs-number">1</span> &amp;&amp; !visited[i]) &#123;<br>                dfs(isConnected, i, visited, size);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度: $O(n^2)$,这里需要对矩阵进行遍历。</li><li>空间复杂度: $O(n)$, 使用<code>visited</code>存储<code>n</code>个城市是否被访问。</li></ul><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p><strong>C++</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python">class Solution &#123;<br>public:<br>    <span class="hljs-built_in">int</span> findCircleNum(vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt;&amp; isConnected) &#123;<br>        <span class="hljs-built_in">int</span> size = isConnected.size();<br>        <span class="hljs-built_in">int</span> count = <span class="hljs-number">0</span>;<br>        vector&lt;<span class="hljs-built_in">bool</span>&gt; visited(size, false);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (!visited[i]) &#123;<br>                bfs(isConnected, i, visited, size);<br>                count++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>    <br><br>    void bfs(vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt;&amp; isConnected, <span class="hljs-built_in">int</span> idx, vector&lt;<span class="hljs-built_in">bool</span>&gt;&amp; visited, <span class="hljs-built_in">int</span> size) &#123;<br>        visited[idx] = true;<br>        queue&lt;<span class="hljs-built_in">int</span>&gt; q;<br>        q.push(idx);<br>        <span class="hljs-keyword">while</span> (!q.empty()) &#123;<br>            <span class="hljs-built_in">int</span> node = q.front();<br>            q.pop();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                <span class="hljs-keyword">if</span> (isConnected[node][i] == <span class="hljs-number">1</span> &amp;&amp; !visited[i]) &#123;<br>                    visited[i] = true;<br>                    q.push(i);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>从上面可以看到，<code>BFS</code>和<code>DFS</code>的写法，只有计算连通分量的时候不一样，其他都是一样的。</p><p>复杂度分析</p><ul><li>时间复杂度：$O(n^2)$，遍历整个矩阵</li><li>空间复杂度: $O(n)$.visited大小的空间</li></ul>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>bfs</tag>
      
      <tag>dfs</tag>
      
      <tag>leetcode</tag>
      
      <tag>union-find</tag>
      
      <tag>图</tag>
      
      <tag>无向图</tag>
      
      <tag>邻接矩阵</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1071 Speech Patterns</title>
    <link href="/2021/01/05/1071-Speech-Patterns/"/>
    <url>/2021/01/05/1071-Speech-Patterns/</url>
    
    <content type="html"><![CDATA[<h1 id="1071-Speech-Patterns-25分"><a href="#1071-Speech-Patterns-25分" class="headerlink" title="1071 Speech Patterns (25分)"></a>1071 Speech Patterns (25分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/dMgnxy.png" alt="dMgnxy"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本题目的是<strong>在一句话中，找到出现次数最多的有效单词</strong>。有效单词的定义是：包含<code>[0-9 a-z A-Z]</code>。因此本题分两步。</p><ul><li>分割出有效单词。大写字符要转成小写字母，无效字符使用<code>while</code>过滤。</li><li>使用<code>map</code>统计有效单词出现次数。</li><li>⚠️题目要求如果两个单词的数量一样，则输出字典上小的那个单词。而<code>C++</code>中<strong>map会以键从小到大的顺序自动排序</strong><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="算法笔记上机训练实战指南">[1]</span></a></sup>。所以下面这个关键代码对比的时候，使用<code>it-&gt;second &gt; macCount</code>就可以求出字典上小的那个单词。如果要求出字典顺序最大的那个单词，只需要<code>it-&gt;second &gt;= maxCount</code>就可以。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (<span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt;::iterator it = mp.begin(); it != mp.end(); ++it) &#123;<br><span class="hljs-keyword">if</span> (it-&gt;second &gt; maxCount) &#123;<br>maxCount = it-&gt;second;<br>ans = it-&gt;first;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 1. 分割字符串</span><br><span class="hljs-comment">// 2. 找出最大的值</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isVaildChar</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (c &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (c &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;z&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (c &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt; mp; <span class="hljs-comment">// 统计字符的数量</span><br>    <span class="hljs-built_in">string</span> str, ans;<br>    getline(<span class="hljs-built_in">cin</span>, str);<br>    <span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>, size = str.length(), maxCount = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (idx &lt; size) &#123; <span class="hljs-comment">// 开始分割字符串</span><br>        <span class="hljs-built_in">string</span> word;<br>        <span class="hljs-comment">// 1. 判断当前字符是否有效</span><br>        <span class="hljs-keyword">while</span> (idx &lt; size &amp;&amp; isVaildChar(str[idx])) &#123; <span class="hljs-comment">// 如果该字符有效</span><br>            <span class="hljs-keyword">if</span> (str[idx] &gt;=<span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; str[idx] &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>) &#123;str[idx] += <span class="hljs-number">32</span>;&#125;<br>            word += str[idx];<br>            idx++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (word != <span class="hljs-string">&quot;&quot;</span>) &#123; <span class="hljs-comment">// 如果该字符不是空的，就加入到map中</span><br>            <span class="hljs-keyword">if</span> (mp.find(word) != mp.end()) &#123;mp[word]++;&#125;<br>            <span class="hljs-keyword">else</span> &#123;mp[word] = <span class="hljs-number">1</span>;&#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (idx &lt; size &amp;&amp; !isVaildChar(str[idx])) &#123;idx++;&#125; <span class="hljs-comment">// 排除无效字符</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt;::iterator it = mp.begin(); it != mp.end(); ++it) &#123;<br>        <span class="hljs-keyword">if</span> (it-&gt;second &gt; maxCount) &#123;<br>            maxCount = it-&gt;second;<br>            ans = it-&gt;first;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; maxCount &lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><section class="footnotes"><h2>参考</h2><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://book.douban.com/subject/30162908/">算法笔记上机训练实战指南</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>C++</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1054 The Dominant Color</title>
    <link href="/2021/01/05/1054-The-Dominant-Color/"/>
    <url>/2021/01/05/1054-The-Dominant-Color/</url>
    
    <content type="html"><![CDATA[<h1 id="1054-The-Dominant-Color-20分"><a href="#1054-The-Dominant-Color-20分" class="headerlink" title="1054 The Dominant Color (20分)"></a><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805422639136768">1054 The Dominant Color (20分)</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/To7ZZS.png" alt="content"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本题目目的是要找到<strong>出现次数大于总数一半的那个数字</strong>。</p><ul><li>最简单的方法就是使用<code>map</code>，以每个值作为<code>key</code>，出现次数作为<code>value</code>。再找出<code>value</code>最大的<code>key</code>。见方法一。</li><li>因为题目要求过半数的值，因此可以采用<strong>两两不相同相互抵消的方法</strong>，最后剩下的那个数一定是超过半数的数字。设置一个<code>ans</code>来存储当前数字，<code>count</code>来计算当前数字的数量。如果遇到相同的数字，<code>count++</code>,否则<code>count--</code>。若<code>count==0</code>，则令<code>ans</code>等于新的值。见方法二。</li><li>❌也可以使用一个很大的数组来存储，但是使用数组会超时</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 找出最主要的颜色，即数量超过一半的</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; colors;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, m, num;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;m, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;num);<br>            <span class="hljs-keyword">if</span> (colors.find(num) != colors.end()) &#123;<br>                colors[num]++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                colors[num] = <span class="hljs-number">1</span>;<br>            &#125;<br><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>, max = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;::iterator it = colors.begin(); it != colors.end(); it++) &#123;<br>        <span class="hljs-keyword">if</span> (it-&gt;second &gt; max) &#123;<br>            k = it-&gt;first;<br>            max = it-&gt;second;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, k);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度</p><blockquote><p><code>map</code>的<code>find</code>时间复杂度是$O(logN)$,而遍历一遍<code>map</code>的时间复杂度是$O(N)$。因此总的时间复杂度是 $O(N*logN)$</p></blockquote><p>空间复杂度</p><blockquote><p>$O (N)$</p></blockquote><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 找出最主要的颜色，即数量超过一半的</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, m, ans = <span class="hljs-number">0</span>, count = <span class="hljs-number">1</span>, num;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;m, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;num);<br>            <span class="hljs-keyword">if</span> (ans == num) count++; <span class="hljs-comment">// 遇到相同的数字，则count++</span><br>            <span class="hljs-keyword">else</span> count--;<br>            <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 令ans等于新的值</span><br>                ans = num;<br>                count = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度</p><blockquote><p>$O(N)$</p></blockquote><p>空间复杂度</p><blockquote><p>$O(1)$</p></blockquote><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><blockquote><p>C++知识学习</p></blockquote><ul><li><code>map</code>遍历以及对key,value的访问</li></ul><p><code>map</code>使用迭代器进行遍历元素<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="算法笔记上机训练实战指南">[1]</span></a></sup></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;::iterator it;<br>it-&gt;first; <span class="hljs-comment">// 访问key</span><br>it-&gt;second; <span class="hljs-comment">// 访问value</span><br><span class="hljs-comment">// 遍历每个元素</span><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;::iterator it = mp.begin(); it != mp.end(); it++) &#123;<br><span class="hljs-keyword">int</span> key = it-&gt;first;<br><span class="hljs-keyword">int</span> value = it-&gt;second;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>map</code>判断<code>key</code>是否存在<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="C++(14):判断map中key值是否存在">[2]</span></a></sup></li></ul><p><strong>find函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">iterator <span class="hljs-title">find</span> <span class="hljs-params">( <span class="hljs-keyword">const</span> key_type&amp; key )</span></span>;<br></code></pre></td></tr></table></figure><p>如果key存在，则find返回key对应的迭代器，如果key不存在，则find返回尾后迭代器 .end()。可以参考下面的示例来判断key值是否存在</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span> (mp.find(key) == mp.end()) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;mp not has the key&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;mp has the key&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><section class="footnotes"><h2>参考</h2><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://book.douban.com/subject/30162908/">算法笔记上机训练实战指南</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://blog.csdn.net/Leo_csdn_/article/details/85066264">C++(14):判断map中key值是否存在</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>C++</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1044 火星数字</title>
    <link href="/2021/01/04/1044-%E7%81%AB%E6%98%9F%E6%95%B0%E5%AD%97/"/>
    <url>/2021/01/04/1044-%E7%81%AB%E6%98%9F%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h1 id="1044-火星数字-20分"><a href="#1044-火星数字-20分" class="headerlink" title="1044 火星数字 (20分)"></a><a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805279328157696">1044 火星数字 (20分)</a></h1><blockquote><p>本文内容参考自《算法笔记-上机训练实战指南》<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="算法笔记上机训练实战指南">[1]</span></a></sup>，并添加上自己总结，容易出错部分。</p></blockquote><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>火星人是以 13 进制计数的：</p><ul><li>地球人的 0 被火星人称为 tret。</li><li>地球人数字 1 到 12 的火星文分别为：jan, feb, mar, apr, may, jun, jly, aug, sep, oct, nov, dec。</li><li>火星人将进位以后的 12 个高位数字分别称为：tam, hel, maa, huh, tou, kes, hei, elo, syy, lok, mer, jou。</li></ul><p>例如地球人的数字 <code>29</code> 翻译成火星文就是 <code>hel mar</code>；而火星文 <code>elo nov</code> 对应地球数字 <code>115</code>。为了方便交流，请你编写程序实现地球和火星数字之间的互译。</p><p>输入格式：<br>输入第一行给出一个正整数 $N（&lt;100）$，随后 $N$ 行，每行给出一个 $[0, 169)$ 区间内的数字 —— 或者是地球文，或者是火星文。</p><h2 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h2><p>对应输入的每一行，在一行中输出翻译后的另一种语言的数字。</p><blockquote><p>4</p><p>29</p><p>5</p><p>elo nov</p><p>tam</p></blockquote><h2 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h2><blockquote><p>hel mar</p><p>may</p><p>115</p><p>13</p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ul><li>因为输入的测试数据范围是$13*13=169$，所以可以考虑将所有数据都计算出来。</li><li>设置两个数组，一个是<code>n2s</code>，用来存储数字转化为字符串。</li><li>另一个数组 <code>s2n</code>，用来存储字符串转化为数字。</li></ul><p>预处理代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">string</span> unit[<span class="hljs-number">13</span>] = &#123;<br>    <span class="hljs-string">&quot;tret&quot;</span>, <span class="hljs-string">&quot;jan&quot;</span>, <span class="hljs-string">&quot;feb&quot;</span>, <span class="hljs-string">&quot;mar&quot;</span>, <span class="hljs-string">&quot;apr&quot;</span>, <span class="hljs-string">&quot;may&quot;</span>, <span class="hljs-string">&quot;jun&quot;</span>, <span class="hljs-string">&quot;jly&quot;</span>, <span class="hljs-string">&quot;aug&quot;</span>, <span class="hljs-string">&quot;sep&quot;</span>, <span class="hljs-string">&quot;oct&quot;</span>, <span class="hljs-string">&quot;nov&quot;</span>, <span class="hljs-string">&quot;dec&quot;</span><br>&#125;;<br><br><span class="hljs-built_in">string</span> ten[<span class="hljs-number">13</span>] = &#123;<br>    <span class="hljs-string">&quot;tret&quot;</span>, <span class="hljs-string">&quot;tam&quot;</span>, <span class="hljs-string">&quot;hel&quot;</span>, <span class="hljs-string">&quot;maa&quot;</span>, <span class="hljs-string">&quot;huh&quot;</span>, <span class="hljs-string">&quot;tou&quot;</span>, <span class="hljs-string">&quot;kes&quot;</span>, <span class="hljs-string">&quot;hei&quot;</span>, <span class="hljs-string">&quot;elo&quot;</span>, <span class="hljs-string">&quot;syy&quot;</span>, <span class="hljs-string">&quot;lok&quot;</span>, <span class="hljs-string">&quot;mer&quot;</span>, <span class="hljs-string">&quot;jou&quot;</span><br>&#125;;<br><br><span class="hljs-built_in">string</span> n2s[<span class="hljs-number">170</span>]; <span class="hljs-comment">// num-&gt;string</span><br><span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt; s2n; <span class="hljs-comment">// string -&gt; num</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">13</span>; i++) &#123;<br>        n2s[i] = unit[i]; <span class="hljs-comment">// 填充 0- 12</span><br>        n2s[i * <span class="hljs-number">13</span>] = ten[i]; <span class="hljs-comment">// 填充13的倍数</span><br>        s2n[unit[i]] = i; <span class="hljs-comment">// 填充 0-12</span><br>        s2n[ten[i]] = i * <span class="hljs-number">13</span>; <span class="hljs-comment">// 填充 13的倍数</span><br><br>    &#125;<br>    <span class="hljs-comment">// 接下来填充其他部分数据</span><br><span class="hljs-comment">// ⚠️需要从1开始，因为13倍数部分已经在上面被填充了</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">13</span>; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">13</span>; ++j) &#123;<br>            <span class="hljs-built_in">string</span> res = ten[i] + <span class="hljs-string">&quot; &quot;</span> + unit[j]; <span class="hljs-comment">// 组成新的字符串</span><br>            n2s[i * <span class="hljs-number">13</span> + j] = res;<br>            s2n[res] = i * <span class="hljs-number">13</span> + j;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-built_in">string</span> unit[<span class="hljs-number">13</span>] = &#123;<br>    <span class="hljs-string">&quot;tret&quot;</span>, <span class="hljs-string">&quot;jan&quot;</span>, <span class="hljs-string">&quot;feb&quot;</span>, <span class="hljs-string">&quot;mar&quot;</span>, <span class="hljs-string">&quot;apr&quot;</span>, <span class="hljs-string">&quot;may&quot;</span>, <span class="hljs-string">&quot;jun&quot;</span>, <span class="hljs-string">&quot;jly&quot;</span>, <span class="hljs-string">&quot;aug&quot;</span>, <span class="hljs-string">&quot;sep&quot;</span>, <span class="hljs-string">&quot;oct&quot;</span>, <span class="hljs-string">&quot;nov&quot;</span>, <span class="hljs-string">&quot;dec&quot;</span><br>&#125;;<br><br><span class="hljs-built_in">string</span> ten[<span class="hljs-number">13</span>] = &#123;<br>    <span class="hljs-string">&quot;tret&quot;</span>, <span class="hljs-string">&quot;tam&quot;</span>, <span class="hljs-string">&quot;hel&quot;</span>, <span class="hljs-string">&quot;maa&quot;</span>, <span class="hljs-string">&quot;huh&quot;</span>, <span class="hljs-string">&quot;tou&quot;</span>, <span class="hljs-string">&quot;kes&quot;</span>, <span class="hljs-string">&quot;hei&quot;</span>, <span class="hljs-string">&quot;elo&quot;</span>, <span class="hljs-string">&quot;syy&quot;</span>, <span class="hljs-string">&quot;lok&quot;</span>, <span class="hljs-string">&quot;mer&quot;</span>, <span class="hljs-string">&quot;jou&quot;</span><br>&#125;;<br><br><span class="hljs-built_in">string</span> n2s[<span class="hljs-number">170</span>]; <span class="hljs-comment">// num-&gt;string</span><br><span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt; s2n; <span class="hljs-comment">// string -&gt; num</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">13</span>; i++) &#123;<br>        n2s[i] = unit[i]; <span class="hljs-comment">// 填充 0- 12</span><br>        n2s[i * <span class="hljs-number">13</span>] = ten[i]; <span class="hljs-comment">// 填充13的倍数</span><br>        s2n[unit[i]] = i; <span class="hljs-comment">// 填充 0-12</span><br>        s2n[ten[i]] = i * <span class="hljs-number">13</span>; <span class="hljs-comment">// 填充 13的倍数</span><br><br>    &#125;<br>    <span class="hljs-comment">// 接下来填充其他部分数据</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">13</span>; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">13</span>; ++j) &#123;<br>            <span class="hljs-built_in">string</span> res = ten[i] + <span class="hljs-string">&quot; &quot;</span> + unit[j]; <span class="hljs-comment">// 组成新的字符串</span><br>            n2s[i * <span class="hljs-number">13</span> + j] = res;<br>            s2n[res] = i * <span class="hljs-number">13</span> + j;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    init();<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-built_in">cin</span>.get(); <span class="hljs-comment">// 需要吸收回车符号，不然使用getline的第一个字符是回车</span><br>    <span class="hljs-keyword">while</span> (n--) &#123;<br>        <span class="hljs-built_in">string</span> str;<br>        getline(<span class="hljs-built_in">cin</span>, str);<br>        <span class="hljs-comment">// fgets(str, 100, stdin);</span><br>        <span class="hljs-comment">// cin &gt;&gt; str;</span><br>        <span class="hljs-comment">// cout &lt;&lt; str &lt;&lt;endl;</span><br>        <span class="hljs-keyword">if</span> (str[<span class="hljs-number">0</span>] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; str[<span class="hljs-number">0</span>] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>            <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; str.length(); ++i)<br>            &#123;<br>                num = num * <span class="hljs-number">10</span> + (str[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>            &#125;<br>            <span class="hljs-comment">// printf(&quot;%d\n&quot;, num);</span><br>            <span class="hljs-comment">//printf(&quot;%s\n&quot;, n2s[num]);</span><br>            <span class="hljs-built_in">cout</span> &lt;&lt; n2s[num] &lt;&lt;<span class="hljs-built_in">endl</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//printf(&quot;%d\n&quot;, s2n[str]);</span><br>            <span class="hljs-built_in">cout</span> &lt;&lt; s2n[str] &lt;&lt;<span class="hljs-built_in">endl</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><blockquote><p>由于本人初次学习C++，在写代码的时候遇到几个语法问题</p></blockquote><ul><li>在输出<code>string</code>类型的变量时候，使用<code>printf(&quot;%s&quot;, str);</code>出现乱码，而需要使用<code>cout &lt;&lt; str &lt;&lt; endl;</code>。因为<code>printf</code>里面要求的是<code>*char</code>类型，而<code>string</code>与<code>*char</code>类型不一样。<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="c++ string问题 cout输出正常，printf输出乱码">[2]</span></a></sup></li><li>C++中，处理字符<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="C++ 输入函数getline(cin,str) 与cin.getline(str,int)区别">[3]</span></a></sup><ul><li>处理<code>string</code>使用<code>getline(cin,str)</code>.</li><li>处理<code>char[]</code>类型使用<code>cin.getline(char * , in)</code></li><li>⚠️ 在输入的时候，需要注意吸收字符<code>cin.get();//接受最后一个结束符</code></li></ul></li></ul><section class="footnotes"><h2>参考</h2><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://book.douban.com/subject/30162908/">算法笔记上机训练实战指南</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://blog.csdn.net/qinweixin/article/details/51743962">c++ string问题 cout输出正常，printf输出乱码</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://blog.csdn.net/xumengxing/article/details/6664436">C++ 输入函数getline(cin,str) 与cin.getline(str,int)区别</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>C++</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ArcGIS For JS 实现鹰眼图</title>
    <link href="/2021/01/04/ArcGIS-For-JS-%E5%AE%9E%E7%8E%B0%E9%B9%B0%E7%9C%BC%E5%9B%BE/"/>
    <url>/2021/01/04/ArcGIS-For-JS-%E5%AE%9E%E7%8E%B0%E9%B9%B0%E7%9C%BC%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="鹰眼图-概述图实现"><a href="#鹰眼图-概述图实现" class="headerlink" title="鹰眼图/概述图实现"></a>鹰眼图/概述图实现</h1><p><img src="https://cdn.jsdelivr.net/gh/emhui/oss@master/uPic/bPrbRu.png" alt="bPrbRu"></p><p>本例展示在3D场景中添加一个2D的鹰眼图/概述图。概述图展示当前所在的3D场景。使用<a href="https://developers.arcgis.com/javascript/latest/api-reference/esri-core-Accessor.html#watch">watch()</a>来实现2D概览图和3D场景图的同步。<a href="https://developers.arcgis.com/javascript/latest/sample-code/sandbox/index.html?sample=overview-map">具体案例</a>。</p><blockquote><p>有关watching属性的更多信息，可以查看<a href="https://developers.arcgis.com/javascript/latest/guide/programming-patterns/#properties">Working with properties</a></p></blockquote><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><ol><li>创建一个DIV，用来展示鹰眼图。</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;overviewDiv&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;extentDiv&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>为鹰眼图创建一个Map。</li><li>为鹰眼图创建一个MapView</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> overviewMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(&#123;<br>    basemap: <span class="hljs-string">&quot;topo&quot;</span><br>&#125;)<br><br><span class="hljs-keyword">var</span> mapView = <span class="hljs-keyword">new</span> MapView(&#123;<br>    contrain: <span class="hljs-string">&quot;overviewDIV&quot;</span>,<br>    map: overviewMap,<br>    constraints: &#123;<br>        rotationEnabled: <span class="hljs-literal">false</span><br>    &#125;<br>&#125;)<br><br><span class="hljs-comment">// 移除默认的MapVIew自带的控件,具体效果可看文末下面</span><br>mapView.ui.components = [];<br></code></pre></td></tr></table></figure><ol start="4"><li>创建一个灰色的矩形用来标示当前的位置，并添加到mapview中。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> extent3Dgraphic = <span class="hljs-keyword">new</span> Graphic(&#123;<br>    geometry: <span class="hljs-literal">null</span>,<br>    symbol: &#123;<br>      type: <span class="hljs-string">&quot;simple-fill&quot;</span>,<br>      color: [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.5</span>],<br>      outline: <span class="hljs-literal">null</span><br>    &#125;<br>  &#125;);<br>  mapView.graphics.add(extent3Dgraphic);<br></code></pre></td></tr></table></figure><ol start="5"><li><strong>重点：使用WatchUtils监听MainView的extent属性变化</strong></li></ol><p><strong>WatchUtils的用法</strong></p><p><code>watchUtils.init(obj, propertyName, callback)</code></p><p>具体代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript">watchUtils.init(mainView, <span class="hljs-string">&quot;extent&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">extent</span>) </span>&#123;<br><span class="hljs-comment">// 当3D场景静止的时候，mapView移动到视图的位置</span><br><span class="hljs-keyword">if</span> (mainView.stationary) &#123;<br>  mapView.goTo(&#123;<br>    center: mainView.center,<br>    scale:<br>      mainView.scale *<br>      <span class="hljs-number">2</span> *<br>      <span class="hljs-built_in">Math</span>.max(<br>        mainView.width / mapView.width,<br>        mainView.height / mapView.height<br>      )<br>  &#125;);<br>&#125;<br><br>extent3Dgraphic.geometry = extent;<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><strong>mapView.ui.components = []的作用</strong></p><p>如图，该语句作用是清空默认的组件</p><p><img src="https://cdn.jsdelivr.net/gh/emhui/oss@master/uPic/LmJOlG.png" alt="LmJOlG"></p><p><strong>Scale缩放算式</strong></p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs maxima">mainView.<span class="hljs-built_in">scale</span> * <span class="hljs-number">2</span> *<br>Math.<span class="hljs-built_in">max</span>(<br>mainView.<span class="hljs-built_in">width</span> / mapView.<span class="hljs-built_in">width</span>,<br>mainView.<span class="hljs-built_in">height</span> / mapView.<span class="hljs-built_in">height</span><br></code></pre></td></tr></table></figure><p><code>mapView.width/height</code> 是指当前显示区域的宽度和高度.</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">var</span> size = mainView.<span class="hljs-built_in">scale</span> *<br>Math.<span class="hljs-built_in">max</span>(<br>mainView.<span class="hljs-built_in">width</span> / mapView.<span class="hljs-built_in">width</span>,<br>mainView.<span class="hljs-built_in">height</span> / mapView.<span class="hljs-built_in">height</span>)<br></code></pre></td></tr></table></figure><p>令上面的算式=size，下面两张图是size*1、2的效果。 可见其实size *1的效果已经不错了，但是 *2 效果可以更好。</p><p>*<em>size * 1*</em></p><p><img src="https://cdn.jsdelivr.net/gh/emhui/oss@master/uPic/wgFEZq.png" alt="wgFEZq"></p><p>*<em>size * 2*</em></p><p><img src="https://cdn.jsdelivr.net/gh/emhui/oss@master/uPic/sfffrS.png" alt="sfffrS"></p><p><a href="https://developers.arcgis.com/javascript/latest/sample-code/sandbox/index.html?sample=overview-map">Overview Sample</a></p><h3 id="2D和3D同步切换"><a href="#2D和3D同步切换" class="headerlink" title="2D和3D同步切换"></a>2D和3D同步切换</h3><p><img src="https://cdn.jsdelivr.net/gh/emhui/oss@master/uPic/Y3EIi3.png" alt="Y3EIi3"></p><p><a href="https://developers.arcgis.com/javascript/latest/sample-code/sandbox/index.html?sample=views-synchronize">views-synchronize</a></p><h4 id="代码讲解"><a href="#代码讲解" class="headerlink" title="代码讲解"></a>代码讲解</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>  &lt;head&gt;<br>    &lt;meta charset=<span class="hljs-string">&quot;utf-8&quot;</span> /&gt;<br>    &lt;meta<br>      name=<span class="hljs-string">&quot;viewport&quot;</span><br>      content=<span class="hljs-string">&quot;initial-scale=1,maximum-scale=1,user-scalable=no&quot;</span><br>    /&gt;<br>    &lt;title&gt;Synchronize MapView and SceneView - <span class="hljs-number">4.14</span>&lt;/title&gt;<br><br>    &lt;style&gt;<br>      html,<br>      body &#123;<br>        padding: <span class="hljs-number">0</span>;<br>        margin: <span class="hljs-number">0</span>;<br>        height: <span class="hljs-number">100</span>%;<br>      &#125;<br>    &lt;/style&gt;<br><br>    &lt;link<br>      rel=<span class="hljs-string">&quot;stylesheet&quot;</span><br>      href=<span class="hljs-string">&quot;https://js.arcgis.com/4.14/esri/themes/light/main.css&quot;</span><br>    /&gt;<br>    &lt;script src=<span class="hljs-string">&quot;https://js.arcgis.com/4.14/&quot;</span>&gt;&lt;/script&gt;<br><br>    &lt;script&gt;<br>      <span class="hljs-built_in">require</span>([<br>        <span class="hljs-string">&quot;esri/Map&quot;</span>,<br>        <span class="hljs-string">&quot;esri/views/MapView&quot;</span>,<br>        <span class="hljs-string">&quot;esri/views/SceneView&quot;</span>,<br>        <span class="hljs-string">&quot;esri/core/watchUtils&quot;</span><br>      ], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">Map</span>, MapView, SceneView, watchUtils</span>) </span>&#123;<br>        <span class="hljs-keyword">var</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(&#123;<br>          basemap: <span class="hljs-string">&quot;satellite&quot;</span><br>        &#125;);<br><br>        <span class="hljs-keyword">var</span> view1 = <span class="hljs-keyword">new</span> SceneView(&#123;<br>          id: <span class="hljs-string">&quot;view1&quot;</span>,<br>          container: <span class="hljs-string">&quot;view1Div&quot;</span>,<br>          map: map<br>        &#125;);<br><br>        <span class="hljs-keyword">var</span> view2 = <span class="hljs-keyword">new</span> MapView(&#123;<br>          id: <span class="hljs-string">&quot;view2&quot;</span>,<br>          container: <span class="hljs-string">&quot;view2Div&quot;</span>,<br>          map: map,<br>          constraints: &#123;<br>            <span class="hljs-comment">// Disable zoom snapping to get the best synchronization</span><br>            snapToZoom: <span class="hljs-literal">false</span><br>          &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * utility method that synchronizes the viewpoint of a view to other views</span><br><span class="hljs-comment">         * 同步视图</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">var</span> synchronizeView = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">view, others</span>) </span>&#123;<br>          others = <span class="hljs-built_in">Array</span>.isArray(others) ? others : [others];<br><br>          <span class="hljs-keyword">var</span> viewpointWatchHandle;<br>          <span class="hljs-keyword">var</span> viewStationaryHandle;<br>          <span class="hljs-keyword">var</span> otherInteractHandlers;<br>          <span class="hljs-keyword">var</span> scheduleId;<br><br>          <span class="hljs-keyword">var</span> clear = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-keyword">if</span> (otherInteractHandlers) &#123;<br>              otherInteractHandlers.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">handle</span>) </span>&#123;<br>                handle.remove();<br>              &#125;);<br>            &#125;<br>            <span class="hljs-comment">// 这是什么意思?</span><br>            <span class="hljs-comment">// viewpointWatchHandle 和 viewStatioaryHandle 对象是WatchHandle对象，其中有一个remove对象方法。用来清空监听属性</span><br>            viewpointWatchHandle &amp;&amp; viewpointWatchHandle.remove();<br>            viewStationaryHandle &amp;&amp; viewStationaryHandle.remove();<br>            scheduleId &amp;&amp; <span class="hljs-built_in">clearTimeout</span>(scheduleId);<br>            otherInteractHandlers = viewpointWatchHandle = viewStationaryHandle = scheduleId = <span class="hljs-literal">null</span>;<br>          &#125;;<br><br>            <span class="hljs-comment">// 监听当前控制视图的 交互和动画属性</span><br>          <span class="hljs-keyword">var</span> interactWatcher = view.watch(<span class="hljs-string">&quot;interacting,animation&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">            newValue</span></span><br><span class="hljs-function"><span class="hljs-params">          </span>) </span>&#123;<br>            <span class="hljs-keyword">if</span> (!newValue) &#123;<br>              <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (viewpointWatchHandle || scheduleId) &#123;<br>              <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 开始更新其他视图</span><br>            scheduleId = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>              scheduleId = <span class="hljs-literal">null</span>;<br>              <span class="hljs-comment">// 监听当前view的视点属性</span><br>              viewpointWatchHandle = view.watch(<span class="hljs-string">&quot;viewpoint&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">                newValue</span></span><br><span class="hljs-function"><span class="hljs-params">              </span>) </span>&#123;<br>                <span class="hljs-comment">// 根据新获取的视点，其他视图也同时更新它的视点</span><br>                others.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">otherView</span>) </span>&#123;<br>                  otherView.viewpoint = newValue;<br>                &#125;);<br>              &#125;);<br>            &#125;, <span class="hljs-number">0</span>);<br><br>            <span class="hljs-comment">// stop as soon as another view starts interacting, like if the user starts panning</span><br>            <span class="hljs-comment">// 如果移动其他视图，则销毁当前视图的所有变量</span><br>            otherInteractHandlers = others.map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">otherView</span>) </span>&#123;<br>              <span class="hljs-keyword">return</span> watchUtils.watch(<br>                otherView,<br>                <span class="hljs-string">&quot;interacting,animation&quot;</span>,<br>                <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>&#123;<br>                  <span class="hljs-keyword">if</span> (value) &#123;<br>                    clear();<br>                  &#125;<br>                &#125;<br>              );<br>            &#125;);<br><br>            <span class="hljs-comment">// or stop when the view is stationary again</span><br>            <span class="hljs-comment">// 当不再和视图进行交互时候，即 stationary 状态，则也注销所有变量</span><br>            <span class="hljs-comment">// 当监听的属性为True的时候执行</span><br>            viewStationaryHandle = watchUtils.whenTrue(<br>              view,<br>              <span class="hljs-string">&quot;stationary&quot;</span>,<br>              clear<br>            );<br>          &#125;);<br><br>          <span class="hljs-keyword">return</span> &#123;<br>            remove: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>              <span class="hljs-built_in">this</span>.remove = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;<br>              clear();<br>              interactWatcher.remove();<br>            &#125;<br>          &#125;;<br>        &#125;;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 同步多个View的视点</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">var</span> synchronizeViews = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">views</span>) </span>&#123;<br>        <span class="hljs-comment">/* array.map(function(currentValue,index,arr), thisValue)</span><br><span class="hljs-comment">        * 遍历所有的view</span><br><span class="hljs-comment">        * views.concat() 对当前对views进行复制一份</span><br><span class="hljs-comment">        * handles 存储一系列的同步事件</span><br><span class="hljs-comment">        */</span><br>          <span class="hljs-keyword">var</span> handles = views.map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">view, idx, views</span>) </span>&#123;<br>            <span class="hljs-keyword">var</span> others = views.concat(); <span class="hljs-comment">// 复制一份views</span><br>            others.splice(idx, <span class="hljs-number">1</span>); <span class="hljs-comment">// 删除当前视图，其他视图则是others</span><br>            <span class="hljs-keyword">return</span> synchronizeView(view, others); <span class="hljs-comment">//</span><br>          &#125;);<br><br>          <span class="hljs-keyword">return</span> &#123;<br>            remove: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>              <span class="hljs-built_in">this</span>.remove = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;<br>              handles.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">h</span>) </span>&#123;<br>                h.remove();<br>              &#125;);<br>              handles = <span class="hljs-literal">null</span>;<br>            &#125;<br>          &#125;;<br>        &#125;;<br><br>        <span class="hljs-comment">// 绑定两个视图</span><br>        synchronizeViews([view1, view2]);<br>      &#125;);<br>    &lt;/script&gt;<br>  &lt;/head&gt;<br>  &lt;body&gt;<br>    &lt;div id=<span class="hljs-string">&quot;view1Div&quot;</span> style=<span class="hljs-string">&quot;float: left; width: 50%; height: 100%;&quot;</span>&gt;&lt;/div&gt;<br>    &lt;div id=<span class="hljs-string">&quot;view2Div&quot;</span> style=<span class="hljs-string">&quot;float: left; width: 50%; height: 100%;&quot;</span>&gt;&lt;/div&gt;<br>  &lt;/body&gt;<br>&lt;/html&gt;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ArcGIS For JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ArcGIS For JS</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ceisum实现铁路仿真</title>
    <link href="/2021/01/03/Ceisum%E5%AE%9E%E7%8E%B0%E9%93%81%E8%B7%AF%E4%BB%BF%E7%9C%9F/"/>
    <url>/2021/01/03/Ceisum%E5%AE%9E%E7%8E%B0%E9%93%81%E8%B7%AF%E4%BB%BF%E7%9C%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="铁路模拟仿真实现"><a href="#铁路模拟仿真实现" class="headerlink" title="铁路模拟仿真实现"></a>铁路模拟仿真实现</h1><p>实现效果</p><p><img src="https://cdn.jsdelivr.net/gh/emhui/oss@master/uPic/lxieypx;.gif" alt="train"></p><p>内容比较多，只讲部分内容，可能有点乱。可以参考一下代码，有不懂的欢迎提问</p><h1 id="初始化变量"><a href="#初始化变量" class="headerlink" title="初始化变量"></a>初始化变量</h1><p>这些变量下面都会用到</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 运动车厢的速度</span><br><span class="hljs-keyword">let</span> velocity = <span class="hljs-number">30</span> <span class="hljs-comment">// 速度,根据他来计算到达各个点的时间</span><br><span class="hljs-comment">// 当前目标点的位置</span><br><span class="hljs-comment">// var currentIndex = 1</span><br><br><span class="hljs-comment">// 每节车厢相对上一节车厢延时一定时间到达同一个位置</span><br><span class="hljs-keyword">var</span> delayTime = <span class="hljs-number">13</span><br><br><span class="hljs-comment">// 存储所有运动中的实体对象</span><br><span class="hljs-keyword">var</span> dynamicEntities = []<br><br><span class="hljs-comment">// 运动模型数量</span><br><span class="hljs-keyword">var</span> dynamicNum = <span class="hljs-number">5</span><br><br><span class="hljs-comment">// 每节铁轨的长度，用于计算两个点之前铺设多少节铁轨</span><br><span class="hljs-keyword">var</span> modelLength = <span class="hljs-number">170</span><br><br><span class="hljs-comment">// 初始化dynamicEntitye</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; dynamicNum ; ++i) &#123;<br>    <span class="hljs-keyword">let</span> obj = &#123;<br>        entity: <span class="hljs-literal">null</span>, <span class="hljs-comment">// 实体对象</span><br>        property: <span class="hljs-keyword">new</span> Cesium.SampledPositionProperty(), <span class="hljs-comment">// 动态位置属性</span><br>        timeAndOrientationList: [],<br>        startTime: <span class="hljs-number">0</span>,<br>        endTime: <span class="hljs-number">0</span><br>    &#125;<br>    dynamicEntities.push(obj)<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="加载线路并获取位置"><a href="#加载线路并获取位置" class="headerlink" title="加载线路并获取位置"></a>加载线路并获取位置</h1><p>我们需要有一系列点路径坐标（火车运行的路径）。这里我从Google Eearth中绘制了一条线，然后导出为KML数据加载进来。</p><p><img src="https://cdn.jsdelivr.net/gh/emhui/oss@master/uPic/7MbzTG.png" alt="Google earth"></p><p>通过加载的这条路径，我们需要获取路径中每个转折点的坐标信息。通过这些转折点，我们可以完成<strong>设置铁轨位置</strong>和<strong>计算出模型实体每个时间点对应点位置</strong></p><p><strong>加载KML</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-comment">// 初始化路径 设置带时间的路径</span><br>viewer.dataSources.add(Cesium.KmlDataSource.load(routerUrl,<br>    &#123;<br>        camera: viewer.scene.camera,<br>        canvas: viewer.scene.canvas,<br>        clampToGround: <span class="hljs-literal">true</span><br>    &#125;)<br>).then(<span class="hljs-function"><span class="hljs-params">dataSource</span> =&gt;</span> &#123;<br><span class="hljs-comment">// ... 加载好后获取改路径点坐标数组</span><br>    <span class="hljs-keyword">var</span> router = dataSource.entities.getById(<span class="hljs-string">&#x27;0129AA13ED12D2857AD0&#x27;</span>);<br>    <span class="hljs-keyword">var</span> positions = router.polyline.positions._value<br>    viewer.flyTo(router)<br>    <span class="hljs-comment">// createDynamicPositions(positions) // 计算带时间的路径</span><br>    <span class="hljs-comment">// createDynamicEntity() // 根据动态路径创建模型实体</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>首先我们加载好路线后，就要获取改路线的坐标数组（每个转折点或顶点的位置）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 获取路径对象</span><br><span class="hljs-keyword">var</span> router = dataSource.entities.getById(<span class="hljs-string">&#x27;0129AA13ED12D2857AD0&#x27;</span>);<br><span class="hljs-comment">// 获取对象中的坐标数组</span><br><span class="hljs-keyword">var</span> positions = router.polyline.positions._value<br></code></pre></td></tr></table></figure><p>我们可以看一下这些数组的内容</p><p><img src="https://cdn.jsdelivr.net/gh/emhui/oss@master/uPic/IoR5O3.png" alt="IoR5O3"></p><p>在这里可以看出来，这些坐标全是笛卡尔类型。同时可以知道我们总共有13个转折点</p><p>接下来两章是重点</p><h1 id="加载铁轨"><a href="#加载铁轨" class="headerlink" title="加载铁轨"></a>加载铁轨</h1><p>效果展示</p><p><img src="https://cdn.jsdelivr.net/gh/emhui/oss@master/uPic/Kkx93r.png" alt="Kkx93r"></p><p>实现上面效果，这里我们需要做下面几步。</p><ul><li>计算每段路（两个点）之间的距离S</li><li>设置每个铁轨的固定长度L</li><li>计算每段路可以铺设多少个模型 num = S / L</li><li>通过每段路两端的点的坐标，计算出这段中每个铁轨模型的位置</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-comment">// 这个是每个模型的长度，在一开始的时候就定义了</span><br><span class="hljs-comment">// var modelLength = 170</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">repeateModel</span>(<span class="hljs-params">posCart1, posCart2</span>) </span>&#123;<br>    <span class="hljs-comment">// 需要摆放模型的数量</span><br>    <span class="hljs-comment">// 模型的数量 = 两个点之间的长度 / 每个模型的长度</span><br>    <span class="hljs-keyword">let</span> modelNum = <span class="hljs-built_in">parseInt</span>(computeDistance(posCart1, posCart2) / modelLength)<br>    <span class="hljs-comment">// 根据两个点的经纬度调整每个模型的方向</span><br>    <span class="hljs-keyword">let</span> heading = computeOrientation(posCart1, posCart2)<br>    <span class="hljs-comment">// 开始计算每个模型的位置</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; modelNum; ++i) &#123;<br>    <span class="hljs-comment">// 求第i个点的位置。下面有介绍为什么这样写</span><br>        <span class="hljs-keyword">var</span> mid = <span class="hljs-keyword">new</span> Cesium.Cartesian3()<br>        Cesium.Cartesian3.add(<br>            Cesium.Cartesian3.multiplyByScalar(posCart1, i / modelNum, <span class="hljs-keyword">new</span> Cesium.Cartesian3()),<br>            Cesium.Cartesian3.multiplyByScalar(posCart2, (modelNum - i) / modelNum, <span class="hljs-keyword">new</span> Cesium.Cartesian3()),<br>            mid<br>        )<br><span class="hljs-comment">// 计算出位置后，添加铁轨模型到Viewer中。同时调整模型的方向</span><br>        viewer.entities.add(&#123;<br>            position: mid,<br>            model: &#123;<br>                uri: modelRailwayUrl,<br>                scale: <span class="hljs-number">0.025</span><br>            &#125;,<br>            orientation: changeOrientation(mid, heading)<br>        &#125;)<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>两个坐标之前第i的位置如何求</strong></p><p>先看一下下面的一道数学题</p><p><img src="https://cdn.jsdelivr.net/gh/emhui/oss@master/uPic/bJgWdB.png" alt="bJgWdB"></p><p>通过这道题，我们就可以写出下面代码，求出第i个点的位置了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">Cesium.Cartesian3.add(<br>    Cesium.Cartesian3.multiplyByScalar(posCart1, i / modelNum, <span class="hljs-keyword">new</span> Cesium.Cartesian3()),<br>    Cesium.Cartesian3.multiplyByScalar(posCart2, (modelNum - i) / modelNum, <span class="hljs-keyword">new</span> Cesium.Cartesian3()),<br>    mid<br>)<br></code></pre></td></tr></table></figure><p><strong>模型方向问题</strong></p><p>在上面代码中。我们经常要用到一个计算模型方向和改变模型方向的函数，那么为什么要计算模型的方向呢？</p><p>我们打开铁轨模型和系统自带的一些模型。看看他们的方向</p><p>使用下面命令调出查看方向的小工具</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">viewer.extend(Cesium.viewerCesiumInspectorMixin);<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/emhui/oss@master/uPic/EUBOGy.png" alt="EUBOGy"></p><p>可以看到，我们的模型的方向默认位置是朝向南方（红色是东方，绿色是北方）。而官网的模型方向默认是东方。根据官方对模型的描述</p><blockquote><p>By default, the model is oriented upright and facing east. Control the orientation of the model by specifying a Quaternion for the Entity.orientation property. This controls the heading, pitch, and roll of the model.</p></blockquote><p>可以看到，我们的模型方向是有问题。因此需要手动纠正。查阅很多方法，无法从模型本身入手。所以只能通过代码的方式来纠正方向。大概的思路是先计算出两个点的方向，然后在向东方偏移90度左右即可。</p><p><strong>计算方向函数</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">computeOrientation</span>(<span class="hljs-params">posCart1, posCart2</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> heading = bearing(<br>        Cesium.Cartographic.fromCartesian(posCart1).latitude,<br>        Cesium.Cartographic.fromCartesian(posCart1).longitude,<br>        Cesium.Cartographic.fromCartesian(posCart2).latitude,<br>        Cesium.Cartographic.fromCartesian(posCart2).longitude<br>    )<br>    <span class="hljs-keyword">return</span> heading<br>&#125;<br>        <span class="hljs-comment">// 计算两点之间的方向</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bearing</span>(<span class="hljs-params">startLat, startLng, destLat, destLng</span>) </span>&#123;<br>    startLat = Cesium.Math.toRadians(startLat);<br>    startLng = Cesium.Math.toRadians(startLng);<br>    destLat = Cesium.Math.toRadians(destLat);<br>    destLng = Cesium.Math.toRadians(destLng);<br><br>    <span class="hljs-keyword">let</span> y = <span class="hljs-built_in">Math</span>.sin(destLng - startLng) * <span class="hljs-built_in">Math</span>.cos(destLat);<br>    <span class="hljs-keyword">let</span> x = <span class="hljs-built_in">Math</span>.cos(startLat) * <span class="hljs-built_in">Math</span>.sin(destLat) - <span class="hljs-built_in">Math</span>.sin(startLat) * <span class="hljs-built_in">Math</span>.cos(destLat) * <span class="hljs-built_in">Math</span>.cos(destLng - startLng);<br>    <span class="hljs-keyword">let</span> brng = <span class="hljs-built_in">Math</span>.atan2(y, x);<br>    <span class="hljs-keyword">let</span> brngDgr = Cesium.Math.toDegrees(brng);<br>    <span class="hljs-keyword">return</span> (brngDgr + <span class="hljs-number">360</span>) % <span class="hljs-number">360</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>改变模型的位置</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">changeOrientation</span>(<span class="hljs-params">position, degree</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> heading = Cesium.Math.toRadians(degree);<br>    <span class="hljs-keyword">var</span> pitch = Cesium.Math.toRadians(<span class="hljs-number">0.0</span>);<br>    <span class="hljs-keyword">var</span> roll = Cesium.Math.toRadians(<span class="hljs-number">0.0</span>);<br>    <span class="hljs-keyword">var</span> orientation = Cesium.Transforms.headingPitchRollQuaternion(position, <span class="hljs-keyword">new</span> Cesium.HeadingPitchRoll(heading, pitch, roll));<br>    <span class="hljs-keyword">return</span> orientation<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="加载运动的车头和车厢"><a href="#加载运动的车头和车厢" class="headerlink" title="加载运动的车头和车厢"></a>加载运动的车头和车厢</h1><p>这里我们需要了解一个知识。<a href="https://www.jianshu.com/p/f0b47997224c">Cesium的Property机制总结</a>.<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="Cesium的Property机制总结">[1]</span></a></sup>这篇文章中，我们可以看到一个属性<code>SampledPositionProperty</code>,它可以使用物体的运动。</p><p><img src="https://upload-images.jianshu.io/upload_images/80648-366b91d38f419afa.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/296/format/webp" alt="move"></p><p>它的实现代码如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> property = <span class="hljs-keyword">new</span> Cesium.SampledPositionProperty();<br><br>property.addSample(Cesium.JulianDate.fromIso8601(<span class="hljs-string">&#x27;2019-01-01T00:00:00.00Z&#x27;</span>),<br>    Cesium.Cartesian3.fromDegrees(-<span class="hljs-number">114.0</span>, <span class="hljs-number">40.0</span>, <span class="hljs-number">300000.0</span>));<br><br>property.addSample(Cesium.JulianDate.fromIso8601(<span class="hljs-string">&#x27;2019-01-03T00:00:00.00Z&#x27;</span>),<br>    Cesium.Cartesian3.fromDegrees(-<span class="hljs-number">114.0</span>, <span class="hljs-number">45.0</span>, <span class="hljs-number">300000.0</span>));<br><br>blueBox.position = property;<br></code></pre></td></tr></table></figure><p>它的原理是，Entity在不同的时间运动到不同的位置。因此我们的火车运动也是一样，在不同的时候运动到不同的位置即可。那么如何实现呢？</p><p>还是通过之前获取的铁轨路径数组，再计算到达每个转折点的时间。构成一个如下图所示的数据结构。</p><p><img src="https://cdn.jsdelivr.net/gh/emhui/oss@master/uPic/XzFZ1f.png" alt="XzFZ1f"></p><p>如何让模型运动起来也可以总结为下面这张图</p><p><img src="https://cdn.jsdelivr.net/gh/emhui/oss@master/uPic/Eg6FPk.png" alt="Eg6FPk"></p><p>比如4点的时候在position1位置，4.30的时候在position2位置。4.50的时候在position3位置。</p><p>那么现在时间点应该如何计算</p><p>我们设置一个速度变量V，然后计算两点的距离S。那么到达下一个的时间就是</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">time</span> = S / V<br></code></pre></td></tr></table></figure><p>因此实现代码如下（伪代码）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 计算到下一个坐标所花费的时间</span><br><span class="hljs-keyword">let</span> time2Next = computeTime(datas[index], datas[index + <span class="hljs-number">1</span>])<br><span class="hljs-comment">// 计算到达改点的时刻</span><br><span class="hljs-keyword">let</span> time = totalTime + time2Next<br><span class="hljs-comment">// 将时刻+位置信息写入到模型的位置变量中</span><br>dynamicEntity.property.addSample(<br>    Cesium.JulianDate.addSeconds(start, time, <span class="hljs-keyword">new</span> Cesium.JulianDate()),<br>    position<br>)<br><span class="hljs-comment">// 计算总花费时间</span><br>totalTime += time2Next<br><br></code></pre></td></tr></table></figure><p>这里又有新的问题。</p><p>我们需要好几节车厢一起运动，如何实现呢？</p><p>使用延时启动，就是每一个车厢到达一个转折点的时间都比上一节车厢晚一段时间。如下图所示，不同的车厢在不同的时间点的位置不一样。</p><p><img src="https://cdn.jsdelivr.net/gh/emhui/oss@master/uPic/Lp33qj.png" alt="Lp33qj"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> time = totalTime + delayTime * i<br></code></pre></td></tr></table></figure><p>我们看一下实现效果,车厢是一节在一节的后面出现的</p><p><img src="https://cdn.jsdelivr.net/gh/emhui/oss@master/uPic/lxiemjmjiuxm.gif" alt="train"></p><p>通过代码实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createDynamicPositions</span>(<span class="hljs-params">positions</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> length = positions.length<br>    <span class="hljs-keyword">var</span> totalTime = <span class="hljs-number">0</span><span class="hljs-comment">// 跑完全部路程的时间</span><br>    <span class="hljs-comment">// 遍历铁轨路径的每个转折点</span><br>    positions.forEach(<span class="hljs-function">(<span class="hljs-params">position, index, datas</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">// 在每个路径转角处创建一个Point对象</span><br>        CreatePoint(position, index)<br>        <span class="hljs-keyword">if</span> (index + <span class="hljs-number">1</span> &lt; length) &#123;<br>            <span class="hljs-comment">// 计算一个点到另一点需要到时间</span><br>            <span class="hljs-keyword">let</span> time2Next = computeTime(datas[index], datas[index + <span class="hljs-number">1</span>])<br>            <span class="hljs-comment">// 计算两个转角点的方向</span><br>            <span class="hljs-keyword">let</span> orientation = computeOrientation(datas[index], datas[index + <span class="hljs-number">1</span>])<br>            <span class="hljs-comment">// 为每个车厢模型设置 时间+位置</span><br>            dynamicEntities.forEach(<span class="hljs-function">(<span class="hljs-params">dynamicEntity, i</span>) =&gt;</span> &#123;<br>            <span class="hljs-comment">// 这里实现了 每个模型都相对于之前都个模型延时一定时间进行启动</span><br>                <span class="hljs-keyword">let</span> time = totalTime + delayTime * i<br>                dynamicEntity.property.addSample(<br>                    Cesium.JulianDate.addSeconds(start, time, <span class="hljs-keyword">new</span> Cesium.JulianDate()),<br>                    position<br>                )<br>                <span class="hljs-comment">// 记录每个模型分别达到一个点的时间、方向、位置</span><br>                <span class="hljs-keyword">let</span> obj = &#123;<br>                    time: totalTime, <span class="hljs-comment">// 到达下一个点需要耗费的时间,它是一个数值，不是一个时间点</span><br>                    position: position,<br>                    orientation: orientation<br>                &#125;<br><br>                <span class="hljs-comment">// 计算开始时间</span><br>                <span class="hljs-keyword">if</span> (index === <span class="hljs-number">0</span>) &#123;<br>                    dynamicEntity.startTime = Cesium.JulianDate.addSeconds(start, time, <span class="hljs-keyword">new</span> Cesium.JulianDate())<br>                &#125;<br><br>                <span class="hljs-comment">// 计算最后一个时间</span><br>                <span class="hljs-keyword">if</span> (index + <span class="hljs-number">2</span> === length) &#123;<br>                    dynamicEntity.endTime = Cesium.JulianDate.addSeconds(start, time, <span class="hljs-keyword">new</span> Cesium.JulianDate())<br>                &#125;<br>                <span class="hljs-comment">// 将计算得到的 时间+位置 属性存储到每个实体中</span><br>                dynamicEntity.timeAndOrientationList.push(obj)<br><br>            &#125;)<br><br>            totalTime += time2Next<br><br>        &#125;<br>    &#125;);<br></code></pre></td></tr></table></figure><p>这里我们发现我们也计算了每个模型的方向，为什么要计算方向呢？在上面设置铁轨的时候讲到了，因为我们的模型方向默认是有点问题的。默认朝向南方，因此需要手动调整方向，我们需要自己写一个方法，判断到了转角处进行转向。（如果是模型默认朝向东方的话，则不需要使用该方法，直接使用自带的一种方法，具体方法后面再谈）</p><p>如何实现到了转角处自动转向呢？我们在刚刚上一步的时候记录了每个模型到达某个位置的时候是在是什么时间点。因此只需要判断，当前模型运行的时间是否到了转角的时间点，到了的话就开始转向，而这个方向我们同时也在上一步的时候存储到每个实体中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;<br>    time: totalTime, <span class="hljs-comment">// 到达下一个点需要耗费的时间,它是一个数值，不是一个时间点</span><br>    position: position,<br>    orientation: orientation<br>&#125;<br></code></pre></td></tr></table></figure><p>监听当前时间点并转向的代码如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript">viewer.clock.onTick.addEventListener(<span class="hljs-function">(<span class="hljs-params">clock</span>) =&gt;</span> &#123;<br><span class="hljs-comment">// 判断每个运动的模型当前是否到了转向时间</span><br>    dynamicEntities.forEach(<span class="hljs-function"><span class="hljs-params">dynamicEntity</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 计算每个运动的模型与模型的开始时间差</span><br>        <span class="hljs-keyword">let</span> timeOffset = Cesium.JulianDate.secondsDifference(clock.currentTime, dynamicEntity.startTime);<br>        <span class="hljs-comment">// 判断是否达到转向的时间点</span><br>        dynamicEntity.timeAndOrientationList.forEach(<span class="hljs-function">(<span class="hljs-params">obj, index, array</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (timeOffset &gt;= obj.time &amp;&amp; timeOffset &lt;= array[index + <span class="hljs-number">1</span>].time) &#123;<br>                <span class="hljs-comment">// 177在第一条铁轨是一个好的角度</span><br>                dynamicEntity.entity.orientation = changeOrientation(obj.position, obj.orientation + <span class="hljs-number">180</span>)<br>            &#125;<br>        &#125;)<br>    &#125;)<br></code></pre></td></tr></table></figure><p>如果模型的方向是正确的，只需要在创建模型实体对象的时候，指定该属性即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">orientation: <span class="hljs-keyword">new</span> Cesium.VelocityOrientationProperty(dynamicEntity.property),<br></code></pre></td></tr></table></figure><p>目前还有下面问题暂时无法解决</p><ul><li>各个模型之间的衔接不好</li></ul><blockquote><p>经过测试如果模型的方向是正确的话，那么就可以解决这个问题。所以可以从模型入手，更改模型的默认方向，使它默认朝向东方，但是自己一直没有找到如何编辑GLB模型。所以暂时无解。</p></blockquote><section class="footnotes"><h2>参考</h2><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.jianshu.com/p/f0b47997224c">Cesium的Property机制总结</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Cesium</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Cesium</tag>
      
      <tag>铁路</tag>
      
      <tag>仿真</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo注意事项</title>
    <link href="/2021/01/03/hexo%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <url>/2021/01/03/hexo%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<p><code>hexo clean &amp;&amp; hexo d</code></p><p><del>如果使用这个命令，可能会清除<strong>CNAME</strong>文件</del></p><p>保持永久域名的方法</p><p>在<code>/source</code>目录下面建立一个文件<code>CNAME</code>,然后填入你的域名即可。<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="脚注">[1]</span></a></sup></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><h2>参考</h2><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://hexo.fluid-dev.com/docs/guide/#%E8%84%9A%E6%B3%A8">脚注</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>域名</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/11/12/hello-world/"/>
    <url>/2020/11/12/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
